<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>Clippings from Domain-Driven Design - Yiming Chen</title>
  <meta charset="utf-8" />
  <meta name="author" content="Yiming Chen" />
  <meta name="keywords" content="Domain-Driven Design, DDD" />

  <link rel="alternate" title="RSS Feed" href="/rss.xml" type="application/rss+xml">
  <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  <link rel="stylesheet" href="/media/css/posts.css" type="text/css">
  <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
  <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>

  <script src="/media/js/main.js"></script>
</head>

  <body class="container">
<header id="header">
    <body>
        <nav class="navbar navbar-default navbar-fixed-top" style="opacity: .9" role="navigation">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">Yiming Chen</a>
                </div>
                <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="/blog/">Blog</a></li>
                        <li><a href="/clipping/">Clipping</a></li>
                        <li><a href="/tags/">Tags</a></li>
                        <li><a href="/about/">About</a></li>
                        <li><a href="https://github.com/dsdshcym">GitHub</a></li>
                        <li><a href="/rss.xml">RSS</a></li>
                        <li><a href="https://webring.xxiivv.com/#random">Webring</a></li>
                    </ul>
                </div>
            </div>
        </nav>
    </body>
</header>

<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>Clippings from Domain-Driven Design</h1>

<div id="outline-container-org1e56b99" class="outline-2">
<h2 id="org1e56b99">Foreword</h2>
<div class="outline-text-2" id="text-org1e56b99">
<ul class="org-ul">
<li>The key to controlling complexity is a good domain model,
<ul class="org-ul">
<li>a model that goes beyond a surface vision of a domain by
introducing an underlying structure,</li>
<li>which gives the software developers the leverage they need.</li>
</ul></li>
<li><b>You shouldn't separate the concepts from the implementation</b>
<ol class="org-ol">
<li>you cannot build a useful conceptual model without considering
implementation issues.</li>
<li>The greatest value of a domain model is that it provides a
<b>ubiquitous language</b> that ties domain experts and technologists
together.</li>
</ol></li>
<li><b>Domain models aren't first modeled and then implemented.</b>
<ol class="org-ol">
<li>the really powerful domain models evolve over time</li>
<li>even the most experienced modelers find that they gain their best
ideas after the initial releases of a system.</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-orgf1d0c80" class="outline-2">
<h2 id="orgf1d0c80">Preface</h2>
<div class="outline-text-2" id="text-orgf1d0c80">
<ul class="org-ul">
<li>This book provides a framework for making design decisions and a
technical vocabulary for discussing domain design.
<ul class="org-ul">
<li>It is a synthesis of widely accepted best practices along with my
own insights and experiences.</li>
<li>Software development teams facing complex domains can use this
framework to approach domain-driven design systematically.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org96b12e0" class="outline-3">
<h3 id="org96b12e0">Contrasting Three Projects</h3>
<div class="outline-text-3" id="text-org96b12e0">
<dl class="org-dl">
<dt>A project lacking a domain model</dt><dd>over-came by business logic</dd>
<dt>A project emphasizing domain design</dt><dd>The design became easier to modify and extend</dd>
<dt>A project designed poorly</dt><dd>Repeated iteration produced no improvement</dd>
</dl>
</div>
</div>
<div id="outline-container-org97b2589" class="outline-3">
<h3 id="org97b2589">The Challenge of Complexity</h3>
<div class="outline-text-3" id="text-org97b2589">
<ul class="org-ul">
<li><b>The approach to design largely determines how complex software can
become</b></li>
<li><b>The most significant complexity of many applications is in the
domain itself</b>, the activity or business of the user, (not
technical).</li>
<li>The premise of this book:
<ol class="org-ol">
<li>For most software projects, the primary focus should be on the
domain and domain logic.</li>
<li>Complex domain designs should be based on a model.</li>
</ol></li>
<li>Domain-driven design, aimed at accelerating software projects that have to
deal with complicated domains, is both
<ol class="org-ol">
<li>a way of thinking</li>
<li>a set of priorities,</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-orgd3ca068" class="outline-3">
<h3 id="orgd3ca068">Design Versus Development Process</h3>
<div class="outline-text-3" id="text-orgd3ca068">
<ul class="org-ul">
<li>Design and process are inextricable
<ul class="org-ul">
<li>When people learn design techniques, they feel excited by the
possibilities. Then the messy realities of a real project descend
on them.
<ol class="org-ol">
<li>They can't fit the new design ideas with the technology they
must use.</li>
<li>They don't know when to let go of a particular design aspect in
the interest of time and when to dig in their heels and find a
clean solution.</li>
</ol></li>
<li>Two (Agile) practices are prerequisites for applying the approach
in this book.
<ol class="org-ol">
<li><i>Development is iterative</i></li>
<li><i>Developers and domain experts have a close relationship</i></li>
</ol></li>
<li>Extreme Programming Explained: Embrace Change, 2nd Edition</li>
<li>This book intertwines design and development practice and
<b>illustrates how domain-driven design and Agile development
reinforce each other</b>.
<ol class="org-ol">
<li>A sophisticated approach to domain modeling within the context
of an Agile development process will accelerate development.</li>
<li>The interrelationship of process with domain development makes
this approach more practical than any treatment of "pure"
design in a vacuum.</li>
</ol></li>
</ul></li>
<li>although fear of unanticipated requirements often leads to
over-engineering, the attempt to avoid over-engineering can develop
into another fear: <b>a fear of doing any deep design thinking at
all</b>.</li>
<li>XP works best for developers with a sharp design sense
<ol class="org-ol">
<li>past design choices make refactoring itself either easier or
harder</li>
<li>model and design choices clarify or confuse communication</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org9710efb" class="outline-3">
<h3 id="org9710efb">The Structure of This Book</h3>
</div>
<div id="outline-container-org92c4b8d" class="outline-3">
<h3 id="org92c4b8d">Who Should Read This Book</h3>
<div class="outline-text-3" id="text-org92c4b8d">
<ul class="org-ul">
<li>this book will fill in gaps and provide perspective on how object
modeling fits into real life on a software project</li>
<li>learn to apply sophisticated modeling and design skills to practical
problems.</li>
</ul>
</div>
</div>
<div id="outline-container-orgde58519" class="outline-3">
<h3 id="orgde58519">A Domain-Driven Team</h3>
<div class="outline-text-3" id="text-orgde58519">
<ul class="org-ul">
<li>Domain-driven design is a difficult technical challenge that can pay
off big, opening opportunities just when most software projects
begin to ossify into legacy.</li>
<li>The biggest gains come when a team joins together to apply a
domain-driven design approach and to move the domain model to the
project's center of discourse.
<ol class="org-ol">
<li>the team members will share a language that enriches their
communication and keeps it connected to the software.</li>
<li>They will produce a lucid implementation in step with a model,
giving leverage to application development.</li>
<li>They will share a map of how the design work of different teams
relates, and they will systematically focus attention on the
features that are most distinctive and valuable to the
organization.</li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5244839" class="outline-2">
<h2 id="org5244839">Part I: Putting the Domain Model to Work</h2>
<div class="outline-text-2" id="text-org5244839">
<ul class="org-ul">
<li><p>
What is a Model?
</p>
<pre class="example">
18th century Chinese map is a wrong model of this world
</pre>
<ul class="org-ul">
<li><b>A model is a selectively simplified and consciously structured form
of knowledge</b>
<ul class="org-ul">
<li>An appropriate model makes sense of information and focuses it on
a problem</li>
<li>Different forms of a model
<ol class="org-ol">
<li>A diagram</li>
<li>Carefully written code</li>
<li>An English sentence</li>
</ol></li>
</ul></li>
<li>Domain modeling is not a matter of making as "realistic" a model as
possible.</li>
</ul></li>
<li>The Utility of a Model in DDD
<ol class="org-ol">
<li>The model and the heart of the design shape each other</li>
<li>The model is the backbone of a language used by all team members</li>
<li>The model is distilled knowledge</li>
</ol></li>
<li>The Heart of Software
<ul class="org-ul">
<li>The heart of software is its ability to solve domain-related
problems for its user</li>
<li>There are systematic ways of thinking that developers can employ
to search for insight and produce effective models.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgbb12b51" class="outline-3">
<h3 id="orgbb12b51">Chapter One. Crunching Knowledge</h3>
<div class="outline-text-3" id="text-orgbb12b51">
<ul class="org-ul">
<li>A Real-world Example (PCB)
<ol class="org-ol">
<li>They (PCB designers) constantly corrected me, and as they did I
started to learn. We ironed out collisions and ambiguities in
their terminology and differences between their technical
opinions, and they learned. They began to explain things more
precisely and consistently, and we started to develop a model
together.</li>
<li>As the (PCB) engineers described new features they needed, I made
them walk me through scenarios of how the objects
interacted. When the model objects couldn't carry us through an
important scenario, we brainstormed new ones or changed old ones,
crunching their knowledge. We refined the model; the code
coevolved. A few months later the PCB engineers had a rich tool
that exceeded their expectations.</li>
</ol></li>
<li>Ingredients of Effective Modeling
<ol class="org-ol">
<li>Binding the model and the implementation</li>
<li>Cultivating a language based on the model</li>
<li>Developing a knowledge-rich model
<ol class="org-ol">
<li>The objects had behavior and enforced rules.</li>
<li>The model wasn't just a data schema; it was integral to
solving a complex problem.</li>
<li>It captured knowledge of various kinds.</li>
</ol></li>
<li>Distilling the model</li>
<li>Brainstorming and experimenting</li>
</ol></li>
</ul>
</div>
<div id="outline-container-orga9e5759" class="outline-4">
<h4 id="orga9e5759">Knowledge Crunching</h4>
<div class="outline-text-4" id="text-orga9e5759">
<ul class="org-ul">
<li><b>Effective domain modelers are knowledge crunchers.</b></li>
<li>Knowledge crunching is not a solitary activity.
<ul class="org-ul">
<li>A team of developers and domain experts collaborate,</li>
<li>typically led by developers.</li>
</ul></li>
<li><p>
Waterfall method completely lacks feedback
</p>
<pre class="example">
The analysts have full responsibility for creating the model, based
only on input from the business experts. They have no opportunity to
learn from the programmers or gain experience with early versions of
software. Knowledge trickles in one direction, but does not
accumulate.
</pre></li>
<li>Other projects use an iterative process, but they fail to build up
knowledge because they don't abstract.
<ul class="org-ul">
<li><b>If programmers are not interested in the domain, they learn only
what the application should do, not the principles behind it.</b></li>
<li>Useful software can be built that way, but the project will
never arrive at a point where powerful new features unfold as
corollaries to older features.</li>
</ul></li>
<li>Without collaboration with domain experts, the concepts
(abstracted by programmers) are naive
<ul class="org-ul">
<li>That shallowness of knowledge produces software that does a
basic job but lacks a deep connection to the domain expert's way
of thinking.</li>
</ul></li>
<li>The interaction between team members changes as all members crunch
the model together.
<dl class="org-dl">
<dt>Because analysts and programmers are feeding into it</dt><dd>it is cleanly organized and abstracted, so it can provide
leverage for the implementation.</dd>
<dt>Because the domain experts are feeding into it</dt><dd>the model reflects deep knowledge of the business.</dd>
</dl></li>
<li>As the model improves, it becomes <b>a tool for organizing the
information that continues to flow through the project</b>.</li>
</ul>
</div>
</div>
<div id="outline-container-org6b1c7f5" class="outline-4">
<h4 id="org6b1c7f5">Continuous Learning</h4>
<div class="outline-text-4" id="text-org6b1c7f5">
<ul class="org-ul">
<li>When we set out to write software, we never know enough.
<ul class="org-ul">
<li><b>we don't realize how much we don't know</b> -&gt; domains that seem
less technically daunting can be deceiving</li>
</ul></li>
<li>All projects leak knowledge, and the knowledge is fragmented
again.
<ol class="org-ol">
<li>People who have learned something move on.</li>
<li>Reorganization scatters the team</li>
<li>Crucial subsystems are out-sourced in such a way that code is
delivered but knowledge isn't.</li>
<li>With typical design approaches, the code and documents don't
express this hard-earned knowledge in a usable form, so <b>when
the oral tradition is interrupted for any reason</b>, the
knowledge is lost.</li>
</ol></li>
<li>For developers:
<ol class="org-ol">
<li>Technical knowledge</li>
<li>General domain-modeling skills</li>
<li><b>The specific domain they are working on</b>
<ul class="org-ul">
<li>The goal is to <b>learn how to talk to domain experts</b></li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org47d8058" class="outline-4">
<h4 id="org47d8058">Knowledge-Rich Design</h4>
<div class="outline-text-4" id="text-org47d8058">
<ul class="org-ul">
<li>Business <b>activities</b> and <b>rules</b> are as central to a domain as are
the entities involved (<i>the nouns</i>)</li>
<li>Example: Extracting a Hidden Concept
<ul class="org-ul">
<li>Overbooking in the shipping industry</li>
<li><b>An important business rule may be hidden as a guard clause</b> in an
application method
<ol class="org-ol">
<li>As written, it is unlikely that any business expert could read
this code to verify the rule, even with the guidance of a
developer.</li>
<li>It would be difficult for a technical, non-businessperson to
connect the requirement text with the code.</li>
</ol></li>
<li>Focus on the important rules and minimize or separate everything
else.</li>
<li>The more explicit design has these advantages:
<ol class="org-ol">
<li>In order to bring the design to this stage, the programmers and
everyone else involved will have come to understand the nature
of overbooking as a distinct and important business rule, not
just an obscure calculation.</li>
<li>Programmers can show business experts technical artifacts, even
code, that should be intelligible to domain experts (with
guidance), thereby closing the feedback loop.</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2d6cce1" class="outline-4">
<h4 id="org2d6cce1">Deep Models</h4>
<div class="outline-text-4" id="text-org2d6cce1">
<ul class="org-ul">
<li>Useful models seldom lie on the surface.
<ul class="org-ul">
<li>As we come to understand the domain and the needs of the
application, <b>we usually discard superficial model elements that
seemed important in the beginning</b>, or <b>we shift their
perspective</b>.</li>
</ul></li>
<li><b>Knowledge crunching is an exploration, and you can't know where you
will end up.</b></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbfa0aa9" class="outline-3">
<h3 id="orgbfa0aa9">Chapter Two. Communication and the Use of Language</h3>
<div class="outline-text-3" id="text-orgbfa0aa9">
<ul class="org-ul">
<li>To make most effective use of a model, <b>it needs to pervade every
medium of communication</b>.
<ol class="org-ol">
<li>written text documents</li>
<li>informal diagrams</li>
<li>casual conversation</li>
<li>the code itself</li>
<li>the tests for code</li>
</ol></li>
</ul>
</div>
<div id="outline-container-orga0d6509" class="outline-4">
<h4 id="orga0d6509">Ubiquitous Language</h4>
<div class="outline-text-4" id="text-orga0d6509">
<ul class="org-ul">
<li>On a project without a common language
<ol class="org-ol">
<li>developers have to translate for domain experts</li>
<li>developers even translate for each other</li>
</ol></li>
<li>Translation blunts communication and makes knowledge crunching
anemic.</li>
<li><b>A project needs a common language that is more robust than the
lowest common denominator.</b></li>
<li>Use the model as the backbone of a language.
<ul class="org-ul">
<li>Commit the team to exercising that language relentlessly in all
communication within the team and in the code.</li>
<li>Iron out difficulties by experimenting with alternative
expressions, which reflect alternative models.
<ul class="org-ul">
<li>Then refactor the code, renaming classes, methods, and modules
to conform to the new model.</li>
<li>Resolve confusion over terms in conversation, in just the way we
come to agree on the meaning of ordinary words.</li>
</ul></li>
<li>Recognize that a change in the UBIQUITOUS LANGUAGE is a change to
the model.</li>
<li>Domain experts should object to terms or structures that are
awkward or inadequate to convey domain understanding;</li>
<li>Developers should watch for ambiguity or inconsistency that will
trip up design.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgcdd40a8" class="outline-4">
<h4 id="orgcdd40a8">Modeling Out Loud</h4>
<div class="outline-text-4" id="text-orgcdd40a8">
<ul class="org-ul">
<li><b>One of the best ways to refine a model is to explore with speech</b>,
trying out loud various constructs from possible model variations.
<dl class="org-dl">
<dt>vague and technical</dt><dd>"If we give the Routing Service an origin, destination, and
arrival time, it can look up the stops the cargo will have to
make and, well ... stick them in the database."</dd>
<dt>more complete, but verbose</dt><dd>"The origin, destination, and so on ... it all feeds into the
Routing Service, and we get back an Itinerary that has
everything we need in it."</dd>
<dt>concise</dt><dd>"A Routing Service finds an Itinerary that satisfies a
Route Specification."</dd>
</dl></li>
<li>Our brains seem to be somewhat specialized for <b>dealing with
complexity in spoken language</b></li>
<li><p>
An addendum to the <i>Ubiquitous language</i> pattern
</p>
<blockquote>
<ol class="org-ol">
<li>Play with the model as you talk about the system</li>
<li>Describe scenarios out loud using the elements and interactions
of the model, combining concepts in ways allowed by the model</li>
<li>Find easier ways to say what you need to say</li>
<li>Take those new ideas back down to the diagrams and code</li>
</ol>
</blockquote></li>
</ul>
</div>
</div>
<div id="outline-container-org48a6c04" class="outline-4">
<h4 id="org48a6c04">One Team, One Language</h4>
<div class="outline-text-4" id="text-org48a6c04">
<ul class="org-ul">
<li><b>If sophisticated domain experts don't understand the model, there
is something wrong with the model</b></li>
<li><i>Ubiquitous Language</i> is cultivated in the intersection of jargons
<ul class="org-ul">
<li>Developers-only language
<ul class="org-ul">
<li>Technical aspects of design</li>
<li>Technical terms</li>
<li>Technical design problems</li>
</ul></li>
<li>Ubiquitous language
<ul class="org-ul">
<li>Domain model terms</li>
<li>Names of <i>Bounded Contexts</i></li>
<li>Terminology of large-scale structure</li>
<li>Many pattern names from this book</li>
</ul></li>
<li>Domain experts-only language
<ul class="org-ul">
<li>Business terms developers don't understand</li>
<li>Business terms everyone uses that don't appear in design
(candidates to fold into model)</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgac2ad22" class="outline-4">
<h4 id="orgac2ad22">Documents and Diagrams</h4>
<div class="outline-text-4" id="text-orgac2ad22">
<ul class="org-ul">
<li>UML diagrams
<ol class="org-ol">
<li>Class diagrams</li>
<li>Object-interactions</li>
</ol></li>
<li>But a UML diagram <b>cannot</b> convey two of the most important aspects
of a model (Careful use of natural languages can fill this role
pretty well)
<ol class="org-ol">
<li>The meaning of the concepts it represents</li>
<li>What the objects are meant to do</li>
</ol></li>
<li>Diagrams are <b>a means of communication and explanation</b>, and they
facilitate brainstorming
<ul class="org-ul">
<li>They serve these ends best if <b>they are minimal</b>
<ul class="org-ul">
<li>Comprehensive diagrams of the entire object model fail to
communicate or explain
<ol class="org-ol">
<li>They overwhelm the reader with detail</li>
<li>They lack meaning</li>
</ol></li>
<li>Simplify diagrams to only containing <b>conceptually important
parts of the object model</b> that are essential to understand the
design
<ol class="org-ol">
<li>Simplify</li>
<li>Explain</li>
<li>Even incorporate a bit of nonstandard notation when it
clarifies their point</li>
</ol></li>
</ul></li>
</ul></li>
<li><i>The vital detail about the design is captured in the code</i>
<ul class="org-ul">
<li>A well-written implementation should be <b>transparent, revealing the
model underlying it</b> (what this book is about)</li>
</ul></li>
<li>Responsibilities of different mediums
<dl class="org-dl">
<dt>Code</dt><dd>Vital detail</dd>
<dt>Supplemental diagrams and documents</dt><dd>guide people's attention to the central parts</dd>
<dt>Natural language discussion</dt><dd>fill in the nuances of meaning</dd>
</dl></li>
<li><b>Write a text document illustrated with selective and simplified
diagrams</b></li>
<li><b>The model is not the diagram</b></li>
<li>Written Design Documents
<ul class="org-ul">
<li>Documents often lose their connection with the flow of the project</li>
<li>Two general guidelines for evaluating a document
<ol class="org-ol">
<li>Documents should complement code and speech
<ul class="org-ul">
<li>Cod as a design document can over-whelm the reader with
detail</li>
<li>Documents need to:
<ol class="org-ol">
<li>Illuminate meaning</li>
<li>Give insight into  large-scale structures</li>
<li>Focus attention on core elements</li>
</ol></li>
<li>Documents can <b>clarify design intent</b> when the programming
language <i>does not support a straightforward implementation
of a concept</i></li>
</ul></li>
<li>Documents should work for a living and stay current
<ul class="org-ul">
<li>A document must be involved in project activities. (Observe
the document's interaction with the UBIQUITOUS LANGUAGE.)
<ul class="org-ul">
<li>Is the document written in the language people speak on the
project (now)?</li>
<li>Is it written in the language embedded in the code?</li>
</ul></li>
<li>The UBIQUITOUS LANGUAGE allows other documents, such as
requirements specifications, to be more concise and less
ambiguous.</li>
</ul></li>
</ol></li>
</ul></li>
<li>Executable Bedrock
<ul class="org-ul">
<li><b>It takes fastidiousness to write code that doesn't just <i>do</i> the
right thing but also <i>says</i> the right thing.</b></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1198751" class="outline-4">
<h4 id="org1198751">Explanatory Models</h4>
<div class="outline-text-4" id="text-org1198751">
<ul class="org-ul">
<li><b>One model should underlie implementation, design, and team
communication.</b></li>
<li>But other models are also needed
<ol class="org-ol">
<li>To teach about the domain</li>
<li>For scope reasons
<ul class="org-ul">
<li>Provide context that clarifies the more narrowly scoped model</li>
</ul></li>
</ol></li>
<li>Explanatory models offer the freedom to create much more
communicative styles tailored to a particular topic</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9b12e76" class="outline-3">
<h3 id="org9b12e76">Chapter Three. Binding Model and Implementation</h3>
<div class="outline-text-3" id="text-org9b12e76">
<p>
<b>DDD requires a different approach to modeling</b>
</p>
</div>
<div id="outline-container-orge2dc46d" class="outline-4">
<h4 id="orge2dc46d">Model-Driven Design</h4>
<div class="outline-text-4" id="text-orge2dc46d">
<ul class="org-ul">
<li>Bad Examples
<ol class="org-ol">
<li>Projects that have no domain model at all</li>
<li>Complex projects that attempt some sort of domain model, but
don't maintain a tight connection between the model and the code
<ul class="org-ul">
<li>Design up-front model
<ul class="org-ul">
<li>Pure analysis models get abandoned soon after coding starts</li>
</ul></li>
</ul></li>
</ol></li>
<li>If the design, or some central part of it, does not map to the
domain model
<ol class="org-ol">
<li>That model is of little value</li>
<li>The correctness of the software is suspect</li>
<li>Complex mappings between models and design functions are
difficult to understand and impossible to maintain as the design
changes</li>
<li>A deadly divide opens between analysis and design, so that
insight gained in each of those activities does not feed into the
other</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org09e8ec7" class="outline-4">
<h4 id="org09e8ec7">Modeling Paradigms and Tool Support</h4>
<div class="outline-text-4" id="text-org09e8ec7">
<ul class="org-ul">
<li>Different modeling paradigms
<dl class="org-dl">
<dt>OOP</dt><dd>Object-oriented programming is powerful because it is based
on a modeling paradigm, and it provides implementations of
the model constructs.</dd>
<dt>Logic</dt><dd>a natural fit for MODEL-DRIVEN DESIGN</dd>
<dt>Procedural</dt><dd>software written in procedural languages has
complicated functions linked together based on
anticipated paths of execution, rather than by
conceptual connections in the domain model.</dd>
</dl></li>
<li>Example: From Procedural to MODEL-DRIVEN</li>
<li>Benefits of Model-Driven Design
<dl class="org-dl">
<dt>Scale easily</dt><dd>Can include constraints on combining rules and
other enhancements</dd>
<dt>Accommodate testing</dt><dd>well-defined interfaces that can be unit-tested</dd>
</dl></li>
</ul>
</div>
</div>
<div id="outline-container-org60271a5" class="outline-4">
<h4 id="org60271a5">Letting the Bones Show: Why Models Matter to Users</h4>
<div class="outline-text-4" id="text-org60271a5">
<ul class="org-ul">
<li>Trying to create in the UI an illusion of a model other than the
domain model will cause confusion unless the illusion is perfect.</li>
<li>Just by removing the misleading extra model, the power of the
application would increase and become clearer.</li>
</ul>
</div>
</div>
<div id="outline-container-orgf09235b" class="outline-4">
<h4 id="orgf09235b">Hands-On Modelers</h4>
<div class="outline-text-4" id="text-orgf09235b">
<ul class="org-ul">
<li>Software development is <b>all</b> design.</li>
<li>That model (highly skilled engineers design; less skilled laborers
assemble the products / the sharp separation of modeling and
programming) never put to work
<ol class="org-ol">
<li>Some of the model's intent was lost in the handoff</li>
<li>The indirectness of feedback from the interaction of the model
with the implementation and the technology
<ol class="org-ol">
<li>If the people who write the code do not feel responsible for
the model, or don't understand how to make the model work for
an application, then the model has nothing to do with the
software.</li>
<li>If developers don't realize that changing code changes the
model, then their refactoring will weaken the model rather
than strengthen it.</li>
<li>When a modeler is separated from the implementation process,
he or she never acquires, or quickly loses, a feel for the
constraints of implementation.</li>
<li>The knowledge and skills of experienced designers won't be
transferred to other developers if the division of labor
prevents the kind of collaboration that conveys the subtleties
of coding a Model-Driven Design.</li>
</ol></li>
</ol></li>
<li>The need for HANDS-ON MODELERS does not mean that team members
cannot have specialized roles.</li>
<li><b>The problem arises from separating two tasks that are coupled in a
MODEL-DRIVEN DESIGN, modeling and implementation.</b></li>
<li>Any technical person contributing to the model must spend some time
touching the code, whatever primary role he or she plays on the
project.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org85a92ae" class="outline-2">
<h2 id="org85a92ae">Part II: The Building Blocks of a Model-Driven Design</h2>
<div class="outline-text-2" id="text-org85a92ae">
<ul class="org-ul">
<li>Previous work
<ol class="org-ol">
<li>responsibility-driven design</li>
<li>design by contract</li>
</ol></li>
</ul>
</div>
<div id="outline-container-orgfdc7797" class="outline-3">
<h3 id="orgfdc7797">Chapter Four. Isolating the Domain</h3>
<div class="outline-text-3" id="text-orgfdc7797">
<p>
<b>Decouple the domain objects from other functions of the system</b>
</p>
</div>
<div id="outline-container-org89d68c0" class="outline-4">
<h4 id="org89d68c0">Layered Architecture</h4>
<div class="outline-text-4" id="text-org89d68c0">
<ul class="org-ul">
<li><p>
Without Layers
</p>
<pre class="example">
In an object-oriented program, UI, database, and other support code
often gets written directly into the business objects. Additional
business logic is embedded in the behavior of UI widgets and data-base
scripts. This happens because it is the easiest way to make things
work, in the short run.
</pre>
<ul class="org-ul">
<li>Implementing coherent, model-driven objects becomes impractical.</li>
<li>With all the technologies and logic involved in each activity, a
program must be kept very simple or it becomes impossible to
understand.</li>
</ul></li>
<li><b>Any element of a layer depends only on other elements in the same
layer or on elements of the layers "beneath" it.</b>
<ul class="org-ul">
<li><b>Communication upward must pass through some indirect mechanism</b></li>
</ul></li>
<li>The value of layers is that <b>each (layer) specializes in a
particular aspect</b> of a computer program.</li>
<li>Most successful architectures use some version of these four
conceptual layers:
<ol class="org-ol">
<li>UI (Presentation Layer)</li>
<li>Application Layer</li>
<li>Domain Layer (Model Layer)</li>
<li>Infrastructure Layer</li>
</ol></li>
<li>Separating the domain layer from the infrastructure and user
interface layers allows <b>a much cleaner design of each layer</b>.</li>
<li>Relating the Layers
<ul class="org-ul">
<li>MVC</li>
<li>The infrastructure layer (services)
<ul class="org-ul">
<li>Simplify the application layer</li>
<li>The application layer only needs to know <i>when</i> to send a
message, but not <i>how</i></li>
</ul></li>
</ul></li>
<li>Architectural Frameworks
<ul class="org-ul">
<li>The best architectural frameworks solve complex technical problems
while allowing the domain developer to concentrate on expressing a
model.</li>
<li>But frameworks can easily get in the way,
<ol class="org-ol">
<li>either by making too many assumptions that constrain domain
design choices</li>
<li>or by making the implementation so heavyweight that development
slows down</li>
</ol></li>
<li>A lot of the downside of frameworks can be avoided by <b>applying
them selectively to solve difficult problems</b> without looking for
a one-size-fits-all solution.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1568671" class="outline-4">
<h4 id="org1568671">The Domain Layer Is Where the Model Lives</h4>
<div class="outline-text-4" id="text-org1568671">
<ul class="org-ul">
<li>Isolating the domain implementation is a prerequisite for
domain-driven design.</li>
</ul>
</div>
</div>
<div id="outline-container-org58369f2" class="outline-4">
<h4 id="org58369f2">The Smart UI "Anti-Pattern"</h4>
<div class="outline-text-4" id="text-org58369f2">
<ul class="org-ul">
<li>SMART UI is an alternate, mutually exclusive fork in the road,
incompatible with the approach of domain-driven design</li>
<li>When to use SMART UI?
<ul class="org-ul">
<li>If an unsophisticated team with a simple project decides to try a
MODEL-DRIVEN DESIGN with LAYERED ARCHITECTURE, it will face a
difficult learning curve.</li>
</ul></li>
<li>When to use Domain-Driven Design?
<ul class="org-ul">
<li>Domain-driven design pays off best for ambitious projects, and it
does require strong skills.</li>
</ul></li>
<li>What is SMART UI? (<b>The Default Rails Stack</b>)
<ul class="org-ul">
<li>Put all the business logic into the user interface.</li>
<li>Chop the application into small functions and implement them as
separate user interfaces, embedding the business rules into them.</li>
<li>Use a relational database as a shared repository of the data.</li>
<li>Use the most automated UI building and visual programming tools
available.</li>
</ul></li>
<li>Pros &amp; Cons
<ul class="org-ul">
<li>Advantages
<ol class="org-ol">
<li>Productive</li>
<li>Less capable developers can work this way with little training</li>
<li>Even deficiencies in requirements analysis can be overcome by
releasing a prototype to users and then quickly changing the
product to fit their requests</li>
<li>Applications are decoupled from each other
<ol class="org-ol">
<li>Delivery schedules of small modules can be planned
relatively accurately</li>
<li>Expanding the system with additional, simple behavior can be
easy</li>
</ol></li>
<li>Relational databases work well and provide integration at the
data level</li>
<li>4GL tools work well</li>
<li>When applications are hand off, maintenance programmers will be
able to quickly redo portions they can't figure out, because
the effects of the changes should be localized to each
particular UI</li>
</ol></li>
<li>Disadvantages
<ol class="org-ol">
<li>Integration of applications is difficult except through the
database</li>
<li>There is no reuse of behavior and no abstraction of the
business problem - Business rules have to be duplicated in each
operation to which they apply</li>
<li>Rapid prototyping and iteration reach a natural limit because
the lack of abstraction limits refactoring options</li>
<li>Complexity buries you quickly, so the growth path is strictly
toward additional simple applications
(<b>micro-services?</b>). There is no graceful path to richer
behavior</li>
<li><b>You can't migrate to another design approach except by
replacing entire applications.</b></li>
<li>Just using a flexible language doesn't create a flexible
system, but it may well produce an expensive one.</li>
</ol></li>
</ul></li>
<li>If the architecture isolates the domain-related code in a way that
<b>allows a cohesive domain design loosely coupled to the rest of the
system</b>, then that architecture can probably support domain-driven
design.</li>
</ul>
</div>
</div>
<div id="outline-container-orgcdfa981" class="outline-4">
<h4 id="orgcdfa981">Other Kinds of Isolation</h4>
</div>
</div>
<div id="outline-container-org4d3cdca" class="outline-3">
<h3 id="org4d3cdca">Chapter Five. A Model Expressed in Software</h3>
<div class="outline-text-3" id="text-org4d3cdca">
<ul class="org-ul">
<li>3 patterns of model elements that express the model
<ul class="org-ul">
<li>Entities</li>
<li>Value Objects</li>
<li>Services</li>
</ul></li>
<li>Modules -&gt; <b>Every design decision should be motivated by some insight
into the domain</b></li>
</ul>
</div>
<div id="outline-container-orgda8d49c" class="outline-4">
<h4 id="orgda8d49c">Associations</h4>
<div class="outline-text-4" id="text-orgda8d49c">
<ul class="org-ul">
<li><b>For every traversable association in the model, there is a mechanism
in the software with the same properties</b>.</li>
<li>The design has to specify a particular traversal mechanism whose
behavior is consistent with the association in the model.</li>
<li>3 ways of making associations more tractable
<ol class="org-ol">
<li>Imposing a traversal direction</li>
<li>Adding a qualifier, effectively reducing multiplicity
<ul class="org-ul">
<li>It's important to constrain relationships as much as possible</li>
<li>Some traversal directions can reflect a natural bias in the domain
<ul class="org-ul">
<li>One direction of the association is much more meaningful and
important than the other</li>
<li>Examples
<ul class="org-ul">
<li><p>
Country &lt;-&gt; President
</p>
<pre class="example">
Country -&gt; * President
        |
        v
Country + Period -&gt; 1 President
</pre></li>
<li><p>
Brokerage Account &lt;-&gt; Investment
</p>
<pre class="example">
BrokerageAccount -&gt; * Investment
                 |
                 v
BrokerageAccount + Stock -&gt; 1 Investment
</pre></li>
</ul></li>
</ul></li>
</ul></li>
<li>Eliminating nonessential associations</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org65c1294" class="outline-4">
<h4 id="org65c1294">Entities (a.k.a. Reference Objects)</h4>
<div class="outline-text-4" id="text-org65c1294">
<ul class="org-ul">
<li><b>Many objects are not fundamentally defined by their attributes, but
rather by a thread of continuity and identity.</b></li>
<li>Their class definitions, responsibilities, attributes, and associations should
revolve around who they are, rather than the particular attributes they carry.</li>
<li>Identity is a subtle and meaningful attribute of ENTITIES, which can't be
turned over to the automatic features of the language.</li>
</ul>
</div>
</div>
<div id="outline-container-org9ab5c44" class="outline-4">
<h4 id="org9ab5c44">Value Objects</h4>
<div class="outline-text-4" id="text-org9ab5c44">
<ul class="org-ul">
<li>Many objects have no conceptual identity. These objects describe
some characteristic of a thing.</li>
<li>Tracking the identity of ENTITIES is essential, but attaching
identity to other objects can hurt system performance, add
analytical work, and muddle the model by making all objects look the
same.</li>
<li>When you care only about the attributes of an element of the model,
classify it as a VALUE OBJECT.</li>
<li>Treat the VALUE OBJECT as <b>immutable</b>.</li>
<li><b>The attributes that make up a VALUE OBJECT should form a conceptual
whole</b></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org2b1d79c"></a>Designing VALUE OBJECTS<br />
<div class="outline-text-5" id="text-org2b1d79c">
<ul class="org-ul">
<li>In order for a <i>value object</i> to be shared safely, it must be
<i>immutable</i>
<ul class="org-ul">
<li>Sharing is best restricted to those cases in which it is most
valuable and least troublesome:
<ul class="org-ul">
<li>When saving space or object count in the database is critical</li>
<li>When communication overhead is low (such as in a centralized
server)</li>
<li>When the shared object is strictly immutable</li>
</ul></li>
</ul></li>
<li>Flyweight</li>
</ul>
</div>
</li>
<li><a id="org75d8b13"></a>Designing Associations That Involve VALUE OBJECTS<br />
<div class="outline-text-5" id="text-org75d8b13">
<ul class="org-ul">
<li>Associations</li>
<li>The fewer and simpler the associations in the model, the better.</li>
<li>Try to completely eliminate bidirectional associations between VALUE
OBJECTS.</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgc5ab5c5" class="outline-4">
<h4 id="orgc5ab5c5">Services</h4>
<div class="outline-text-4" id="text-orgc5ab5c5">
<ul class="org-ul">
<li>A SERVICE is <b>an operation offered as an interface that stands alone
in the model</b>, without encapsulating state, as ENTITIES and VALUE
OBJECTS do.</li>
<li>The name service emphasizes the relationship with other objects.</li>
<li>It is defined purely in terms of what it can do for a client.</li>
<li>When an operation is actually an important domain concept, a SERVICE
forms a natural part of a MODEL-DRIVEN DESIGN</li>
<li>A good SERVICE has three characteristics.
<ol class="org-ol">
<li>The operation relates to a domain concept that is not a natural
part of an ENTITY or VALUE OBJECT.</li>
<li>The interface is defined in terms of other elements of the domain
model.</li>
<li>The operation is <b>stateless</b>.
<ul class="org-ul">
<li><b>Any client can use any instance of a particular SERVICE
without regard to the instance's individual history.</b></li>
</ul></li>
</ol></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org4fbfde4"></a>SERVICES and the Isolated Domain Layer<br />
<div class="outline-text-5" id="text-org4fbfde4">
<ul class="org-ul">
<li>Services can be in different layers
<dl class="org-dl">
<dt>Application</dt><dd>Funds Transfer App Service
<ul class="org-ul">
<li>Digests input (such as an XML request).</li>
<li>Sends message to domain service for fulfillment.</li>
<li>Listens for confirmation.</li>
<li>Decides to send notification using infrastructure service.</li>
</ul></dd>
<dt>Domain</dt><dd>Funds Transfer Domain Service
<ul class="org-ul">
<li>Interacts with necessary Account and Ledger objects, making
appropriate debits and credits.</li>
<li>Supplies confirmation of result (transfer allowed or not, and so on).</li>
</ul></dd>
<dt>Infrastructure</dt><dd>Send Notification Service
<ul class="org-ul">
<li>Sends e-mails, letters, and other communications as directed by
the application.</li>
</ul></dd>
</dl></li>
<li>Make a Facade for external services</li>
</ul>
</div>
</li>
<li><a id="org9761c0b"></a>Granularity<br />
<div class="outline-text-5" id="text-org9761c0b">
<ul class="org-ul">
<li>Services are expressive (explained as above)</li>
<li>Services are also valuable as a means of <b>controlling granularity</b> in
the interfaces of the domain layer
<ul class="org-ul">
<li>Medium-grained, stateless services can be easier to reuse in large
systems (because they encapsulate significant functionality behind
a simple interface)</li>
<li>Fine-grained objects can lead to inefficient messaging in a
distributed system</li>
</ul></li>
<li>Service pattern <b>favors interface simplicity over client control and
versatility</b></li>
</ul>
</div>
</li>
<li><a id="org14b4442"></a>Access to Services<br />
<div class="outline-text-5" id="text-org14b4442">
<ul class="org-ul">
<li>Singleton</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-orgfa0f3f3" class="outline-4">
<h4 id="orgfa0f3f3">Modules (a.k.a Packages)</h4>
<div class="outline-text-4" id="text-orgfa0f3f3">
<ul class="org-ul">
<li><b>Cognitive overload is the primary motivation for modularity</b></li>
<li>Modules give people two views of the model
<ol class="org-ol">
<li>Look at <b>detail within a module</b> without being overwhelmed by the
whole</li>
<li>Look at <b>relationships between modules</b> in views that exclude
interior detail</li>
</ol></li>
<li>Low coupling, high cohesion
<dl class="org-dl">
<dt>Low Coupling</dt><dd>There is a limit to how many things a person can
think about at once</dd>
<dt>High Cohesion</dt><dd>Incoherent fragments of ideas are as hard to
understand as an undifferentiated soup of ideas</dd>
</dl></li>
<li>Like everything else in a domain-driven design, MODULES are a
<i>communications mechanism</i>
<ul class="org-ul">
<li>The <i>meaning</i> of the objects being partitioned needs to drive the
choice of MODULES</li>
<li><b>If your model is telling a story, the MODULES are chapters</b></li>
<li>MODULES' names enter the UBIQUITOUS LANGUAGE</li>
</ul></li>
<li>Trade-off is best to got with the <b>conceptual clarity</b>
<ul class="org-ul">
<li>Even if it means more references between modules or occasional
ripple effects when changes are made to a module</li>
</ul></li>
<li>Agile Modules
<ul class="org-ul">
<li>Whatever development technology the implementation will be based
on, we need to look for ways of
<ol class="org-ol">
<li>minimizing the work of refactoring MODULES</li>
<li>minimizing clutter in communicating to other developers.</li>
</ol></li>
</ul></li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org2262171"></a>The Pitfalls of Infrastructure-Driven Packaging<br />
<div class="outline-text-5" id="text-org2262171">
<ul class="org-ul">
<li>Strong forces on our packaging decisions come from technical
frameworks. (Rails/Phoenix)</li>
<li>Tiered architectures can fragment the implementation of the model
objects</li>
<li>Elaborate technically driven packaging schemes impose two costs
<ol class="org-ol">
<li>If the framework's partitioning conventions pull apart the
elements implementing the conceptual objects, the code no longer
reveals the model</li>
<li>There is only so much partitioning a mind can stitch back
together, and if the framework uses it all up, the domain
developers lose their ability to chunk the model into meaningful
pieces</li>
</ol></li>
<li>Unless there is a real intention to distribute code on different
servers, keep all the code that implements a single conceptual
object in the same MODULE, if not the same object.</li>
<li><b>Use packaging to separate the domain layer from other code.</b>
Otherwise, leave as much freedom as possible to the domain
developers to package the domain objects in ways that support their
model and design choices.</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="outline-container-org263d48b" class="outline-4">
<h4 id="org263d48b">Modeling Paradigms</h4>
<div class="outline-text-4" id="text-org263d48b">
</div>
<ul class="org-ul">
<li><a id="orge5ec5e6"></a>Why the Object Paradigm Predominates<br />
<div class="outline-text-5" id="text-orge5ec5e6">
<ul class="org-ul">
<li>Object modeling does strike <b>a nice balance of simplicity and
sophistication</b>
<ul class="org-ul">
<li>Simplicity
<ul class="org-ul">
<li>the fundamentals of object-oriented design seem to come
naturally to most people</li>
</ul></li>
<li>Sophistication
<ul class="org-ul">
<li>Object-oriented design has proven rich enough to capture
important domain knowledge</li>
<li>Most new technologies provide the means to integrate with the
popular object-oriented platforms.</li>
<li>Equally important is the maturity of the developer community and
the design culture itself.</li>
</ul></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org9d6d479"></a>Nonobjects in an Object World<br />
<div class="outline-text-5" id="text-org9d6d479">
<ul class="org-ul">
<li>A domain model does not have to be an object model.</li>
<li>Whatever the dominant model paradigm may be on a project, there are
bound to be parts of the domain that would be much easier to express
in some other paradigm.</li>
<li>Mixing paradigms allows developers to model particular concepts in
the style that fits best.</li>
</ul>
</div>
</li>
<li><a id="org1d06c6c"></a>Sticking with MODEL-DRIVEN DESIGN When Mixing Paradigms<br />
<div class="outline-text-5" id="text-org1d06c6c">
<ul class="org-ul">
<li>Without a seamless environment, it falls on the developers to
distill a model made up of clear, fundamental concepts to hold the
whole design together.</li>
<li>The most effective tool for holding the parts together is a robust
UBIQUITOUS LANGUAGE that underlies the whole heterogeneous model.</li>
<li>4 Rules of thumb for mixing non-object elements into a predominantly
object-oriented system
<ol class="org-ol">
<li>Don't fight the implementation paradigm
<ul class="org-ul">
<li><b>There's always another way to think about a domain</b> -&gt; find
model concepts that fit the domain</li>
</ul></li>
<li>Lean on the UBIQUITOUS LANGUAGE</li>
<li>Don't get hung up on UML
<ul class="org-ul">
<li>Sometimes the fixation on a tool (UML) leads people to distort
the model to make it fit what can easily be drawn</li>
</ul></li>
<li>Be skeptical
<ul class="org-ul">
<li><b>multiple paradigms complicate matters enormously</b></li>
<li>Before taking on the burden of mixed paradigms, the options
within the dominant paradigm should be exhausted</li>
</ul></li>
</ol></li>
<li><b>The relational paradigm is a special case of paradigm mixing</b>
(which will be discussed in Chapter 6)</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orga5b9f53" class="outline-3">
<h3 id="orga5b9f53">Chapter Six. The Life Cycle of a Domain Object</h3>
<div class="outline-text-3" id="text-orga5b9f53">
<ul class="org-ul">
<li>2 Challenges
<ol class="org-ol">
<li>Maintaining integrity throughout the life cycle</li>
<li>Preventing the model from getting swamped by the complexity of
managing the life cycle</li>
</ol></li>
<li>3 Patterns
<ol class="org-ol">
<li>AGGREGATES</li>
<li>FACTORIES</li>
<li>REPOSITORIES</li>
</ol></li>
</ul>
</div>
<div id="outline-container-orgd96c4de" class="outline-4">
<h4 id="orgd96c4de">Aggregates</h4>
<div class="outline-text-4" id="text-orgd96c4de">
<ul class="org-ul">
<li>It is difficult to guarantee the consistency of changes to objects
in a model with complex associations.
<ul class="org-ul">
<li>The real world seldom obliges us with sharp boundaries (it's a
problem in a software design)</li>
<li>The web of relationships in a typical object model gives no clear
limit to the potential effect of a change</li>
</ul></li>
<li>A solution driven from the model will make the model easier to
understand and make the design easier to communicate</li>
<li>Definition
<ul class="org-ul">
<li>An AGGREGATE is a cluster of associated objects that we treat as a
unit for the purpose of data changes</li>
<li>Each AGGREGATE has a root and a boundary
<dl class="org-dl">
<dt>Root</dt><dd>a single, specific ENTITY contained in the AGGREGATE</dd>
<dt>Boundary</dt><dd>defines what is inside the AGGREGATE</dd>
</dl></li>
</ul></li>
<li>Rules
<ol class="org-ol">
<li>The root ENTITY has global identity and is ultimately responsible
for checking invariant</li>
<li>ENTITIES inside the boundary have local identity, unique only
within the AGGREGATE</li>
<li>Nothing outside the AGGREGATE boundary can hold a reference to
anything inside, except to the root ENTITY</li>
<li>Only AGGREGATE roots can be obtained directly with database
queries</li>
<li>A delete operation must remove everything within the AGGREGATE
boundary at once</li>
<li>When a change to any object within the AGGREGATE boundary is
committed, all invariant of the whole AGGREGATE must be satisfied</li>
</ol></li>
<li>AGGREGATES mark off the scope within which invariant have to be
maintained at every stage of the life cycle.</li>
</ul>
</div>
</div>
<div id="outline-container-org8b8fda8" class="outline-4">
<h4 id="org8b8fda8">Factories</h4>
<div class="outline-text-4" id="text-org8b8fda8">
<ul class="org-ul">
<li>When creation of an object, or an entire AGGREGATE, becomes
complicated or reveals too much of the internal structure, FACTORIES
provide encapsulation.</li>
<li>Rationales
<ul class="org-ul">
<li>An object should be distilled until nothing remains that does not
relate to its meaning or support its role in interactions.</li>
<li><b>Cars are never assembled and driven at the same time</b>, there is no
value in combining both of these functions into the same mechanism.</li>
<li>Complex object creation is a responsibility of the domain layer, yet
that task does not belong to the objects that express the model.</li>
<li>A program element whose responsibility is the creation of other
objects is called a FACTORY.</li>
<li>a FACTORY encapsulates the knowledge needed to create a complex
object or AGGREGATE.</li>
</ul></li>
<li>2 basic requirements for any good FACTORY
<ol class="org-ol">
<li>Each creation method is atomic and enforces all invariant of the
created object or AGGREGATE</li>
<li>The FACTORY should be abstracted to the type desired, rather than
the concrete class(es) created</li>
</ol></li>
<li>Choosing FACTORIES and Their Sites
<ul class="org-ul">
<li>A FACTORY is very tightly coupled to its product, so a FACTORY
should be attached <b>only to an object that has a close natural
relationship with the product</b></li>
<li>If an object interior to an AGGREGATE needs a FACTORY, and the
AGGREGATE root is not a reasonable home for it, then go ahead and
make a standalone FACTORY.</li>
</ul></li>
<li>When a Constructor Is All You Need
<ul class="org-ul">
<li>FACTORIES can actually obscure simple objects that don't use
polymorphism.</li>
<li>Avoid calling constructors within constructors of other classes.</li>
</ul></li>
<li>Designing the Interface
<ol class="org-ol">
<li>Each operation must be atomic</li>
<li>The FACTORY will be coupled to its arguments</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org3e05c18" class="outline-4">
<h4 id="org3e05c18">Repositories</h4>
<div class="outline-text-4" id="text-org3e05c18">
<ul class="org-ul">
<li><b>A starting point for a traversal to an ENTITY or VALUE in the
middle of its life cycle</b></li>
<li>How to get the reference to an object?
<ol class="org-ol">
<li>create it</li>
<li>traverse an association</li>
<li>execute a database query</li>
</ol></li>
<li><b>The right combination of <i>search</i> and <i>association</i> makes the
design comprehensible.</b></li>
<li><i>Retrieval of a stored object</i> (<i>Reconstitution</i>) is the <b>middle</b> of
the life cycle of an ENTITY</li>
<li><p>
<b>The goal of DDD</b> is to <b>create better software</b> by <i>focusing on a
model of the domain rather than the technology</i>
</p>
<blockquote>
<p>
By the time a developer has constructed an SQL query, passed it to a
query service in the infrastructure layer, obtained a result set of
table rows, pulled the necessary information out, and passed it to a
constructor or FACTORY, the model focus is gone. It becomes natural
to think of the objects as containers for the data that the queries
provide, and the whole design shifts toward a data-processing style.
</p>
</blockquote>
<ul class="org-ul">
<li><b>More and more domain rules become embedded in query code or
simply lost.</b></li>
</ul></li>
<li>Reduce the scope of the object access problem
<ul class="org-ul">
<li>if you find you need to search the database for a preexisting
VALUE, it is worth considering the possibility that you've really
got an ENTITY whose identity you haven't recognized.</li>
</ul></li>
<li>The REPOSITORY pattern
<ul class="org-ul">
<li>different solutions for dealing with the technical challenges of database
access
<ol class="org-ol">
<li>QUERY OBJECTS</li>
<li>ORM (METADATA MAPPING LAYERS)</li>
<li>FACTORIES</li>
</ol></li>
<li>it's a simple conceptual framework to encapsulate these
solutions (for dealing with the technical challenges of database
access) and bring back our model focus</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4fcdb34" class="outline-4">
<h4 id="org4fcdb34">Designing Objects for Relational Databases</h4>
<div class="outline-text-4" id="text-org4fcdb34">
<ul class="org-ul">
<li>When the database is being viewed as an object store, don't let the
data model and the object model diverge far, regardless of the
powers of the mapping tools.</li>
<li>Processes outside the object system should not access such an object
store.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org86401ed" class="outline-3">
<h3 id="org86401ed">Chapter Seven. Using the Language: An Extended Example</h3>
<div class="outline-text-3" id="text-org86401ed">
<ol class="org-ol">
<li>Isolating the domain</li>
<li>Distinguishing ENTITIES and VALUE OBJECTS</li>
<li>Designing Associations</li>
<li>AGGREGATE Boundaries</li>
<li>Selecting REPOSITORIES</li>
<li>Walking Through Scenarios
<ul class="org-ul">
<li>To cross-check all these decisions, we have to constantly step
through scenarios to confirm that we can solve application
problems effectively.</li>
</ul></li>
<li>Object Creation</li>
<li>Pause for Refactoring: An alternative design
<ul class="org-ul">
<li>By modeling VALUES, ENTITIES, and their AGGREGATES as we have, we
have reduced the impact of such design changes.</li>
</ul></li>
<li>Introducing a New Feature
<ul class="org-ul">
<li>Connecting the Two Systems
<ul class="org-ul">
<li>ANTICORRUPTION LAYER</li>
</ul></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org6a437c7" class="outline-2">
<h2 id="org6a437c7">Part III: Refactoring Toward Deeper Insight</h2>
<div class="outline-text-2" id="text-org6a437c7">
<ul class="org-ul">
<li>We hope to develop a model that captures a deep understanding of the
domain.
<ol class="org-ol">
<li>Sophisticated domain models are achievable and worth the trouble.</li>
<li>They are seldom developed except through an iterative process of
refactoring, including close involvement of the domain experts
with developers interested in learning about the domain.</li>
<li>They may call for sophisticated design skills to implement and to
use effectively.</li>
</ol></li>
<li>Levels of Refactoring
<ul class="org-ul">
<li>Nearly all the literature on how to refactor focuses on the
technical view of the quality of the design</li>
<li>The refactorings that have the greatest impact on the viability of
the system are
<ol class="org-ol">
<li><b>those motivated by new insights into the domain</b></li>
<li><b>those that clarify the model's expression through the code</b></li>
</ol></li>
<li><b>Modeling and design call for creativity</b>
<ul class="org-ul">
<li>We shouldn't get sidetracked trying to reduce domain modeling to
a cookbook or a toolkit</li>
</ul></li>
</ul></li>
<li><p>
Deep /Models
</p>
<ul class="org-ul">
<li>Initial models usually are naive and superficial, based on shallow</li>
</ul>
<p>
knowledge/
</p>
<ul class="org-ul">
<li>A deep model <b>provides a lucid expression of the primary concerns
of the domain experts and their most relevant knowledge</b> while it
sloughs off the superficial aspects of the domain.</li>
</ul></li>
<li>Deep Model/Supple Design (Chapter 10)
<ul class="org-ul">
<li>A MODEL-DRIVEN DESIGN stands on two legs
<ol class="org-ol">
<li>A deep model makes possible an expressive design</li>
<li>A design can actually feed insight into the model discovery
process when it has the flexibility to let a developer
experiment and the clarity to show a developer what is
happening</li>
</ol></li>
</ul></li>
<li>The Discovery Process (Chapter 9)</li>
</ul>
</div>
<div id="outline-container-orgfa3d650" class="outline-3">
<h3 id="orgfa3d650">Chapter Eight. Breakthrough</h3>
<div class="outline-text-3" id="text-orgfa3d650">
<ul class="org-ul">
<li>The returns from refactoring are not linear.
<ul class="org-ul">
<li>Each refinement of code and model gives developers a clearer view.</li>
<li>This clarity creates the potential for a breakthrough of insights</li>
</ul></li>
<li>The challenge lies in <b>recognizing what is happening</b> and deciding
<b>how to deal with it</b>.</li>
<li>Story of a Breakthrough
<ul class="org-ul">
<li>The <b>Share Pie</b> truly became part of the UBIQUITOUS LANGUAGE
because it got to the heart of what loan syndication is about.</li>
</ul></li>
<li>Opportunities
<ul class="org-ul">
<li>The transition to a really deep model is a profound shift in your
thinking and demands a major change to the design.</li>
</ul></li>
<li>Focus on Basics
<ul class="org-ul">
<li>To set the stage for a breakthrough, concentrate on knowledge
crunching and cultivating a robust UBIQUITOUS LANGUAGE.
<ul class="org-ul">
<li>Probe for important domain concepts and make them explicit in
the model (Chapter 9).</li>
<li>Refine the design to be suppler (Chapter 10)</li>
<li>Distill the model (Chapter 15)</li>
</ul></li>
<li><b>Don't hold back from modest improvements</b></li>
</ul></li>
<li>Epilogue: A Cascade of New Insights
<ul class="org-ul">
<li>As is often the case after a real breakthrough to a deep model,
the clarity and simplicity of the new design, combined with the
enhanced communication based on the new UBIQUITOUS LANGUAGE, had
led to yet another modeling breakthrough.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5fec023" class="outline-3">
<h3 id="org5fec023">Chapter Nine. Making Implicit Concepts Explicit</h3>
<div class="outline-text-3" id="text-org5fec023">
<ul class="org-ul">
<li>A deep model has power because it contains the central concepts and
abstractions that can succinctly and flexibly express essential
knowledge of the users' activities, their problems, and their
solutions.</li>
<li><b>The first step is to somehow represent the essential concepts of the
domain in the model.</b>
<ul class="org-ul">
<li>Many transformations of domain models and the corresponding code
happen when developers recognize a concept that has been hinted at
in discussion or present implicitly in the design, and they then
represent it explicitly in the model with one or more objects or
relationships.</li>
</ul></li>
<li>Digging Out Concepts
<ol class="org-ol">
<li>Listen to Language
<ul class="org-ul">
<li>Listen to the language the domain experts use.
<ul class="org-ul">
<li>Are there terms that succinctly state something complicated?</li>
<li>Are they correcting your word choice (perhaps
diplomatically)?</li>
<li>Do the puzzled looks on their faces go away when you use a
particular phrase?</li>
</ul></li>
<li>When the users or domain experts use vocabulary that is nowhere
in the design, that is a warning sign.</li>
<li>Benefits
<ol class="org-ol">
<li>Defining the interface more expressively</li>
<li>Decoupling</li>
<li>Clarifying relationships</li>
<li>Reducing duplication</li>
<li>Removing domain logic and placing it in the isolated domain
layer</li>
<li>Expanding the UBIQUITOUS LANGUAGE</li>
</ol></li>
</ul></li>
<li>Scrutinize Awkwardness
<ul class="org-ul">
<li>The place to dig is the most awkward part of your design.
<ul class="org-ul">
<li>The place where procedures are doing complicated things that
are hard to explain.</li>
<li>The place where every new requirement seems to add
complexity.</li>
</ul></li>
</ul></li>
<li>Contemplate Contradictions</li>
<li>Read the Book
<ol class="org-ol">
<li>Books that explain the fundamental concepts and conventional
wisdom</li>
<li>Books written by another software professional with
development experience in this domain</li>
</ol></li>
<li>Try Try Again
<ul class="org-ul">
<li><b>A modeler/designer cannot afford to get attached to his own
ideas</b>.</li>
</ul></li>
</ol></li>
<li>How to Model Less Obvious Kinds of Concepts
<ol class="org-ol">
<li>Explicit Constraints
<ul class="org-ul">
<li>some warning signs that <b>a constraint is distorting the design
of its host object</b>.
<ol class="org-ol">
<li>Evaluating a constraint requires data that does not
otherwise fit the object's definition.</li>
<li>Related rules appear in multiple objects, forcing
duplication or inheritance between objects that are not
otherwise a family.</li>
<li>A lot of design and requirements conversation revolves
around the constraints, but in the implementation, they are
hidden away in procedural code.</li>
</ol></li>
<li>Methods
<ol class="org-ol">
<li>Factoring the constraint into its own method</li>
<li>Factoring it out into an explicit object</li>
<li>Modeling it as a set of objects and relationships</li>
</ol></li>
<li>Benefits
<ol class="org-ol">
<li>Allows us to give it an intention-revealing name that makes
the constraint explicit in our design.</li>
<li>Gives the constraint some room to grow</li>
</ol></li>
</ul></li>
<li>Processes as Domain Objects
<ul class="org-ul">
<li><b>Objects are meant to encapsulate the procedures and let us
think about their goals or intentions instead.</b></li>
<li>The key to distinguishing a process that ought to be made
explicit from one that should be hidden is simple:
<b>Is this something the domain experts talk about, or is it just
part of the mechanism of the computer program?</b></li>
<li>Specification
<ul class="org-ul">
<li>SPECIFICATION provides a concise way of expressing certain
kinds of rules, extricating them from conditional logic and
making them explicit in the model.</li>
<li>Difficulties dealing with business rules
<ol class="org-ol">
<li>they often do not fit the responsibility of any of the
obvious ENTITIES or VALUE OBJECTS,</li>
<li>their variety and combinations can overwhelm the basic
meaning of the domain object.</li>
<li>moving them out of the domain layer is even worse, since
the domain code no longer expresses the model</li>
<li>Logic programming solves this by defining "predicates",
but it's hard to do that in OOP</li>
</ol></li>
<li>a SPECIFICATION can test any object to see if it satisfies
the specified criteria.</li>
<li>the concept can be extended to allow simple specifications to
be combined, just as predicates are combined with logical
operators.</li>
</ul></li>
<li>Applying and Implementing SPECIFICATION</li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org5d23e35" class="outline-3">
<h3 id="org5d23e35">Chapter Ten. Supple Design</h3>
<div class="outline-text-3" id="text-org5d23e35">
<ul class="org-ul">
<li>This Chapter:
<ol class="org-ol">
<li>What kind of design are you trying to arrive at?</li>
<li>What kind of experiments should you try along the way?</li>
</ol></li>
<li>To have a project accelerate as development proceedsrather than get
weighed down by its own legacydemands a design that is a pleasure
to work with, inviting to change. A supple design.
<ul class="org-ul">
<li>The ultimate purpose of software is to <b>serve users</b>. But that
same software has to <b>serve developers first</b></li>
<li>When software with complex behavior lacks a good design, it
becomes hard to refactor or combine elements.</li>
<li>Duplication starts to appear as soon as a developer isn't
confident of predicting the full implications of a computation.</li>
<li><b>Duplication is forced when design elements are monolithic, so that
the parts cannot be recombined</b></li>
</ul></li>
<li>Supple design is the complement to deep modeling
<ul class="org-ul">
<li>Models are just the raw material</li>
<li>Development of the design and code leads to insight that refines
model concepts</li>
</ul></li>
<li>Simple is not easy (Simple Made Easy - Rich Hickey)</li>
<li>Developers play two roles, <b>each of which must be served by the design</b>
<ol class="org-ol">
<li>The developer of a client</li>
<li>The developer working to change the design</li>
</ol></li>
<li>Some <b>patterns that contribute to supple design</b>
<ol class="org-ol">
<li>Intention-Revealing Interfaces
<ul class="org-ul">
<li>If a developer must consider the implementation of a component
in order to use it, the value of encapsulation is lost</li>
<li>Name classes and operations to describe their effect and
purpose</li>
</ul></li>
<li>Side-Effect-Free Functions
<ul class="org-ul">
<li><b>Command Query Separation</b></li>
<li>Reasoning
<ul class="org-ul">
<li>The usefulness of any abstraction of interfaces is limited if
the developers are forced to pierce the veil.</li>
<li>Without safely predictable abstractions, the developers must
limit the combinatory explosion, placing a low ceiling on the
richness of behavior that is feasible to build.</li>
</ul></li>
<li>Methods
<ol class="org-ol">
<li>Place as much of the logic as possible into side-effect-free
(pure) functions</li>
<li>Strictly segregate commands into very simple operations that
do not return domain information</li>
<li>Further control side effects by moving complext logic into
value objects</li>
</ol></li>
</ul></li>
<li>Assertions
<ul class="org-ul">
<li>Assertions make side effects explicit and easier to deal with</li>
<li>We need a way of understanding the meaning of a design element
and the consequences of executing an operation <b>without delving
into its internals</b> (abstraction).</li>
<li>Design by contract
<ul class="org-ul">
<li>Post-conditions</li>
<li>Preconditions</li>
</ul></li>
<li>If assertions cannot be coded directly in your language, write
automated unit tests for them</li>
</ul></li>
<li>Conceptual Contours
<ul class="org-ul">
<li>The CONCEPTUAL CONTOURS emerge as the code is adapted to newly
understood concepts or requirements</li>
<li>Decompose design elements into <b>high cohesive</b> units</li>
<li>The goal is <b>a simple set of interfaces that combine logically
to make sensible statements in the UBIQUITOUS LANGUAGE</b>, and
without the distraction and maintenance burden of irrelevant
options.</li>
</ul></li>
<li>Standalone Classes
<ul class="org-ul">
<li>Refined models are distilled until <b>every remaining connection
between concepts represents something fundamental</b> to the
meaning of those concepts</li>
<li>Implicit concepts count just as much as explicit references
<ul class="org-ul">
<li><b>What primitive values represent</b></li>
</ul></li>
<li><b>Low coupling is fundamental to object design</b></li>
<li>The goal is not to eliminate all dependencies, but to eliminate
all nonessential ones</li>
<li>Standalone classes can <b>be studies and tested alone</b></li>
</ul></li>
<li>Closure of Operations (reducing dependency while keeping a rich interface)
<ul class="org-ul">
<li><b>Closed</b>: When you combine any two elements of the set, the
result is also included in the set</li>
<li>Benefits of the property of closure
<ol class="org-ol">
<li>tremendously simplifies the interpretation of an operation</li>
<li>it's easy to think about chaining together or combining
closed operations</li>
</ol></li>
<li>How
<ul class="org-ul">
<li><b>Where it fits, define an operation whose return type is the
same as the type of its argument(s)</b></li>
<li>Especially for VALUE OBJECTs</li>
<li><p>
An operation can be closed under an abstract type
</p>
<pre class="example">
Addition is closed under real numbers (rational or irrational)
</pre></li>
</ul></li>
<li><p>
Smalltalk example
</p>
<pre class="example">
The Smalltalk Collections provide other such FUNCTIONS that return
derived Collections, which can be of several concrete classes. The
operations are not closed, because they take a "block" as an
argument. But blocks are a basic library type in Smalltalk, so they
don't add to the developer's mental load. Because the return value
matches the implementer, they can be strung together, like a series of
filters. They are easy to write and easy to read. They do not
introduce extraneous concepts that are irrelevant to the problem of
selecting subsets.
</pre>
<pre class="example">
employees := (some Set of Employee objects).
lowPaidEmployees := employees select:
         [:anEmployee | anEmployee salary &lt; 40000].
</pre></li>
</ul></li>
</ol></li>
<li>Declarative Design:
<b>Making software obvious, predictable, and communicative makes
abstraction and encapsulation effective.</b>
<ul class="org-ul">
<li><b>Generating a running program from a declaration of model
properties</b> is a kind of Holy Grail of MODEL-DRIVEN DESIGN</li>
<li>Many declarative approaches can be corrupted if the developers
bypass them intentionally or unintentionally.</li>
<li>Domain-Specific Languages</li>
</ul></li>
<li>A Declarative Style of Design
<ul class="org-ul">
<li>A supple design can <b>make it possible for the client code to use a
declarative style of design</b></li>
</ul></li>
<li>Angles of Attack
<ol class="org-ol">
<li>Carve Off Subdomains</li>
<li>Draw on Established Formalism, when you can
<ul class="org-ul">
<li><b>Use and adapt conceptual systems that are long established in
your domain or others</b>, some of which have been refined and
distilled over centuries.</li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-orgc1f660b" class="outline-3">
<h3 id="orgc1f660b">Chapter Eleven. Applying Analysis Patterns</h3>
<div class="outline-text-3" id="text-orgc1f660b">
<ul class="org-ul">
<li><p>
<i>Analysis Patterns: Reusable Object Models</i> by Martin Fowler
</p>
<blockquote>
<p>
Analysis patterns are groups of concepts that represent a common
construction in business modeling.
</p>
</blockquote></li>
<li>Analysis Patterns Are Knowledge to Draw On</li>
</ul>
</div>
<div id="outline-container-orgd62031b" class="outline-4">
<h4 id="orgd62031b">Example Earning Interest with Accounts</h4>
</div>
</div>
<div id="outline-container-orgdb9b7cd" class="outline-3">
<h3 id="orgdb9b7cd">Chapter Twelve. Relating Design Patterns to the Model</h3>
<div class="outline-text-3" id="text-orgdb9b7cd">
<ul class="org-ul">
<li>Design Patterns presents a catalog of design elements that have
solved problems commonly encountered in a variety of contexts.</li>
<li>Strategy (A.K.A. Policy)
<ul class="org-ul">
<li>When we use the technical design pattern in the domain layer, we
have to add an additional motivation, another layer of meaning.</li>
</ul></li>
<li>Composite
<ul class="org-ul">
<li>When applying any design pattern in the domain, the first concern
should be whether the pattern idea really is a good fit for the
domain concept.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgff2916c" class="outline-3">
<h3 id="orgff2916c">Chapter Thirteen. Refactoring Toward Deeper Insight</h3>
<div class="outline-text-3" id="text-orgff2916c">
<ul class="org-ul">
<li>three things you have to focus on.
<ol class="org-ol">
<li>Live in the domain.</li>
<li>Keep looking at things a different way.</li>
<li>Maintain an unbroken dialog with domain experts.</li>
</ol></li>
<li>Initiation
<ul class="org-ul">
<li>Seeing the trouble spot is often the hardest and most uncertain part.</li>
</ul></li>
<li>Exploration Teams
<dl class="org-dl">
<dt>Self-determination</dt><dd>A small team can be assembled on the fly to explore a design
problem. The team can operate for a few days and then
disband. There is no need for long-term, elaborate
organizational structures.</dd>
<dt>Scope and sleep</dt><dd>Two or three short meetings spaced out over a few days should
produce a design worth trying. Dragging it out doesn't help. If
you get stuck, you may be taking on too much at once. Pick a
smaller aspect of the design and focus on that.</dd>
<dt>Exercising the UBIQUITOUS LANGUAGE</dt><dd>Involving the other team membersparticularly the subject
matter expertin the brain-storming session creates an
opportunity to exercise and refine the UBIQUITOUS LANGUAGE. The
end result of the effort is a refinement of that LANGUAGE which
the original developer(s) will take back and formalize in code.</dd>
</dl></li>
<li>Prior Art</li>
<li>A Design for Developers
<ul class="org-ul">
<li>Chapter Ten. Supple Design</li>
</ul></li>
<li>Timing
<ul class="org-ul">
<li><b>If you wait until you can make a complete justification for a
change, you've waited too long.</b></li>
<li>Most project teams are still too cautious about <i>continuous
refactoring</i>.
<ul class="org-ul">
<li>They see the risk of changing code and the cost of developer
time to make a change;</li>
<li>but what's harder to see is <b>the risk of keeping an awkward
design</b> and <b>the cost of working around that design</b>.</li>
</ul></li>
<li>Refactoring toward deeper insight needs to become part of the
ongoing exploration of the subject matter of the domain, the
education of the developers, and the meeting of the minds of
developers and domain experts.</li>
<li>Refactor when:
<ol class="org-ol">
<li>The design does not express the team's current understanding of
the domain;</li>
<li>Important concepts are implicit in the design (and you see a
way to make them explicit); or</li>
<li>You see an opportunity to make some important part of the
design suppler.</li>
</ol></li>
<li>This aggressive attitude does not justify any change at any time.
<ol class="org-ol">
<li>Don't refactor the day before a release.</li>
<li>Don't introduce "supple designs" that are just demonstrations
of technical virtuosity but fail to cut to the core of the
domain.</li>
<li>Don't introduce a "deeper model" that you couldn't convince a
domain expert to use, no matter how elegant it seems.</li>
<li>Don't be absolute about things, but push beyond the comfort
zone in the direction of favoring refactoring.</li>
</ol></li>
</ul></li>
<li>Crisis as Opportunity</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgeaf615d" class="outline-2">
<h2 id="orgeaf615d">Part IV: Strategic Design</h2>
<div class="outline-text-2" id="text-orgeaf615d">
<ul class="org-ul">
<li>These are the decisions where design and politics often intersect.</li>
<li>The challenge is to <b>accomplish modularity without losing the
benefits of integration</b>, allowing different parts of the system to
interoperate to support the coordination of various business
operations.</li>
<li>context, distillation, and large-scale structure.</li>
</ul>
</div>
<div id="outline-container-orgb239535" class="outline-3">
<h3 id="orgb239535">Chapter Fourteen. Maintaining Model Integrity</h3>
<div class="outline-text-3" id="text-orgb239535">
<ul class="org-ul">
<li>The most fundamental requirement of a model is that it be
<b>internally consistent</b> -&gt; <b>unification</b>
<ul class="org-ul">
<li>Total unification of the domain model for a large system will not be
feasible or cost-effective.</li>
</ul></li>
<li>The risks of fighting this fact
(trying to unify all the software in a large project under a single
model)
<ol class="org-ol">
<li>Too many legacy replacements may be attempted at once</li>
<li>Large projects may bog down because the coordination over-head
exceeds their abilities.</li>
<li>Applications with specialized requirements may have to use models
that don't fully satisfy their needs, forcing them to put
behavior elsewhere.</li>
<li>Conversely, attempting to satisfy everyone with a single model
may lead to complex options that make the model difficult to use.</li>
</ol></li>
<li>This chapter lays out <b>techniques for recognizing, communicating, and
choosing the limits of a model and its relationships to others</b>.</li>
</ul>
</div>
<div id="outline-container-org5b834a8" class="outline-4">
<h4 id="org5b834a8">Bounded Context</h4>
<div class="outline-text-4" id="text-org5b834a8">
<blockquote>
<p>
Cells can exist because their membranes define what is in and out and
determine what can pass.
</p>
</blockquote>
<ul class="org-ul">
<li>Multiple models are in play on any large project.
<ul class="org-ul">
<li>It is often unclear in what context a model should <b>not</b> be
applied.</li>
<li>To clarify the context of a model, we have to look at both the
project and its end products (code, database schemas, and so on).</li>
</ul></li>
<li>BOUNDED CONTEXTS are <b>not</b> Modules
<ul class="org-ul">
<li>Modules also organize the elements within one model - <b>they don't
necessarily communicate an intention to separate CONTEXTS</b></li>
</ul></li>
<li>Benefits
<dl class="org-dl">
<dt>clarity</dt><dd>For the teams working in CONTEXT</dd>
<dt>freedom</dt><dd>For the teams working outside CONTEXT</dd>
</dl></li>
<li>Recognizing Splinters Within a BOUNDED CONTEXT
<ol class="org-ol">
<li>Code interfaces don't match up (Unexpected behavior)</li>
<li>Combining elements of distinct models
<dl class="org-dl">
<dt>Duplicate concepts</dt><dd>there are two model elements that actually represent the
same concepts</dd>
<dt>False cognates</dt><dd>When two people who are using the same term
think they are talking about the same thing,
but really are not</dd>
</dl></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org29f19e0" class="outline-4">
<h4 id="org29f19e0">Continuous Integration</h4>
<div class="outline-text-4" id="text-org29f19e0">
<ul class="org-ul">
<li>We need ways of increasing communication and reducing complexity.</li>
<li>We also need safety nets that prevent overcautious behavior, such as
<i>developers duplicating functionality because they are afraid they
will break existing code</i>.</li>
<li>XP in its purest form is a nice fit for maintaining model integrity
within a single BOUNDED CONTEXT.</li>
<li>CONTINUOUS INTEGRATION
<ul class="org-ul">
<li>means that all work within the context is being merged and made
consistent frequently enough that <b>when splinters happen they are
caught and corrected quickly</b>.</li>
<li>operates at two levels:
<ol class="org-ol">
<li>The integration of <i>model concepts</i>
<ul class="org-ul">
<li><b>Constant communication among team members</b></li>
<li><b>Constantly hammering out the UBIQUITOUS LANGUAGE</b></li>
</ul></li>
<li>the integration of <i>the implementation</i>
<ul class="org-ul">
<li><b>A systematic merge/build/test process that exposes model
splinters early</b></li>
<li>Most of the effective processes share these characteristics
<ol class="org-ol">
<li>A step-by-step, reproducible merge/build technique</li>
<li>Automated test suites</li>
<li>Rules that set some reasonably small upper limit on the
life time of unintegrated changes</li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org08d4d8f" class="outline-4">
<h4 id="org08d4d8f">Context Map</h4>
<div class="outline-text-4" id="text-org08d4d8f">
<ul class="org-ul">
<li>When connections must be made between different contexts, they tend
to bleed into each other.</li>
<li>A CONTEXT MAP is in the overlap between <i>project management</i> and
<i>software design</i>.
<ol class="org-ol">
<li>Identify each model in play on the project and define its BOUNDED
CONTEXT.</li>
<li>Describe the points of contact between the models, outlining
explicit translation for any communication and highlighting any
sharing.</li>
<li>Map the existing terrain. Take up transformations later.</li>
</ol></li>
<li>Testing at the CONTEXT Boundaries
<ul class="org-ul">
<li>Contact points with other BOUNDED CONTEXTS are particularly
important to test.</li>
<li>They can act as a valuable early warning system, especially
reassuring in cases where you depend on the details of a model you
don't control.</li>
</ul></li>
<li>Organizing and Documenting CONTEXT MAPS
<ol class="org-ol">
<li>The BOUNDED CONTEXTS should have names so that you can talk about
them. Those names should enter the UBIQUITOUS LANGUAGE of the
team.</li>
<li>Everyone has to know where the boundaries lie, and be able to
recognize the CONTEXT of any piece of code or any situation.</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-orgdddb48c" class="outline-4">
<h4 id="orgdddb48c">Relationships Between BOUNDED CONTEXTS</h4>
<div class="outline-text-4" id="text-orgdddb48c">
</div>
<ul class="org-ul">
<li><a id="orgfcdbadd"></a>More cooperative relationships<br />
<ul class="org-ul">
<li><a id="org11c1965"></a>Shared Kernel<br />
<div class="outline-text-6" id="text-org11c1965">
<ul class="org-ul">
<li>The SHARED KERNEL is often the CORE DOMAIN, some set of GENERIC
SUBDOMAINS, or both</li>
<li>The goal is to
<ol class="org-ol">
<li><b>reduce duplication</b> (but not to eliminate ti)</li>
<li>make integration between the two subsystems relatively easy.</li>
</ol></li>
</ul>
</div>
</li>
<li><a id="org7d18e24"></a>Customer/Supplier Development Teams<br />
<div class="outline-text-6" id="text-org7d18e24">
<ul class="org-ul">
<li>Problems can emerge, depending on the political relationship of the
two teams.</li>
<li>Iteration planning process
<ul class="org-ul">
<li>Representatives of the downstream team can function much like the
user representatives, joining them in planning sessions,
discussing directly with their fellow "customers" the trade-offs
for the tasks they want.</li>
</ul></li>
<li>Therefore
<ol class="org-ol">
<li>Establish a clear customer/supplier relationship between the two
teams (implicate that the customer's needs are paramount)</li>
<li>Jointly develop automated acceptance tests that will validate the
interface expected -&gt; free the upstream team to make changes
without fear of side effects downstream</li>
</ol></li>
<li>CUSTOMER/SUPPLIER TEAMS are more likely to succeed if the two teams
work <b>under the same management</b>, so that ultimately they do share
goals</li>
</ul>
</div>
</li>
<li><a id="org4cfbb07"></a>Conformist<br />
<div class="outline-text-6" id="text-org4cfbb07">
<ul class="org-ul">
<li>When two development teams have an upstream/downstream relationship
in which the upstream has no motivation to provide for the
downstream team's needs, the downstream team is helpless.
<ol class="org-ol">
<li>Separate Ways</li>
<li>Anticorruption Layer</li>
<li>Conformist</li>
</ol></li>
<li>Therefore:
<ul class="org-ul">
<li>Eliminate the complexity of translation between BOUNDED CONTEXTS
by slavishly adhering to the model of the upstream team.</li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgfa4431a"></a>Anticorruption Layer<br />
<div class="outline-text-6" id="text-orgfa4431a">
<ul class="org-ul">
<li>When a new system is being built that must have a large interface
with another, the difficulty of relating the two models can
eventually overwhelm the intent of the new model altogether, causing
it to be modified to resemble the other system's model, in an ad hoc
fashion.</li>
<li>Therefore:
<ul class="org-ul">
<li>Create an isolating layer (anti-corruption layer) to provide
clients with functionality in terms of their own domain model.</li>
</ul></li>
<li>Implementing the ANTICORRUPTION LAYER
<ul class="org-ul">
<li>One way of organizing the design of the ANTICORRUPTION LAYER is as
a combination of FACADES, ADAPTERS, and translators</li>
</ul></li>
<li><b>Integration can be very valuable, but it is always expensive.</b></li>
</ul>
</div>
</li>
<li><a id="org3adfda8"></a>Separate Ways<br />
<div class="outline-text-6" id="text-org3adfda8">
<ul class="org-ul">
<li>Integration is always expensive. Sometimes the benefit is small.</li>
<li><b>Just because features are related in a use case does not mean they
must be integrated.</b></li>
<li>Therefore:
<ul class="org-ul">
<li>Declare a BOUNDED CONTEXT to have no connection to the others at
all, allowing developers to find simple, specialized solutions
within this small scope.</li>
</ul></li>
</ul>
</div>
</li>
</ul>
</li>
<li><a id="org581c5a1"></a>Scale up integration<br />
<ul class="org-ul">
<li><a id="orgd5fd61a"></a>Open Host Service<br />
<div class="outline-text-6" id="text-orgd5fd61a">
<ul class="org-ul">
<li>When a subsystem has to be integrated with many others, customizing
a translator for each can bog down the team.
<ul class="org-ul">
<li>There is more and more to maintain, and more and more to worry
about when changes are made.</li>
</ul></li>
<li>Therefore:
<ul class="org-ul">
<li><b>Define a protocol that gives access to your subsystem as a set of
SERVICES.</b></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org2572439"></a>Published Language<br />
<div class="outline-text-6" id="text-org2572439">
<ul class="org-ul">
<li>Direct translation to and from the existing domain models may not be
a good solution.</li>
<li>Use a well-documented shared language <b>(XML, JSON, etc.)</b> that can
express the necessary domain information as a common medium of
communication, translating as necessary into and out of that
language.</li>
</ul>
</div>
</li>
<li><a id="orgecb990b"></a>Unifying an Elephant<br />
<div class="outline-text-6" id="text-orgecb990b">
<ul class="org-ul">
<li>If no integration is required, then it doesn't matter that the
models are not unified.</li>
<li>If they require some integration, they may not actually have to
agree on what an elephant is, but they will get a lot of value from
merely recognizing that they don't agree.</li>
<li>When more integration is needed, the unified model doesn't have to
reach full maturity in the first version.</li>
<li><b>Unifying multiple models almost always means creating a new model.</b></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-org51a0f37" class="outline-4">
<h4 id="org51a0f37">Choosing Your Model Context Strategy</h4>
<div class="outline-text-4" id="text-org51a0f37">
<ol class="org-ol">
<li>Team Decision or Higher
<ul class="org-ul">
<li>In practice, political relationships between teams often
determine how systems are integrated. (Conway's Corollary)</li>
</ul></li>
<li>Putting Ourselves in Context</li>
<li>Transforming Boundaries (How to draw the boundaries)
<ul class="org-ul">
<li>Larger BOUNDED CONTEXTS
<ul class="org-ul">
<li>Flow between user tasks is smoother when</li>
<li>It's easier to understand <i>one coherent model</i> than two
distinct ones plus mappings</li>
<li>Translation between two models can be difficult (sometimes
impossible)</li>
<li>Shared language fosters clear team communication</li>
</ul></li>
<li>Smaller BOUNDED CONTEXTS
<ul class="org-ul">
<li>Communication overhead between developers is reduced</li>
<li>CONTINUOUS INTEGRATION is easier with smaller teams and code
bases</li>
<li>Larger contexts may call for more versatile abstract models,
requiring skills that are in short supply</li>
<li>Different models can cater to special needs or encompass the
jargon of specialized groups of users, along with specialized
dialects of the UBIQUITOUS LANGUAGE</li>
</ul></li>
</ul></li>
<li>Accepting That Which We Cannot Change: Delineating the External
Systems
<ul class="org-ul">
<li>Relationships with the External Systems
<ol class="org-ol">
<li>Separate Ways</li>
<li>Conformist</li>
<li>Anti Corruption Layer</li>
</ol></li>
</ul></li>
<li>The System Under Design</li>
<li>Catering to Special Needs with Distinct Models</li>
<li>Deployment</li>
</ol>
</div>
</div>
<div id="outline-container-org056a7d3" class="outline-4">
<h4 id="org056a7d3">Transformations</h4>
<div class="outline-text-4" id="text-org056a7d3">
<ul class="org-ul">
<li>Merging CONTEXTS: SEPARATE WAYS   SHARED KERNEL</li>
<li>Merging CONTEXTS: SHARED KERNEL   CONTINUOUS INTEGRATION</li>
<li>Phasing Out a Legacy System</li>
<li>Open Host Service   Published Language</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3597f62" class="outline-3">
<h3 id="org3597f62">Chapter Fifteen. Distillation</h3>
<div class="outline-text-3" id="text-org3597f62">
<p>
Patterns to make the CORE DOMAIN easier to see and use and change.
</p>
<ul class="org-ul">
<li><span class="underline">Distillation</span> is the process of separating the components of a
mixture to extract the essence in a form that makes it more valuable
and useful (<b>CORE DOMAIN</b>).</li>
<li>Strategic distillation of a domain model does all of the following:
<ol class="org-ol">
<li>Aids all team members in grasping the overall design of the
system and how it fits together</li>
<li>Facilitates communication by identifying a core model of
manageable size to enter the UBIQUITOUS LANGUAGE</li>
<li>Guides refactoring</li>
<li>Focuses work on areas of the model with the most value</li>
<li>Guides outsourcing, use of off-the-shelf components, and
decisions about assignments</li>
</ol></li>
<li>Navigation map
<ul class="org-ul">
<li>Core domain
<ul class="org-ul">
<li>(point the way with) Domain vision statement</li>
<li>(designate content with) Highlighted core</li>
<li>(repackaged into) Segregated core
<ul class="org-ul">
<li>(Distill into) Abstract core</li>
<li>(Distill to) Declarative Style</li>
</ul></li>
<li>(unencumber from) Generic subdomains
<ul class="org-ul">
<li>(Distill to) Declarative Style</li>
</ul></li>
<li>(unencumber from) Cohesive mechanisms
<ul class="org-ul">
<li>(expose capability through) Intention-revealing interfaces</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgfa34580" class="outline-4">
<h4 id="orgfa34580">Core Domain</h4>
<div class="outline-text-4" id="text-orgfa34580">
<ul class="org-ul">
<li>Reasons
<ul class="org-ul">
<li>A system that is hard to understand is hard to change.</li>
<li>Not all parts of the design are going to be equally refined.</li>
</ul></li>
<li>Therefore
<ul class="org-ul">
<li>Boil the model down
<ul class="org-ul">
<li>Find the CORE DOMAIN</li>
<li>make the CORE small</li>
</ul></li>
<li>Apply top talent to the CORE DOMAIN, and recruit accordingly</li>
</ul></li>
<li>Distilling the CORE DOMAIN leads to some easy decisions
<ol class="org-ol">
<li>Put more efforts into your CORE</li>
<li>Only need to keep the CORE DOMAIN as your secret</li>
<li>Refactorings affects the CORE DOMAIN the most should be chosen
first</li>
</ol></li>
<li>Choosing the CORE
<ul class="org-ul">
<li>Those parts of the model particular to representing your business
domain and solving your business problems.</li>
<li>The CORE DOMAIN you choose depends on your point of view.
<ul class="org-ul">
<li>One application's CORE DOMAIN can be another application's
generic supporting component.</li>
</ul></li>
</ul></li>
<li>The greatest value of custom software comes from the total control
of the CORE DOMAIN.</li>
<li>One way or another, creating distinctive software comes back to a
stable team <b>accumulating specialized knowledge and crunching it
into a rich model</b>. No shortcuts. No magic bullets.</li>
</ul>
</div>
</div>
<div id="outline-container-orgbfae4bf" class="outline-4">
<h4 id="orgbfae4bf">An Escalation of Distillations</h4>
<div class="outline-text-4" id="text-orgbfae4bf">
<ul class="org-ul">
<li>Successive distillation of a domain model produces an asset that
gives the project speed, agility, and precision of execution.</li>
</ul>
</div>
</div>
<div id="outline-container-orgbe2370e" class="outline-4">
<h4 id="orgbe2370e">Generic Subdomains</h4>
<div class="outline-text-4" id="text-orgbe2370e">
<ul class="org-ul">
<li>Therefore
<ol class="org-ol">
<li>Identify cohesive subdomains that are not the motivation for your
project (CORE DOMAIN)</li>
<li>Give their continuing development lower priority than the CORE
DOMAIN</li>
</ol></li>
<li>A few extra options when developing these packages
<ol class="org-ol">
<li>An Off-the-shelf Solution
<ul class="org-ul">
<li>Advantages
<ul class="org-ul">
<li>Less code to develop.</li>
<li>Maintenance burden externalized.</li>
<li>Code is probably more mature, used in multiple places, and
therefore more bulletproof and complete than homegrown code.</li>
</ul></li>
<li>Disadvantages
<ul class="org-ul">
<li>You still have to spend the time to evaluate it and
understand it before using it.</li>
<li>Quality control being what it is in our industry, you can't
count on it being correct and stable.</li>
<li>It may be overengineered for your purposes; integration could
be more work than a minimalist homegrown implementation.</li>
<li>Foreign elements don't usually integrate smoothly. There may
be a distinct BOUNDED CONTEXT. Even if not, it may be
difficult to smoothly reference ENTITIES from your other
packages.</li>
<li>It may introduce platform dependencies, compiler version
dependencies, and so on.</li>
</ul></li>
<li>Sometimes GENERIC SUBDOMAIN solutions are packaged in the form
of frameworks (Rails?), which implement a very abstract model
that can be integrated with and specialized for your
application.</li>
</ul></li>
<li>A Published Design or Model
<ul class="org-ul">
<li>Chapter Eleven. Applying Analysis Patterns</li>
<li>Advantages
<ul class="org-ul">
<li>More mature than a homegrown model and reflects many people's
insights</li>
<li>Instant, high-quality documentation</li>
</ul></li>
<li>Disadvantage
<ul class="org-ul">
<li>May not quite fit your needs or may be overengineered for
your needs</li>
</ul></li>
</ul></li>
<li>An Outsourced Implementation
<ul class="org-ul">
<li>Advantages
<ul class="org-ul">
<li>Keeps core team free to work on the CORE DOMAIN, where most
knowledge is needed and accumulated.</li>
<li>Allows more development to be done without permanently
enlarging the team, but without dissipating knowledge of the
CORE DOMAIN.</li>
<li>Forces an interface-oriented design, and helps keep the
subdomain generic, because the specification is being passed
outside.</li>
</ul></li>
<li>Disadvantages
<ul class="org-ul">
<li>Still requires time from the core team, because the
interface, coding standards, and any other important aspects
need to be communicated.</li>
<li>Incurs significant overhead of transferring ownership back
inside, because code has to be understood. (Still, overhead
is less than for specialized subdomains, because a generic
model presumably requires no special background to
understand.)</li>
<li>Code quality can vary. This could be good or bad, depending
on the relative caliber of the two teams.</li>
</ul></li>
</ul></li>
<li>An In-House Implementation
<ul class="org-ul">
<li>Advantages
<ul class="org-ul">
<li>Easy integration.</li>
<li>You get just what you want and nothing extra.</li>
<li>Temporary contractors can be assigned.</li>
</ul></li>
<li>Disadvantages
<ul class="org-ul">
<li>Ongoing maintenance and training burden.</li>
<li>It is easy to underestimate the time and cost of developing
such packages.</li>
</ul></li>
</ul></li>
</ol></li>
<li>We technical people tend to enjoy definable problems like time zone
conversion, and we can easily justify spending our time on them.
<ul class="org-ul">
<li>But <b>a disciplined look at priorities usually points to the CORE
DOMAIN</b>.</li>
</ul></li>
<li><b>Generic Doesn't Mean Reusable</b>
<ul class="org-ul">
<li><b>The model reuse is often a better level of reuse (than code
reuse)</b></li>
<li>You can model and implement only the part you need for your
business.</li>
</ul></li>
<li>Introducing industry-specific model elements will have two costs.
<ol class="org-ol">
<li>impede future development
<ul class="org-ul">
<li>By introducing anything to the design that is not part of the
concept, you make it much more difficult to expand the system
cleanly without completely rebuilding the older part and
redesigning the other modules that use it.</li>
</ul></li>
<li>industry-specific concepts belong either in the CORE DOMAIN or in
their own, more specialized, subdomain
<ul class="org-ul">
<li>those specialized models are even more valuable than the
generic ones.</li>
</ul></li>
</ol></li>
<li>Project Risk Management
<ul class="org-ul">
<li>Agile processes typically call for managing risk by tackling the
riskiest tasks early.
<ul class="org-ul">
<li>XP specifically calls for getting an end-to-end system up and
running immediately.</li>
</ul></li>
<li>Projects face risk from both sides
<ol class="org-ol">
<li>technical risks</li>
<li>domain modeling risks
<ul class="org-ul">
<li><b>It is easy to underestimate the domain modeling risk.</b>
<ol class="org-ol">
<li>unforeseen complexity</li>
<li>inadequate access to business experts</li>
<li>gaps in key skills of the developers</li>
</ol></li>
<li>except when the team has proven skills and the domain is very
familiar, <b>the first-cut system should be based on some part
of the CORE DOMAIN, however simple.</b></li>
</ul></li>
</ol></li>
</ul></li>
<li>the next two patterns, DOMAIN VISION STATEMENT and HIGHLIGHTED CORE,
show how the use of supplemental documents can, with a very minor
investment, improve communication and awareness of the CORE and
focus development effort</li>
</ul>
</div>
</div>
<div id="outline-container-orgc529786" class="outline-4">
<h4 id="orgc529786">Domain Vision Statement</h4>
<div class="outline-text-4" id="text-orgc529786">
<ul class="org-ul">
<li>A DOMAIN VISION STATEMENT is modeled after such documents ("vision
statements", layu out the specific value the application will bring
to the organization), but it focuses on the nature of the domain
model and how it is valuable to the enterprise.</li>
<li>Therefore
<ol class="org-ol">
<li>Write a short description (about one page) of the CORE DOMAIN and
the value it will bring (the "value proposition")</li>
<li>Show how the domain model serves and balances diverse interests</li>
<li>Keep it narrow</li>
<li>Write this statement early and revise it as you gain new insight</li>
</ol></li>
<li>Examples
<ol class="org-ol">
<li>Airline Booking System
<ul class="org-ul">
<li>The model can represent passenger priorities and airline
booking strategies and balance these based on flexible
policies. The model of a passenger should reflect the
"relationship" the airline is striving to develop with repeat
customers. Therefore, it should represent the history of the
passenger in useful condensed form, participation in special
programs, affiliation with strategic corporate clients, and so
on.</li>
<li>Different roles of different users (such as passenger, agent,
manager) are represented to enrich the model of relationships
and to feed necessary information to the security framework.</li>
<li>Model should support efficient route/seat search and
integration with other established flight booking systems.</li>
</ul></li>
<li>Semiconductor Factory Automation
<ul class="org-ul">
<li>The domain model will represent the status of materials and
equipment within a wafer fab in such a way that necessary audit
trails can be provided and automated product routing can be
supported.</li>
<li>The model will not include the human resources required in the
process, but must allow selective process automation through
recipe download.</li>
<li>The representation of the state of the factory should be
comprehensible to human managers, to give them deeper insight
and support better decision making.</li>
</ul></li>
</ol></li>
<li>A DOMAIN VISION STATEMENT gives the team <b>a shared direction</b>.</li>
</ul>
</div>
</div>
<div id="outline-container-org3f797be" class="outline-4">
<h4 id="org3f797be">Highlighted Core</h4>
<div class="outline-text-4" id="text-org3f797be">
<ul class="org-ul">
<li>The CORE DOMAIN must be made easier to see.
<ul class="org-ul">
<li>Different people won't pick out quite the same elements, and even
the same person won't be consistent from one day to the next.</li>
</ul></li>
<li>Significant structural changes to the code are the ideal way of
identifying the CORE DOMAIN
<ul class="org-ul">
<li>but they are not always practical in the short term</li>
</ul></li>
<li>Two specific techniques can represent this class of solutions.
<ol class="org-ol">
<li>The Distillation Document
<ul class="org-ul">
<li>A separate document to describe and explain the CORE DOMAIN.
<ul class="org-ul">
<li>three to seven sparse pages</li>
<li>describes the CORE DOMAIN and the primary interactions among
CORE elements</li>
</ul></li>
<li>A distillation document is not a complete design document.</li>
<li>All the usual risks of separate documents apply.
<ol class="org-ol">
<li>The document may not be maintained.</li>
<li>The document may not be read.</li>
<li>By multiplying the information sources, the document may
defeat its own purpose of cutting through complexity.</li>
</ol></li>
<li>The best way to limit these risks is to <b>be absolutely
minimalist</b>.</li>
<li><b>Write the document to be understood by the nontechnical
members of the team.</b></li>
</ul></li>
<li>The Flagged CORE
<ul class="org-ul">
<li>Flag the elements of the CORE DOMAIN within the primary
repository of the model, without particularly trying to
elucidate its role.</li>
</ul></li>
</ol></li>
<li>The Distillation Document as Process Tool
<ul class="org-ul">
<li>If the distillation document outlines the essentials of the CORE
DOMAIN, then it serves as a practical indicator of the
significance of a model change.</li>
<li>When a model or code change affects the distillation document, it
requires consultation with other team members.</li>
<li>When the change is made, it requires immediate notification of all
team members, and the dissemination of a new version of the
document.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0c06292" class="outline-4">
<h4 id="org0c06292">Cohesive Mechanisms</h4>
<div class="outline-text-4" id="text-org0c06292">
<ul class="org-ul">
<li>Computations sometimes reach a level of complexity that begins to
bloat the design.
<ul class="org-ul">
<li>The conceptual "what" is swamped by the mechanistic "how."</li>
<li>A large number of methods that provide algorithms for resolving
the problem obscure the methods that express the problem.</li>
</ul></li>
<li>Therefore
<ul class="org-ul">
<li>Partition a conceptually COHESIVE MECHANISM into a separate
lightweight framework.</li>
<li>Particularly watch for formalisms or well-documented categories
of algorithms.</li>
<li>Expose the capabilities of the framework with an
INTENTION-REVEALING INTERFACE.</li>
<li>Now the other elements of the domain can focus on expressing the
problem ("what"), delegating the intricacies of the solution
("how") to the framework.</li>
</ul></li>
<li>If this mechanism had been incorporated into the domain model, it
would have cost us in two ways.
<ol class="org-ol">
<li>The model would have been coupled to a particular method of
solving the problem, limiting future options.</li>
<li>The model of an organization would have been greatly complicated
and muddied.</li>
</ol></li>
<li>GENERIC SUBDOMAIN vs. COHESIVE MECHANISM
<ul class="org-ul">
<li>GENERIC SUBDOMAIN is no different than the CORE DOMAIN, just less
central, less important, less specialized</li>
<li>A COHESIVE MECHANISM does not represent the domain, it solves some
sticky computational problem posed by the expressive models</li>
</ul></li>
<li>When a MECHANISM is Part of the CORE DOMAIN
<ul class="org-ul">
<li>highly specialized algorithms</li>
</ul></li>
<li>Distilling to a Declarative Style
<ul class="org-ul">
<li>When a supple design reaches maturity, it provides an easily
understood set of elements that can be combined unambiguously to
accomplish complex tasks or express complex information, just as
words are combined into sentences.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org479fde1" class="outline-4">
<h4 id="org479fde1">Segregated Core</h4>
<div class="outline-text-4" id="text-org479fde1">
<ul class="org-ul">
<li>Therefore
<ul class="org-ul">
<li>Refactor the model to <b>separate the CORE concepts from supporting
players</b> (including ill-defined ones) and <b>strengthen the cohesion
of the CORE</b> while <b>reducing its coupling to other code</b>.</li>
<li>Factor all generic or supporting elements into other objects and
place them into other packages, even if this means refactoring the
model in ways that separate highly coupled elements.</li>
</ul></li>
<li>The steps needed to refactor to SEGREGATED CORE are typically
something like these:
<ol class="org-ol">
<li>Identify a CORE subdomain (possibly drawing from the distillation
document).</li>
<li>Move related classes to a new MODULE, named for the concept that
relates them.</li>
<li>Refactor code to sever data and functionality that are not
directly expressions of the concept. Put the removed aspects into
(possibly new) classes in other packages. Try to place them with
conceptually related tasks, but don't waste too much time being
perfect. Keep focused on scrubbing the CORE subdomain and making
the references from it to other packages explicit and
self-explanatory.</li>
<li>Refactor the newly SEGREGATED CORE MODULE to make its
relationships and interactions simpler and more communicative,
and to minimize and clarify its relationships with other
MODULES. (This becomes an ongoing refactoring objective.)</li>
<li>Repeat with another CORE subdomain until the SEGREGATED CORE is
complete.</li>
</ol></li>
<li>The Costs of Creating a SEGREGATED CORE
<ul class="org-ul">
<li>sometimes in the creation of a SEGREGATED CORE a nicely cohesive
MODULE may be broken, sacrificing that cohesion for the sake of
bringing out the cohesiveness of the CORE DOMAIN.</li>
<li>segregating the CORE is a lot of work.</li>
</ul></li>
<li><b>The time to chop out a SEGREGATED CORE</b> is
<ul class="org-ul">
<li>when you have a large BOUNDED CONTEXT that is critical to the
system,</li>
<li>but where the essential part of the model is being obscured by a
great deal of supporting capability.</li>
</ul></li>
<li>Evolving Team Decision
<ul class="org-ul">
<li>The challenge is to <b>constrain everyone to use the same definition
of the CORE</b> while <b>not freezing that decision</b></li>
<li>Whatever the process is for joint decisions, whether consensus or
team leader directive, it must <b>be agile enough to make repeated
course corrections.</b></li>
<li>Communication must be effective enough to keep everyone together
in one view of the CORE.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8f3561a" class="outline-4">
<h4 id="org8f3561a">Abstract Core</h4>
<div class="outline-text-4" id="text-org8f3561a">
<ul class="org-ul">
<li>Even the CORE DOMAIN model usually has so much detail that
communicating the big picture can be difficult.</li>
<li>Consider slicing horizontally (polymorphism) rather than vertically.</li>
<li>Therefore
<ul class="org-ul">
<li>Identify the most fundamental concepts in the model</li>
<li>Factor them into distinct classes, abstract classes, or interfaces</li>
<li>Place this abstract overall model in its own MODULE</li>
</ul></li>
<li>The ABSTRACT CORE should end up looking a lot like the distillation
document</li>
</ul>
</div>
</div>
<div id="outline-container-org5d3bc62" class="outline-4">
<h4 id="org5d3bc62">Deep Models Distill</h4>
<div class="outline-text-4" id="text-org5d3bc62">
<ul class="org-ul">
<li>Although a breakthrough to a deep model provides value anywhere it
happens, it is in the CORE DOMAIN that it can change the trajectory
of an entire project.</li>
</ul>
</div>
</div>
<div id="outline-container-org5017c85" class="outline-4">
<h4 id="org5017c85">Choosing Refactoring Targets</h4>
<div class="outline-text-4" id="text-org5017c85">
<ul class="org-ul">
<li>Where do you start?
<ol class="org-ol">
<li>Just start anywhere, because it all has to be factored
<ul class="org-ul">
<li>Impractical
(except in a few projects staffed entirely with top programmers)</li>
<li>When you have the luxury of refactoring freely, you focus first
on better factoring of the CORE DOMAIN, on improving the
segregation of the CORE, and on purifying supporting subdomains
to be GENERIC.</li>
</ul></li>
<li>Start wherever it is hurting (<b>Pain-Driven Refactoring</b>). I'll
refactor what I need to in order to get my specific task done.
<ul class="org-ul">
<li>Tends to pick around the edges, treating symptoms and ignoring
root causes, shying away from the worst tangles</li>
<li>In a pain-driven refactoring, you look to see if the root
involves the CORE DOMAIN or the relationship of the CORE to a
supporting element. If it does, you bite the bullet and fix
that first.</li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgeb3bdf0" class="outline-3">
<h3 id="orgeb3bdf0">Chapter Sixteen. Large-Scale Structure</h3>
<div class="outline-text-3" id="text-orgeb3bdf0">
<ul class="org-ul">
<li><i>Layers would outline their story of the system.</i></li>
<li>The strict segregation imposed by BOUNDED CONTEXTS prevents
corruption and confusion, but it does not, in itself, make it easier
to see the system as a whole.</li>
<li>On a project of any size, people must work somewhat independently on
different parts of the system.
<ul class="org-ul">
<li>Without any coordination or rules, a confusion of different styles
and distinct solutions to the same problems arises, making it hard
to understand how the parts fit together and impossible to see the
big picture.</li>
</ul></li>
<li>Devise a pattern of rules or roles and relationships that will span
the entire system and that allows some understanding of each part's
place in the wholeeven without detailed knowledge of the part's
responsibility.</li>
<li>This chapter explores <b>patterns for successfully structuring a
design</b> at this level.</li>
<li>Some patterns (and their relationships)
<ul class="org-ul">
<li>Model-Driven Design
<ul class="org-ul">
<li>(guide thinking by) System Metaphor
<ul class="org-ul">
<li>(enters) UBIQUITOUS LANGUAGE</li>
</ul></li>
<li>(stratify into) RESPONSIBILITY LAYERS
<ul class="org-ul">
<li>(names enter) UBIQUITOUS LANGUAGE</li>
</ul></li>
<li>(separate plastic behavior into) KNOWLEDGE LEVEL</li>
<li>(decouple contributions) PLUG-ABLE COMPONENT FRAMEWORK</li>
<li>(discover/distill structure through) EVOLVING ORDER</li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org50b6ab7" class="outline-4">
<h4 id="org50b6ab7">Evolving Order</h4>
<div class="outline-text-4" id="text-org50b6ab7">
<ul class="org-ul">
<li>Architectures can straitjacket a project with up-front design
assumptions and take too much power away from the
developers/designers of particular parts of the application.</li>
<li>Therefore
<ul class="org-ul">
<li>Let the conceptual large-scale structure evolve with the
application</li>
<li>Don't over-constrain the detailed design and model decisions that
must be made with detailed knowledge</li>
</ul></li>
<li>A really nice fit of structure to domain and requirements actually
makes detailed modeling and design easier, by helping to quickly
eliminate a lot of options.</li>
<li>The structure can also give shortcuts to design decisions that
could, in principle, be found by working on the individual object
level, but would, in practice, take too long and have inconsistent
results.</li>
<li>A large-scale structure generally needs to be applicable across
BOUNDED CONTEXTS.</li>
<li>Large-scale structures must accommodate practical constraints on
development.</li>
<li>Unlike the CONTEXT MAP, a large-scale structure is optional.</li>
<li>An ill-fitting structure is worse than none</li>
</ul>
</div>
</div>
<div id="outline-container-org8be8464" class="outline-4">
<h4 id="org8be8464">System Metaphor</h4>
<div class="outline-text-4" id="text-org8be8464">
<ul class="org-ul">
<li>Software designs tend to be very abstract and hard to grasp.</li>
<li>SYSTEM METAPHOR has become a popular approach because it is one of
the core practices of Extreme Programming</li>
<li>Therefore
<ul class="org-ul">
<li>When a concrete analogy to the system emerges that captures the
imagination of team members and seems to lead thinking in a useful
direction, adopt it as a large-scale structure.</li>
</ul></li>
<li>The "Naive Metaphor" and Why We Don't Need It
<ul class="org-ul">
<li>a mature domain model is anything but naive</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga95cda3" class="outline-4">
<h4 id="orga95cda3">Responsibility Layers</h4>
<div class="outline-text-4" id="text-orga95cda3">
<ul class="org-ul">
<li>Layers are partitions of a system in which the members of each
partition are aware of and are able to use the services of the
layers "below," but unaware of and independent of the layers
"above."
<ul class="org-ul">
<li>But this ad hoc layering, while it can make tracing dependencies
easierand sometimes makes some intuitive sensedoesn't give much
insight into the model or guide modeling decisions.</li>
</ul></li>
<li>Therefore:
<ul class="org-ul">
<li>Look at the conceptual dependencies in your model and the varying
rates and sources of change of different parts of your domain.</li>
<li>If you identify natural strata in the domain, cast them as broad
abstract responsibilities. These responsibilities should <b>tell a
story of the high-level purpose and design of your system</b>.</li>
<li>Refactor the model so that the responsibilities of each domain
object, AGGREGATE, and MODULE fit neatly within the responsibility
of one layer.</li>
</ul></li>
<li>Choosing Appropriate Layers
<ul class="org-ul">
<li>some useful characteristics to look for and preserve.
<dl class="org-dl">
<dt>Storytelling</dt><dd>The layers should bring out the priorities of the
business.</dd>
<dt>Conceptual dependency</dt><dd>The concepts in the "upper" layers should have meaning
against the backdrop of the "lower" layers, while the
lower-layer concepts should be meaningful standing alone.</dd>
<dt>CONCEPTUAL CONTOURS</dt><dd>If the objects of different layers should have different
rates of change or different sources of change, the layer
accommodates the shearing between them.</dd>
</dl></li>
<li>Certain layers show up in whole families of related domains.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd160400" class="outline-4">
<h4 id="orgd160400">Knowledge Level</h4>
<div class="outline-text-4" id="text-orgd160400">
<ul class="org-ul">
<li>A KNOWLEDGE LEVEL is a group of objects that <b>describes how another
group of objects should behave</b>.</li>
<li>KNOWLEDGE LEVEL untangles things <b>when we need to let some part of
the model itself be plastic in the user's hands</b> yet constrained by
a broader set of rules.</li>
<li>In an application in which the roles and relationships between
ENTITIES vary in different situations, complexity can explode.</li>
<li>Therefore:
<ul class="org-ul">
<li>Create a distinct set of objects that can be used to describe and
constrain the structure and behavior of the basic model.</li>
<li>Keep these concerns separate as two "levels,"
<ol class="org-ol">
<li>one very concrete,</li>
<li>the other reflecting rules and knowledge that a user or
superuser is able to customize.</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0a82174" class="outline-4">
<h4 id="org0a82174">Pluggable Component Framework</h4>
<div class="outline-text-4" id="text-org0a82174">
<ul class="org-ul">
<li>Therefore:
<ul class="org-ul">
<li>Distill an ABSTRACT CORE of interfaces and interactions and create
a framework that allows diverse implementations of those
interfaces to be freely substituted.</li>
<li>Likewise, allow any application to use those components, so long
as it operates strictly through the interfaces of the ABSTRACT
CORE.</li>
</ul></li>
<li>a few downsides
<ol class="org-ol">
<li>It's a very difficult pattern to apply</li>
<li>applications have limited options
<ul class="org-ul">
<li>If an application needs a very different approach to the CORE
DOMAIN, the structure will get in the way.</li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org59c7a90" class="outline-4">
<h4 id="org59c7a90">How Restrictive Should a Structure Be?</h4>
<div class="outline-text-4" id="text-org59c7a90">
<ul class="org-ul">
<li>The most important contribution of the large-scale structure is
conceptual coherence, and giving insight into the domain.</li>
<li>Each structural rule should make development easier.</li>
</ul>
</div>
</div>
<div id="outline-container-orgdd1c455" class="outline-4">
<h4 id="orgdd1c455">Refactoring Toward a Fitting Structure</h4>
<div class="outline-text-4" id="text-orgdd1c455">
<ul class="org-ul">
<li>The only way a useful structure can be found is from <b>a very deep
understanding of the domain and the problem</b>,</li>
<li>The practical way to that understanding is <b>an iterative development
process</b>.</li>
<li>Some general ways of controlling the cost and maximizing the gain.
<ol class="org-ol">
<li>Minimalism
<ul class="org-ul">
<li>Keep the structure simple and lightweight</li>
</ul></li>
<li>Communication and Self-Discipline</li>
<li>Restructuring Yields Supple Design
<ul class="org-ul">
<li>Each time the structure changes, the entire system has to be
changed to adhere to the new order.</li>
<li>A design with a large-scale structure is usually much easier to
transform than one without</li>
</ul></li>
<li>Distillation Lightens the Load
<ul class="org-ul">
<li>Continuous distillation reduces the difficulty of changing the
structure in various ways</li>
<li>The principles of distillation and refactoring toward deeper
insight apply even to the large-scale structure itself.</li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgcc718ad" class="outline-3">
<h3 id="orgcc718ad">Chapter Seventeen. Bringing the Strategy Together</h3>
<div class="outline-text-3" id="text-orgcc718ad">
</div>
<div id="outline-container-orgd36574b" class="outline-4">
<h4 id="orgd36574b">Combining Large-Scale Structures and BOUNDED CONTEXTS</h4>
</div>
<div id="outline-container-org2b80804" class="outline-4">
<h4 id="org2b80804">Combining Large-Scale Structures and Distillation</h4>
</div>
<div id="outline-container-org9eefc3c" class="outline-4">
<h4 id="org9eefc3c">Assessment First</h4>
<div class="outline-text-4" id="text-org9eefc3c">
<ul class="org-ul">
<li>start from a clear assessment of the current situation.
<ol class="org-ol">
<li>Draw a CONTEXT MAP</li>
<li>Attend to the use of language on the project</li>
<li>Understand what is important</li>
<li>Does the technology of the project work for or against a
MODEL-DRIVEN DESIGN?</li>
<li>Do the developers on the team have the necessary technical
skills?</li>
<li>Are the developers knowledgeable about the domain?
Are they <i>interested</i> in the domain?</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-orgd7767fd" class="outline-4">
<h4 id="orgd7767fd">Who Sets the Strategy?</h4>
<div class="outline-text-4" id="text-orgd7767fd">
<ol class="org-ol">
<li>Emergent Structure from Application Development</li>
<li>A Customer Focused Architecture Team</li>
</ol>
</div>
</div>
<div id="outline-container-org785017c" class="outline-4">
<h4 id="org785017c">Six Essentials for Strategic Design Decision Making</h4>
<div class="outline-text-4" id="text-org785017c">
<ul class="org-ul">
<li>6 essentials
<ol class="org-ol">
<li>Decisions must reach the entire team</li>
<li>The decision process must absorb feedback</li>
<li>The plan must allow for evolution</li>
<li>Architecture teams must not siphon off all the best and brightest
<ul class="org-ul">
<li>It is essential to have strong designers on all application
teams.</li>
</ul></li>
<li>Strategic design requires minimalism and humility</li>
<li>Objects are specialists; developers are generalists
<ul class="org-ul">
<li>The essence of good object design is (a specialist)
<ol class="org-ol">
<li>to give each object a clear and narrow responsibility</li>
<li>to reduce interdependence to an absolute minimum</li>
</ol></li>
<li>Having two kinds of design activity does not mean having two
kinds of people. -&gt; let the developers be generalists.</li>
</ul></li>
</ol></li>
<li>The Same Goes for the Technical Frameworks
<ul class="org-ul">
<li>Don't write frameworks for dummies
<ul class="org-ul">
<li>If those people are not smart enough to design, they shouldn't
be assigned to develop software.</li>
<li>If they are smart enough, then the attempts to coddle them will
only put up barriers between them and the tools they need.</li>
</ul></li>
<li>Beware the Master Plan</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd185930" class="outline-3">
<h3 id="orgd185930">Conclusion</h3>
<div class="outline-text-3" id="text-orgd185930">
</div>
<div id="outline-container-orga0ca5d7" class="outline-4">
<h4 id="orga0ca5d7">Epilogues</h4>
<div class="outline-text-4" id="text-orga0ca5d7">
<ul class="org-ul">
<li><b>The true test of success is how the software serves over a period of
time.</b></li>
<li>Any project committed to domain-driven design will be recognizable
in a few ways.
<ol class="org-ol">
<li>The defining characteristic is a priority on understanding the
target domain and incorporating that understanding into the
software. Everything else flows from that premise.</li>
<li>Team members are conscious of the use of language on the project
and cultivate its refinement.</li>
<li>They are hard to satisfy with the quality of the domain model,
because they keep learning more about the domain. They see
continuous refinement as an opportunity and an ill-fitting model
as a risk.</li>
<li>They take design skill seriously because it isn't easy to develop
production-quality software that clearly reflects the domain
model.</li>
<li>They stumble over obstacles, but they hold on to their principles
as they pick themselves up and continue forward.</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org9b289e1" class="outline-4">
<h4 id="org9b289e1">Looking Forward</h4>
<div class="outline-text-4" id="text-org9b289e1">
<ul class="org-ul">
<li>Although purely technological tasks have generally seemed most
interesting and challenging to talented software engineers,
domain-driven design opens up a new area of challenge that is at
least equal.</li>
<li><b>Creating good software is a learning and thinking activity.</b>
<ul class="org-ul">
<li><b>Modeling requires imagination and self-discipline.</b></li>
<li>Efforts to automate what must be the product of thought are naive
and counterproductive.</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>

    </div>
</section>


    <div class="post-meta">
        <span title="post date" class="post-info">2018-08-07</span>
        <span title="last modification date" class="post-info">2018-08-07</span>
        <span title="tags" class="post-info"><a href="/tags/clipping/">Clipping</a>, <a href="/tags/ddd/">DDD</a></span>
        <span title="author" class="post-info">Yiming Chen</span>
    </div>
  <section>
    <h1>Comments</h1>
    <script src="https://utteranc.es/client.js"
      repo="dsdshcym/dsdshcym.github.io"
      issue-term="title"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </section>
<footer class="footer">
  <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> (<a href="http://orgmode.org">Org mode</a>)</p>
  <p>
    Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:dsdshcym &lt;at&gt; gmail &lt;dot&gt; com">Yiming Chen</a>
    &nbsp;&nbsp;-&nbsp;&nbsp;
    Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
    <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
  </p>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-152951733-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-152951733-1');
</script>

  </body>
</html>
