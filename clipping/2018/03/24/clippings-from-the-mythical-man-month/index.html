<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>Clippings from The Mythical Man-Month - Yiming Chen</title>
  <meta charset="utf-8" />
  <meta name="author" content="Yiming Chen" />
  <meta name="keywords" content="Software Engineering, The Mythical Man-Month, Management" />

  <link rel="alternate" title="RSS Feed" href="/rss.xml" type="application/rss+xml">
  <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  <link rel="stylesheet" href="/media/css/posts.css" type="text/css">
  <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
  <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>

  <script src="/media/js/main.js"></script>
</head>

  <body class="container">
<header id="header">
    <body>
        <nav class="navbar navbar-default navbar-fixed-top" style="opacity: .9" role="navigation">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">Yiming Chen</a>
                </div>
                <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="/blog/">Blog</a></li>
                        <li><a href="/clipping/">Clipping</a></li>
                        <li><a href="/tags/">Tags</a></li>
                        <li><a href="/about/">About</a></li>
                        <li><a href="https://github.com/dsdshcym">GitHub</a></li>
                        <li><a href="/rss.xml">RSS</a></li>
                        <li><a href="https://webring.xxiivv.com/#random">Webring</a></li>
                    </ul>
                </div>
            </div>
        </nav>
    </body>
</header>

<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>Clippings from The Mythical Man-Month</h1>

<div id="outline-container-orga869bba" class="outline-2">
<h2 id="orga869bba">Preface to the 20th Anniversary Edition</h2>
</div>
<div id="outline-container-org903a8dc" class="outline-2">
<h2 id="org903a8dc">Preface to the First Edition</h2>
</div>
<div id="outline-container-orgbfe5664" class="outline-2">
<h2 id="orgbfe5664">Chapter 1. The Tar Pit</h2>
<div class="outline-text-2" id="text-orgbfe5664">
<ul class="org-ul">
<li>Large-system programming is a tar pit that so many great and powerful beasts
have sunk in it</li>
<li>The Programming Systems Product
<ul class="org-ul">
<li>A Program</li>
<li>A Programming Product</li>
<li>A Programming System</li>
<li>A Programming Systems Product</li>
</ul></li>
<li>The Joy of the Craft
<ol class="org-ol">
<li>Making things</li>
<li>Making things that are useful to other people</li>
<li>Fashioning complex puzzle-like objects of interlocking moving parts and
watching them work in subtle cycles, playing out the consequences of
principles built in from the beginning</li>
<li>Always learning</li>
<li>Working in such a tractable, flexible medium</li>
</ol></li>
<li>The Woes of the Craft
<ol class="org-ol">
<li>One must perform perfectly</li>
<li>One rarely control the circumstances of his work, or even its goal</li>
<li>Dependencies are often mal-designed, poorly implemented, incompletely
delivered, and poorly documented</li>
<li>Designing grand concepts is fun, but finding nitty little bugs is just work</li>
<li>Debugging has a linear convergence (the last difficult bugs takes more time
to find than the first)</li>
<li>The product appears to be obsolete upon (or before) completion
<ul class="org-ul">
<li>As soon as one freezes a design, it becomes obsolete in terms of its
concepts</li>
<li><b>The obsolescence of an implementation must be measured against other
existing implementations, not against unrealized concepts</b></li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-orgdebc0e5" class="outline-2">
<h2 id="orgdebc0e5">Chapter 2. The Mythical Man-Month</h2>
<div class="outline-text-2" id="text-orgdebc0e5">
<ul class="org-ul">
<li>Scheduling tasks is hard
<ol class="org-ol">
<li>Our techniques of estimating are poorly developed</li>
<li>Our estimating techniques fallaciously confuse effort with progress, hiding
the assumption that men and months are interchangeable</li>
<li>Software managers often lack the courteous stubbornness because we are
uncertain of our estimates</li>
<li>Schedule progress is poorly monitored</li>
<li>When schedule slippage is recognized, the natural and traditional response
is to add manpower</li>
</ol></li>
<li>Optimism
<ul class="org-ul">
<li>The first false assumption: <i>all will go well</i> (<i>each task will hike only as
long as it "ought" to take</i>)</li>
<li>3 stages of a creative activity (book, program, etc.) from <i>The Mind of the Maker</i>
<ol class="org-ol">
<li>the idea</li>
<li>the implementation</li>
<li>the interaction</li>
</ol></li>
<li>Because the medium (computer) is tractable, we expect few difficulties in
implementation -&gt; optimism</li>
<li>A large programming effort, however, consists of many tasks, some chained
end-to-end. The probability that each will go well becomes vanishingly
small.</li>
</ul></li>
<li>The Man-Month
<ul class="org-ul">
<li><b>The man-month as a unit for measuring the size of a job is a dangerous and
deceptive myth.</b>
<ul class="org-ul">
<li><i>Cost</i> does indeed vary as the product of the number of men and the number
of months</li>
<li><i>Progress</i> does not vary</li>
</ul></li>
<li>Men and months are not interchangeable (for programming)
<ol class="org-ol">
<li>They are interchangeable commodities only when a task can be partitioned
among many workers <b>with no communication among them</b>
<ul class="org-ul">
<li>reaping wheat</li>
<li>picking cotton</li>
</ul></li>
<li>When a task cannot be partitioned because of sequential constraints, the
application of more effort has no effect on the schedule
<ul class="org-ul">
<li><b>The bearing of a child takes nine months, no matter how many women are
assigned.</b></li>
</ul></li>
<li>When a task can be partitioned but requires communication among the
subtasks, the effort of communication must be added to the amount of work
to be done</li>
</ol></li>
<li>The added burden of communication is made up of two parts
<ol class="org-ol">
<li>Training
<ul class="org-ul">
<li>Cannot be partitioned</li>
</ul></li>
<li>Intercommunication
<ul class="org-ul">
<li>O(n^2)</li>
<li>The added effort of communicating may fully counteract the division of
the original task and bring us to this situation</li>
</ul></li>
</ol></li>
<li>Since software construction is inherently a systems effort, an exercise in
complex interrelationships, communication effort is great, and it quickly
dominates the decrease in individual task time brought about by
partitioning.</li>
</ul></li>
<li>Systems Test
<ul class="org-ul">
<li>Because of optimism, we usually expect the number of bugs to be smaller than
it turns out to be. Therefore testing is usually the most mis-scheduled part
of programming.</li>
<li>Rule of thumb
<ul class="org-ul">
<li>1/3 planning</li>
<li>1/6 coding</li>
<li>1/4 component test and early system test</li>
<li>1/4 system test, all components in hand</li>
</ul></li>
<li>Failure to allow enough time for system test, in particular, is peculiarly
disastrous.
<ul class="org-ul">
<li>Since the delay comes at the end of the schedule, no one is aware of
schedule trouble until almost the delivery date.</li>
<li>Delay at this point has unusually severe financial, as well as
psychological, repercussions.</li>
</ul></li>
</ul></li>
<li>Gutless Estimating
<ul class="org-ul">
<li>False scheduling to match the patron's desired date is much more common in
our discipline than elsewhere in engineering.</li>
</ul></li>
<li><b>Regenerative Schedule Disaster</b>
<ul class="org-ul">
<li><p>
<b>Brooks's Law</b>
</p>
<blockquote>
<p>
Adding manpower to a late software project makes it later.
</p>
</blockquote></li>
<li>One can derive schedules using fewer men and more months.</li>
<li>One cannot, however, get workable schedules using more men and fewer months.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org83cf7dd" class="outline-2">
<h2 id="org83cf7dd">Chapter 3. The Surgical Team</h2>
<div class="outline-text-2" id="text-org83cf7dd">
<ul class="org-ul">
<li>The Problem
<dl class="org-dl">
<dt>The problem with large teams</dt><dd>Not everyone is a 10x programmer</dd>
<dt>The problem with small, sharp team concept</dt><dd>Too slow for really big systems</dd>
</dl></li>
<li><p>
Mills's Proposal (The Surgical Team)
</p>
<blockquote>
<p>
Instead of each member cutting away on the problem, one does the cutting and
the others give him every support that will enhance his effectiveness and
productivity.
</p>
</blockquote></li>
</ul>
</div>
</div>
<div id="outline-container-orgf0f3da5" class="outline-2">
<h2 id="orgf0f3da5">Chapter 4. Aristocracy, Democracy, and System Design</h2>
<div class="outline-text-2" id="text-orgf0f3da5">
<ul class="org-ul">
<li>Conceptual Integrity
<ul class="org-ul">
<li>Software and Cathedrals
<ul class="org-ul">
<li>Most cathedrals show differences between parts built in different
generations by different builders</li>
<li>Most software reflect <i>conceptual disunity</i> far worse than that of
cathedrals (from the separation of design into many tasks done by many men)</li>
</ul></li>
<li><i>Conceptual integrity</i> is <b>the most important consideration in system
design</b></li>
<li>Chapter 4-7
<ol class="org-ol">
<li>How is conceptual integrity to be achieved?</li>
<li>Does not this argument imply an elite, or aristocracy of architects, and
a horde of plebeian implementer whose creative talents and ideas are
suppressed?</li>
<li>How does one keep the architects from drifting off into the blue with
unimplementable or costly specifications?</li>
<li>How does one ensure that every trifling detail of an architectural
specification get communicated to the implementer, properly understood by
him, and accurately incorporated into the product?</li>
</ol></li>
</ul></li>
<li>Achieving Conceptual Integrity
<ul class="org-ul">
<li>The purpose of a programming system is to make a computer easy to use</li>
<li><b>The ratio of <i>function</i> to <i>conceptual complexity</i> is the ultimate test of
system design</b>
<ul class="org-ul">
<li>Neither <i>function</i> alone nor <i>simplicity</i> alone defines a good design</li>
</ul></li>
</ul></li>
<li>Aristocracy and Democracy
<ul class="org-ul">
<li>Dilemma
<dl class="org-dl">
<dt>Conceptual integrity</dt><dd>The design must proceed from one mind (or a very small number of minds)</dd>
<dt>Schedule pressures</dt><dd>The system building needs many hands</dd>
</dl></li>
<li>Solution
<ol class="org-ol">
<li>Chapter 3. The Surgical Team</li>
<li><p>
Separate architecture (UI) and implementation (Details)
</p>
<blockquote>
<p>
Where architecture tells <i>what</i> happens, implementation tells
<i>how</i> it is made to happen
</p>
</blockquote>
<ul class="org-ul">
<li><i>Architecture</i> -&gt; The complete and detailed specification of
the user interface (UI)</li>
<li>The setting of external specifications is not more creative
work than the designing of implementations.</li>
</ul></li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge5abf4a" class="outline-2">
<h2 id="orge5abf4a">Chapter 5. The Second-System Effect</h2>
<div class="outline-text-2" id="text-orge5abf4a">
<ul class="org-ul">
<li>An architect's first work is apt to be spare and clean
<ol class="org-ol">
<li>He knows the doesn't know what he's doing</li>
<li>He does it carefully and with great restraint</li>
</ol></li>
<li>The Second-System Effect
<ul class="org-ul">
<li>The general tendency is to <b>over-design</b> the second system
<ul class="org-ul">
<li>OS/360 is a prime example of the second-system effect</li>
</ul></li>
<li>Another tendency is to <b>refine obsoleted techniques</b></li>
</ul></li>
<li>How to avoid the second-system effect
<ul class="org-ul">
<li>Architect
<ol class="org-ol">
<li>Be conscious of the peculiar hazards of the second-system</li>
<li>Exert extra <b>self-discipline</b> to
<ol class="org-ol">
<li>avoid functional ornamentation</li>
<li>avoid extrapolation of functions that are obviated by changes
in assumptions and purposes</li>
</ol></li>
</ol></li>
<li>Project Manager
<ol class="org-ol">
<li>Insist on a senior architect who has <b>at least two</b> systems
under his belt</li>
<li>Stay aware of the special temptations</li>
</ol></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgccc96a1" class="outline-3">
<h3 id="orgccc96a1"><a href="https://en.wikipedia.org/wiki/Second-system_effect">Second-system effect - Wikipedia</a></h3>
<div class="outline-text-3" id="text-orgccc96a1">
<blockquote>
<p>
The tendency of small, elegant, and successful systems, to be
succeeded by over-engineered, bloated systems, due to inflated
expectations and overconfidence.
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgd17526b" class="outline-2">
<h2 id="orgd17526b">Chapter 6. Passing the Word</h2>
<div class="outline-text-2" id="text-orgd17526b">
<p>
<b>How shall the manager ensure that everyone hears, understands, and
implements the architects' decisions?</b>
(A successful solution for the System/360 hardware design effort)
</p>
<ol class="org-ol">
<li>Written Specifications - the Manual
<ul class="org-ul">
<li>The <i>external</i> specification of the product</li>
<li>The architect must
<ol class="org-ol">
<li><b>always be prepared to show <i>an</i> implementation for any feature
he describes</b></li>
<li>but not attempt to dictate <i>the</i> implementation</li>
</ol></li>
<li>The style must be precise, full, and accurately detailed.</li>
</ul></li>
<li>Formal Definitions
<ul class="org-ul">
<li>Future specifications will consist of both a formal definition
<i>and</i> a prose definition
<ul class="org-ul">
<li>Formal Definitions are <b>precise</b></li>
<li>Prose Definitions can <b>explain why</b></li>
</ul></li>
<li>But there can be <b>only one</b> primary standard</li>
<li>An implementation can also serve as a formal definition
<ul class="org-ul">
<li>Advantages
<ol class="org-ol">
<li>All questions can be settled unambiguously by experiment</li>
<li>Debate is never needed</li>
<li>Answers are always as precise as one wants</li>
<li>Answers are always correct, by definition</li>
</ol></li>
<li>Disadvantages
<ol class="org-ol">
<li>The implementation may over-prescribe even the externals
<ol class="org-ol">
<li>Side effects</li>
<li>Not only what it must do, but also how to do it</li>
</ol></li>
<li>Sometimes give unexpected and unplanned answers (Vim and its
Emulators)</li>
<li>the use of an implementation as a formal definition is
peculiarly susceptible to confusion as to whether the prose
description or the formal description is in fact the
standard.</li>
</ol></li>
</ul></li>
</ul></li>
<li>Direct Incorporation</li>
<li>Conferences and Courts
<ol class="org-ol">
<li>Weekly half-day conference of all the architects, plus official
representatives of the implementers, and the market planners</li>
<li>Semi-Annual supreme court sessions (two weeks every six months)
<ul class="org-ul">
<li>To solve issues, appeals, or disgruntlements</li>
</ul></li>
</ol></li>
<li>Multiple Implementations
<ul class="org-ul">
<li>when you have enough time and manpower</li>
</ul></li>
<li>The Telephone Log
<ul class="org-ul">
<li>Keep a text log for questions/issues</li>
</ul></li>
<li>Product Test</li>
</ol>
</div>
</div>
<div id="outline-container-org63fee61" class="outline-2">
<h2 id="org63fee61">Chapter 7. Why Did the Tower of Babel Fail?</h2>
<div class="outline-text-2" id="text-org63fee61">
<ul class="org-ul">
<li>Where did they lack?
<ol class="org-ol">
<li>Communication
<ul class="org-ul">
<li>lack of communication led to disputes, bad feelings, and group
jealousies.</li>
</ul></li>
<li>Organization (1's consequence)</li>
</ol></li>
<li>Communication in the Large Programming Project
<ul class="org-ul">
<li>A formal project work book must be started at the beginning</li>
<li>The Project Workbook
<dl class="org-dl">
<dt>What</dt><dd><i>All</i> the documents of the project
<ol class="org-ol">
<li>Objectives</li>
<li>External specifications</li>
<li>Interface specifications</li>
<li>Technical standards</li>
<li>Internal specifications</li>
<li>Administrative memorandum</li>
</ol></dd>
<dt>Why</dt><dd><ol class="org-ol">
<li>Technical prose is almost immortal</li>
<li>Ensure that relevant information gets to all the people who
need it (Control of the distribution of information )</li>
</ol></dd>
<dt>Mechanics</dt><dd><ol class="org-ol">
<li>Each programmer should see all the material</li>
<li>Timely updating</li>
</ol></dd>
</dl></li>
</ul></li>
<li>Organization in the Large Programming Project
<ul class="org-ul">
<li>The purpose of organization is to <b>reduce the amount of
communication and coordination necessary</b></li>
<li>The means by which communication is obviated
<ol class="org-ol">
<li>division of labor</li>
<li>specialization of function</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgef043bd" class="outline-2">
<h2 id="orgef043bd">Chapter 8. Calling the Shot</h2>
<div class="outline-text-2" id="text-orgef043bd">
<ul class="org-ul">
<li>Teams are only realizing 50 percent of the working week as actual
programming and debugging time (20 hours per week)</li>
<li>Programming productivity may be increased as much as five times when
a suitable high-level language is used</li>
</ul>
</div>
</div>
<div id="outline-container-orgfff4a87" class="outline-2">
<h2 id="orgfff4a87">Chapter 9. Ten Pounds in a Five-Pound Sack</h2>
<div class="outline-text-2" id="text-orgfff4a87">
<ul class="org-ul">
<li>Program Space as Cost
<ul class="org-ul">
<li>Since size is such a large part of the user cost of a programming
system product, the builder must set size targets, control size,
and devise size-reduction techniques</li>
</ul></li>
<li>Size Control
<ol class="org-ol">
<li>Budget all aspects of size</li>
<li>Define exactly what a module must do when you specify how big it
must be</li>
</ol></li>
<li>Space Techniques</li>
<li><b>Representation (Data Structure) Is the Essence of Programming</b>
<ul class="org-ul">
<li>Almost always faster algorithms are the result of stategic
breakthrough rather than tactical cleverness.</li>
<li>Much more often, strategic breakthrough will come from redoing the
representation of the data or tables.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org447ff8a" class="outline-2">
<h2 id="org447ff8a">Chapter 10. The Documentary Hypothesis</h2>
<div class="outline-text-2" id="text-org447ff8a">
<ul class="org-ul">
<li>Why Formal Documents?
<ol class="org-ol">
<li>writing the decisions down is essential</li>
<li>the documents will communicate the decisions to others</li>
<li>a manager's documents give him a data base and checklist.</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org4d1bc0d" class="outline-2">
<h2 id="org4d1bc0d">Chapter 11. Plan to Throw One Away</h2>
<div class="outline-text-2" id="text-org4d1bc0d">
<ul class="org-ul">
<li>Pilot Plants and Scaling Up
<ul class="org-ul">
<li>Chemical engineers learned long ago that a process that works in
the laboratory <b>cannot be implemented in a factory in only one
step.</b></li>
<li>Delivering that throwaway to customers buys time, but it does so
only at the cost of agony for the user, distraction for the
builders while they do the redesign, and a bad reputation for the
product that the best redesign will find hard to live down.</li>
<li><b>Plan to throw one away; you will, anyhow.</b></li>
</ul></li>
<li><b>The Only Constancy Is Change Itself</b></li>
<li>Plan the System for Change
<ul class="org-ul">
<li>Most important is <b>the use of a high-level language</b> and
<b>self-documenting techniques</b> so as to reduce errors induced by
changes.</li>
</ul></li>
<li>Plan the Organization for Change
<ul class="org-ul">
<li><p>
The reluctance to document designs comes from the designer's
reluctance to commit himself to the defense of decisions which he
knows to be tentative
</p>
<blockquote>
<p>
By documenting a design, the designer exposes himself to the
criticisms of everyone, and he must be able to defend everything
he writes. If the organizational structure is threatening in any
way, nothing is going to be documented until it is com- pletely
defensible.
</p>
</blockquote></li>
<li>Structuring an organization for change is much harder than
designing a system for change.</li>
<li>Management structures also need to be changed as the system
changes.</li>
</ul></li>
<li>Plan to Throw One Away
<ul class="org-ul">
<li>The fundamental problem with program maintenance is that fixing a
defect has a substantial (20-50 percent) chance of introducing
another.
<ol class="org-ol">
<li>unless the structure is pure or the documentation very fine,
the far-reaching effects of the repair will be overlooked.</li>
<li>the repairer is usually not the man who wrote the code, and
often he is a junior programmer or trainee.</li>
</ol></li>
<li>Program maintenance requires far more system testing per statement
written than any other programming.</li>
</ul></li>
<li>One step forward and one step back
<ul class="org-ul">
<li>Less and less effort is spent on fixing original design flaws;
more and more is spent on fixing flaws introduced by earlier
fixes.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org37406bb" class="outline-2">
<h2 id="org37406bb">Chapter 12. Sharp Tools</h2>
<div class="outline-text-2" id="text-org37406bb">
<blockquote>
<p>
A good workman is known by his tools
</p>
</blockquote>
<ul class="org-ul">
<li>What are the tools about which the manager must philosophize, plan,
and organize?
<ol class="org-ol">
<li>Computer Facility</li>
<li>Operating System</li>
<li>Language
<ol class="org-ol">
<li><b>High-level language</b></li>
<li><b>Interactive programming</b></li>
</ol></li>
<li>Utilities</li>
<li>Debugging aids</li>
<li>Test-case generators</li>
<li>Text-processing system (for documentation)</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org33fc304" class="outline-2">
<h2 id="org33fc304">Chapter 13. The Whole and the Parts</h2>
<div class="outline-text-2" id="text-org33fc304">
<ul class="org-ul">
<li>This Chapter
<ol class="org-ol">
<li>How does one build a program to work?</li>
<li>How does one test a program</li>
<li>How does one integrate a tested set of component programs into a
tested and dependable system?</li>
</ol></li>
<li>Designing the Bugs Out
<ul class="org-ul">
<li>Bug-proofing the definition
<ul class="org-ul">
<li>The most pernicious and subtle bugs are system bugs arising from
<b>mismatched assumptions</b> made by the authors of various
components</li>
<li><b>Conceptual integrity</b> can solve this issue</li>
<li>Careful function definition</li>
<li>Careful specification</li>
</ul></li>
<li><p>
Testing the specification
</p>
<blockquote>
<p>
They won't tell you they don't understand it; they will happily
invent their way through the gaps and obscurities.
</p>
</blockquote></li>
<li><b>Top-down design</b>
<ul class="org-ul">
<li>Program Development by Stepwise Refinement
<ul class="org-ul">
<li>Identify design as a sequence of <i>refinement steps</i> (refactoring?)
<ol class="org-ol">
<li>Sketch a rough task definition and a rough solution method
that achieves the principal result</li>
<li>Examine the definition more closely to see how the result
differs from what is wanted</li>
<li>Take the large setps of the solution and break them down
into smaller steps</li>
</ol></li>
<li>During this process, developer identifies <i>modules</i></li>
<li><b>Use as high-level annotation as is possible at each step</b>,
exposing the concepts and concealing the details until further
refinement becomes necessary</li>
</ul></li>
<li>How top-down design avoids bugs
<ol class="org-ol">
<li><b>The clarity of structure and representation</b> makes the
precise statement of requirements and functions of the
modules easier</li>
<li>The partitioning and independence of modules avoids system
bugs</li>
<li>The suppression of detail makes flaws in the structure more
apparent</li>
<li>The design can be tested at each of its refinement steps
<ul class="org-ul">
<li>So testing can start earlier</li>
<li>testing can focus on the proper level of detail at each
step</li>
</ul></li>
</ol></li>
<li>It's much easier to see exactly when and why one should throw
away a gross design and start over</li>
<li><b>Many poor systems come from an attempt to salvage a bad basic
design and patch it with all kinds of cosmetic relief.</b> Top-down
design reduces the temptation</li>
</ul></li>
<li>Structured programming
<ul class="org-ul">
<li>Do not use <code>goto</code></li>
<li><b>Think about the control structures of a system as control
structures</b>, not as individual branch statements.</li>
</ul></li>
</ul></li>
<li>Component Debugging
(The cycle of debugging procedures)
<ol class="org-ol">
<li>On-machine debugging</li>
<li>Memory dumps</li>
<li>Snapshots</li>
<li>Interactive debugging</li>
</ol></li>
<li>System Debugging
<ul class="org-ul">
<li>System debugging will take longer than one expects</li>
<li>Its difficulty justifies <b>a thoroughly systematic and planned
approach</b>
<ol class="org-ol">
<li>Use debugged components
<ul class="org-ul">
<li>The sooner one puts the pieces together, the sooner the
system bugs will emerge</li>
<li><b>One does <i>not</i> know all the expected effects of known bugs</b></li>
</ul></li>
<li>Build plenty of scaffolding
(programs and data built for debugging purpose)
<ol class="org-ol">
<li><i>dummy component</i> (<b>fake/mock/stub</b>)</li>
<li><i>miniature file</i>
<ul class="org-ul">
<li><i>dummy file</i></li>
</ul></li>
<li><i>auxiliary programs</i>
<ul class="org-ul">
<li>generators for test data (factories)</li>
<li>special analysis printouts</li>
<li>cross-reference table analyzers</li>
</ul></li>
</ol></li>
<li>Control changes</li>
<li>Add one component at a time
<ul class="org-ul">
<li>Assume there will be lots of bugs</li>
<li>Plan an orderly procedure for snaking bugs out</li>
</ul></li>
<li>Quantize updates</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0b0b6ad" class="outline-2">
<h2 id="org0b0b6ad">Chapter 14. Hatching a Catastrophe</h2>
<div class="outline-text-2" id="text-org0b0b6ad">
<ul class="org-ul">
<li>Day-by-day slippage is harder to recognize, harder to prevent,
harder to make up
<ul class="org-ul">
<li>Each one only postpones some activity by a half-day or a day.</li>
<li>And the schedule slips, one day at a time.</li>
</ul></li>
<li>Milestones or Millstones?
<ul class="org-ul">
<li>Milestones must be concrete, specific, measurable events, defined
with knife-edge sharpness.</li>
<li>Two interesting studies of Estimating behavior show that:
<ol class="org-ol">
<li><i>Estimates</i> of the length of an activity, made and revised
care- fully every two weeks before the activity starts, do not
signifi- cantly change as the start time draws near, no matter
how wrong they ultimately turn out to be.</li>
<li>During the activity, <i>overestimates</i> of duration come steadily
down as the activity proceeds.</li>
<li><i>Underestimates</i> do not change significantly during the
activity until about three weeks before the scheduled
completion.</li>
</ol></li>
</ul></li>
<li>"The Other Piece Is Late, Anyway"
<ul class="org-ul">
<li>Critical-path scheduling</li>
<li>PERT chart</li>
</ul></li>
<li>Under the Rug
<ul class="org-ul">
<li>When a first-line manager sees his small team slipping behind, he
is rarely inclined to run to the boss with this woe.</li>
<li><p>
The first-line manager's interests and those of the boss have an
inherent conflict here.
</p>
<blockquote>
<p>
The first-line manager fears that if he reports his problem, the
boss will act on it. Then his action will preempt the manager's
function, diminish his authority, foul up his other plans. So as
long as the manager thinks he can solve it alone, he doesn't tell
the boss.
</p>
</blockquote></li>
<li>Two rug-lifting techniques
<ol class="org-ol">
<li>Reducing the role conflict
<ol class="org-ol">
<li>The boss must distinguish between <i>action information</i> and
<i>status information</i></li>
<li>The boss must discipline himself
<ol class="org-ol">
<li><i>not</i> to act on problems his managers can solve</li>
<li><i>not</i> to act on problems when he is explicitly reviewing status</li>
</ol></li>
<li>The boss can label meetings, reviews, conferences, as
<i>status-review meetings</i> versus <i>problem-action meetings</i>,
and controls himself accordingly.</li>
</ol></li>
<li>Yanking the rug off
<ul class="org-ul">
<li>It is necessary to have review techniques by which the true
status is made known, whether cooperatively or not.</li>
<li>A report showing milestones and actual completions is the key
document.
<ol class="org-ol">
<li>Everyone knows the questions</li>
<li>The component manager should be prepared to explain why
it's late, when it will be finished, what steps he's
taking, and what help</li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
<li>Plans and Controls team</li>
</ul>
</div>
</div>
<div id="outline-container-org9e91124" class="outline-2">
<h2 id="org9e91124">Chapter 15. The Other Face</h2>
<div class="outline-text-2" id="text-org9e91124">
<ul class="org-ul">
<li>The Other Face
<ul class="org-ul">
<li>A computer program is a message from a man to a machine</li>
<li>But a written program has another face, that which <b>tells its
story to the human user</b>.
<ul class="org-ul">
<li>Even if you are not cooperating, memory will fail the
author-user, and you will require refreshing on the details of
his handiwork.</li>
</ul></li>
<li>The other face to the user is fully as important as the face to
the machine.</li>
<li><b>The "how" of good documentation</b></li>
</ul></li>
<li>What Documentation Is Required?
<ul class="org-ul">
<li>To use a program
<ol class="org-ol">
<li>Purpose</li>
<li>Environment</li>
<li>(Input) domain and (output) range</li>
<li>Functions realized and algorithms used</li>
<li>Input-output formats</li>
<li>Operating instructions</li>
<li>Options</li>
<li>Running time</li>
<li>Accuracy and checking</li>
</ol></li>
<li>To believe a program (test cases)
<ol class="org-ol">
<li>Mainline cases (chief functions for commonly encountered data)</li>
<li>Barely legitimate cases (probe the edge of the input data
domain)</li>
<li>Barely illegitimate cases (probe the domain boundary from the
other side)</li>
</ol></li>
<li>To modify a program
<ol class="org-ol">
<li>A flow chart or subprogram structure graph</li>
<li>Complete descriptions of the algorithms used, or self
references to such descriptions in the literature</li>
<li>An explanation of the file structures</li>
<li>And overview of the data pass structure (data flow)</li>
<li>A discussion of modifications contemplated in the original
design, the nature and location of hooks and exits</li>
</ol></li>
</ul></li>
<li>The Flow-Chart Curse
<ul class="org-ul">
<li>Flow charts show the decision structure of a program, which is
only one aspect of its structure.</li>
<li>The one-page flow chart for a substantial program becomes
essentially a diagram of program structure, and of phases or
steps.</li>
<li>The detailed blow-by-blow flow chart, however, is an obsolete
nuisance, suitable only for initiating beginners into algorithmic
thinking.</li>
<li><b>Flow charting is more preached than practiced.</b></li>
</ul></li>
<li>Self-Documenting Programs
<ul class="org-ul">
<li>As a principal objective, we must attempt to <b>minimize the burden
of documentation</b>, the burden neither we nor our predecessors have
been able to bear successfully.</li>
<li>An approach
<ol class="org-ol">
<li>Use the parts of the program that have to be there anyway
(symbol names), for programming language reasons, to carry  as
much of the documentation as possible</li>
<li>Use space and format as much as possible to improve readability
and show subordination and nesting</li>
<li>Insert the necessary prose documentation as paragraphs of
comment
<ul class="org-ul">
<li><i>Paragraph comments</i> are better than <i>line-by-line comments</i>
because they usually give inteligibility and overview to the
whole thing</li>
</ul></li>
</ol></li>
<li>Write documentations when the program is first written</li>
<li>Why not?
<ol class="org-ol">
<li>the increase in the size of the source code</li>
<li>more keystrokes</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgce6ec22" class="outline-2">
<h2 id="orgce6ec22">Chapter 16. No Silver Bullet - Essence and Accident in Software Engineering</h2>
<div class="outline-text-2" id="text-orgce6ec22">
<blockquote>
<p>
There is no single development, in either technology or management
technique, which by itselfpromises even one order-of-magnitude
improvement within a decade in productivity, in reliability, in
simplicity.
</p>
</blockquote>
<ul class="org-ul">
<li><a href="http://www.cs.nott.ac.uk/~pszcah/G51ISS/Documents/NoSilverBullet.html">No Silver Bullet: Essence and Accidents of Software Engineering</a></li>
<li><p>
Silver Bullet
</p>
<blockquote>
<p>
Of all the monsters that fill the nightmares of our folklore, none terrify
more than werewolves, because they transform unexpectedly from the familiar
into horrors. For these, one seeks bullets of silver that can magically lay
them to rest.
</p>
</blockquote>
<ul class="org-ul">
<li>The familiar software project, at least as seen by the nontechnical manager,
has something of this character</li>
</ul></li>
<li>Essential Difficulties
<ol class="org-ol">
<li>Not that software progress is so slow, but that computer hardware progress
is so fast (the fastest in human history)</li>
<li>The difficulties of software technology
<ul class="org-ul">
<li><p>
Essence (inherent)
</p>

<p>
I believe the hard part of building software to be the <b>specification</b>,
<b>design</b>, and <b>testing</b> of this conceptual construct, not the labor of
representing it and testing the fidelity of the representation.
</p>

<ul class="org-ul">
<li>Complexity
<ul class="org-ul">
<li>DRY
<ul class="org-ul">
<li>Software entities are more complex for their size than perhaps any
other human construct because no two parts are alike</li>
<li>If they are, we make the two similar parts into a subroutine</li>
</ul></li>
<li>States
<ul class="org-ul">
<li>Software systems have orders-of-magnitude more states than
computers do.</li>
</ul></li>
<li>Lead to many problems
<ol class="org-ol">
<li>Communication
<dl class="org-dl">
<dt>Function complexity</dt><dd>Hard to use</dd>
<dt>Structure complexity</dt><dd>Hard to extend</dd>
<dt>Structure complexity</dt><dd>Unvisualized states</dd>
</dl></li>
<li>Management</li>
</ol></li>
</ul></li>
<li>Conformity</li>
<li>Changeability
<ul class="org-ul">
<li>Software is constantly subject to pressures for change
<ol class="org-ol">
<li>The software in a system embodies its function, and the
<b>function is the part that most feels the pressures of
change</b></li>
<li>Software can be changed more easily (than buildings,
cars, computers, etc.)</li>
</ol></li>
<li>All successful software gets changes
<ol class="org-ol">
<li>People try it in new cases at the edge of, or beyond,
the original domain</li>
<li>Successful software also survives beyond the normal life
of the hardware for which it is first written</li>
</ol></li>
<li>Software is embedded in <b>a cultural matrix of applications,
users, laws, and hardware</b>. These all change continually</li>
</ul></li>
<li>Invisibility
<ul class="org-ul">
<li>Software constitute not one, but several, general directed
graphs, superimposed one upon another</li>
<li>This lack of visualization not only impedes the process of
design within one mind, it severely hinders communication
among minds</li>
</ul></li>
</ul></li>
<li>Accidents (not inherent)</li>
</ul></li>
</ol></li>
<li><p>
Past Breakthroughs Solved Accidental Difficulties
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Breakthroughs</th>
<th scope="col" class="org-left">Accidental Difficulties</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">High-level languages</td>
<td class="org-left">Machine</td>
</tr>

<tr>
<td class="org-left">Time-sharing</td>
<td class="org-left">Slow turn-around</td>
</tr>

<tr>
<td class="org-left">Unified programming environments</td>
<td class="org-left">Using programs together</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>High-level languages
<ul class="org-ul">
<li>It frees a program from much of its <b>accidental complexity of
the machine</b>.</li>
<li>The most a high-level language can do is to furnish all the
constructs the programmer imagines in the abstract program</li>
<li>At some point the elaboration of a high-level language becomes a
burden that <b>increases, not reduces, the intellectual task of
the user who rarely uses the esoteric constructs</b></li>
</ul></li>
<li>Time-sharing
<ul class="org-ul">
<li>Time-sharing <b>preserves immediacy</b>, and hence enables us to
maintain an overview of complexity</li>
<li>The slow turnaround of batch programming means that we
inevitably forget the minutiae, if not the very thrust, of what
we were thinking when we stopped programming and called for
compilation and execution.
<ul class="org-ul">
<li><b>Slow turn-around</b>, like machine-language complexities, is an
accidental difficulty of the software process.</li>
</ul></li>
<li>The principal effect is to shorten system response time.</li>
</ul></li>
<li>Unified programming environments
<ul class="org-ul">
<li>They attack the accidental difficulties of <b>using programs
together</b>, by providing integrated libraries, unified file
formats, and pipes and filters</li>
</ul></li>
</ul></li>
<li>Hopes for the Silver
<ol class="org-ol">
<li>Another high-level language? (Like Ada)
<ul class="org-ul">
<li>Ada, after all, is just another high-level language</li>
<li>The biggest payoff from high-level languages came from the first
transition</li>
</ul></li>
<li>OOP
<ul class="org-ul">
<li><i>Abstract data types</i> and <i>hierarchical types</i> each removes one
more accidental difficulty from the process</li>
<li>The complexity of the design itself is essential</li>
</ul></li>
<li>Artificial intelligence
<ul class="org-ul">
<li>强人工智能是 P 还是 NP - Google Search</li>
<li><b>The hard thing about building software is deciding what to say,
not saying it.</b></li>
<li>Expert systems (Linter?)
<ul class="org-ul">
<li>suggesting interface rules</li>
<li>advising on testing strategies</li>
<li>remembering bug-type frequencies</li>
<li>offering optimization hints</li>
<li>The most powerful contribution of expert systems will surely
be to put at the service of the inexperienced programmer the
experience and accumulated wisdom of the best program- mers.</li>
</ul></li>
<li>"Automatic" programming
<ul class="org-ul">
<li>the generation of a program for solving a problem from a
statement of the problem specifications.</li>
<li>in most cases it is the solution method, not the problem,
whose specification has to be given.</li>
<li>Problems can be solved by using generators
<ol class="org-ol">
<li>The problems are readily characterized by relatively few
parameters</li>
<li>There are many known methods of solution to provide a
library of alternatives</li>
<li>Extensive analysis has led to explicit rules for selecting
solution techniques, given problem parameters.</li>
</ol></li>
</ul></li>
</ul></li>
<li>Graphical programming
<ol class="org-ol">
<li>The flow chart is a very poor abstraction of software structure
<ul class="org-ul">
<li>it has proved to be essentially useless as a design tool</li>
<li>programmers draw flow charts after, not before, writing the
programs they describe.</li>
</ul></li>
<li>The screens of today are too small, in pixels, to show both the
scope and the resolution of any serious detailed software
diagram</li>
<li>Software is very difficult to visualize</li>
</ol></li>
<li>Program verification
<ul class="org-ul">
<li>Program verification does not promise, however, to save labor</li>
<li>Program verification does not mean error-proof programs.
<ul class="org-ul">
<li>Mathematical proofs also can be faulty.</li>
<li>So whereas verification might reduce the program-testing load,
it cannot eliminate it.</li>
</ul></li>
<li>Even perfect program verification <b>can only establish that a
program meets its specification</b>
<ul class="org-ul">
<li><b>The hardest part of the software task is arriving at a
complete and consistent specification</b>, and much of the
essence of building a program is in fact the debugging of the
specification.</li>
</ul></li>
</ul></li>
<li>Environments and tools
<ul class="org-ul">
<li>The most IDEs promise is freedom from syntactic errors and
simple semantic errors.</li>
<li>Perhaps the biggest gain yet to be realized in the programming
environment is <b>the use of integrated database systems to keep
track of the myriads of details</b> that must be recalled
accurately by the individual programmer and kept current in a
group of collaborators on a single system.</li>
</ul></li>
<li>Workstations
<ul class="org-ul">
<li>A factor of 10 in machine speed would surely leave think-time
the dominant activity in the programmer's day.</li>
</ul></li>
</ol></li>
<li>Promising Attacks on the Conceptual Essence
<ol class="org-ol">
<li>Buy vs. Build
<ul class="org-ul">
<li>The most radical possible solution for constructing software is
<b>not to construct it at all</b></li>
<li>The cost of software has always been <b>development cost</b>, not
<i>replication cost</i></li>
<li>The use of <i>n</i> copies of a software system effectively
multiplies the productivity of its developers by <i>n</i></li>
<li>The key issue is <b>applicability</b>
<ul class="org-ul">
<li>The big change has been in the hardware/software cost ratio.
<ul class="org-ul">
<li>The buyer of a $2-million machine in 1960 felt that he
could afford $250,000 more for a customized payroll program</li>
<li>Buyers of $50,000 office machines today cannot conceivably
afford customized payroll programs</li>
</ul></li>
</ul></li>
</ul></li>
<li>Requirements refinement and rapid prototyping
<ul class="org-ul">
<li><b>The hardest single part of building a software system is
deciding precisely what to build.</b></li>
<li><b>The clients do not know what they want.</b>
<ol class="org-ol">
<li>They usually do not know what questions must be answered,</li>
<li>They almost never have thought of the problem in the detail
that must be specified.</li>
</ol></li>
<li>It is really impossible for clients, even those working with
software engineers, to specify completely, precisely, and
correctly the exact requirements of a modern software product
before having built and tried some versions of the product they
are specifying.</li>
<li>The purpose of the prototype is to make real the conceptual
structure specified, so that the client can test it for
consistency and usability.</li>
</ul></li>
<li>Incremental development
<ul class="org-ul">
<li><b>Grow, not build, software</b></li>
<li>We freely use other elements of the metaphor, such as
<ol class="org-ol">
<li>specifications</li>
<li>assembly of components</li>
<li>scaffolding</li>
</ol></li>
<li>Top-down Design</li>
<li>Teams can <i>grow</i> much more complex entities in four months than
they can <i>build</i></li>
</ul></li>
<li>Great designers
<ul class="org-ul">
<li>We can get good designs by <i>following good practices</i> instead
of poor ones.</li>
<li><b>The very best designers produce structures that are faster,
smaller, simpler, cleaner, and produced with less effort.</b></li>
<li>Software systems that have excited passionate fans are those
that are the products of one or a few designing minds, great
designers.
<ul class="org-ul">
<li>Unix</li>
<li>Pascal</li>
<li>Smalltalk</li>
<li>FORTRAN</li>
<li>Modulo</li>
</ul></li>
<li>I think the most important single effort we can mount is to
<b>develop ways to grow great designers.</b></li>
<li>Each software organization must determine and proclaim that
great designers are as important to its success as great
managers are, and that they can be expected to be similarly
nurtured and rewarded.</li>
<li><b>How to grow great designers?</b>
<ul class="org-ul">
<li>Systematically identify top designers as early as
possible. The best are often not the most experienced.</li>
<li>Assign a career mentor to be responsible for the develop-
ment of the prospect, and keep a careful career file.</li>
<li>Devise and maintain a career development plan for each
prospect, including carefully selected apprenticeships with
top designers, episodes of advanced formal education, and
short courses, all interspersed with solo design and
technical leadership assignments.</li>
<li>Provide opportunities for growing designers to interact with
and stimulate each other.</li>
</ul></li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-orgbbfca23" class="outline-2">
<h2 id="orgbbfca23">Chapter 17. "No Silver Bullet" Refired</h2>
<div class="outline-text-2" id="text-orgbbfca23">
<ul class="org-ul">
<li>accidental complexity -&gt; incidental/appurtenant complexity
<dl class="org-dl">
<dt>essence</dt><dd>mental crafting of the conceptual construct</dd>
<dt>accident</dt><dd>its implementation process</dd>
</dl></li>
<li>If the accidental part of the work is less than 9/10 of the total,
shrinking it to zero will not give an order of magnitude
productivity improvement</li>
<li><p>
Complexity is by levels
</p>
<blockquote>
<p>
<b>Most of the complexities which are encountered in systems work are
symptoms of organizational malfunctions.</b>
</p>
</blockquote>
<p>
NSB advocates adding necessary complexity to a software system:
</p>
<ul class="org-ul">
<li>Hierarchically, by layered modules or objects</li>
<li>Incrementally, so that the system always works.</li>
</ul></li>
<li><p>
Jones's Point—Productivity Follows Quality
</p>
<blockquote>
<p>
Focus on <i>quality</i>, and <i>productivity</i> will follow.
</p>
</blockquote></li>
<li>Object-Oriented Programming -- Will a Brass Bullet Do?
<ul class="org-ul">
<li>Buildings with bigger pieces
<ul class="org-ul">
<li>Views of OOP
<ol class="org-ol">
<li>Modularity</li>
<li>Encapsulation</li>
<li>Inheritance</li>
<li>Strong abstract data-typing</li>
</ol></li>
<li>All these disciplines can be had without taking the whole
Smalltalk or C++ package</li>
</ul></li>
<li><b>Why has object-oriented technique grown slowly</b>
<ul class="org-ul">
<li><p>
The C++ Report
</p>
<blockquote>
<p>
The problem is that programmers in OO have been experimenting in
incestuous applications and aiming low in abstraction, instead
of high.
</p>

<p>
For example, they have been building classes such as <code>linked-list</code>
or <code>set</code> instead of classes such as <code>user-interface</code> or <code>radiation
      beam</code> or <code>finite-element model</code>.
</p>
</blockquote></li>
<li><p>
<b>OO is a type of design</b>
</p>
<blockquote>
<p>
OO has been tied to a variety of complex languages.
</p>

<p>
Instead of teaching people that OO is a type of design, and
giving them design principles, people have taught that OO is the
use of a particular tool.
</p>

<p>
<b>We can write good or bad programs with any tool.</b>
</p>

<p>
<b>Unless we teach people how to design, the languages matter very
little.</b> The result is that people do bad designs with these
languages and get very little value from them. If the value is
small, it won't catch on.
</p>
</blockquote></li>
</ul></li>
<li>Front-loaded costs, down-stream benefits
<ul class="org-ul">
<li>Switching to OO system costs more when started</li>
<li><p>
The big benefits pay off during successor building, extension,
and maintenance activities
</p>
<blockquote>
<p>
Object-oriented techniques will not make the first project
development any faster, or the next one. The fifth one in that
family will go blazingly fast.
</p>
</blockquote></li>
<li>Betting real up-front money for the sake of projected but iffy
benefits later is what investors do every day.</li>
<li>In many programming organizations, however, it requires real
managerial courage, a commodity much scarcer than technical
competence or administrative proficiency. (Tech Debt)</li>
</ul></li>
</ul></li>
<li><p>
What About Reuse?
</p>
<blockquote>
<p>
We conjecture that barriers to reuse are not on the producer side,
but on the consumer side. If a software engineer, a potential
consumer of standardized software components, perceives it to be
more expensive to find a component that meets his need, and so
verify, than to write one anew, a new, duplicative component will be
written. Notice we said perceives above. It doesn't matter what the
true cost of reconstruction is.
</p>
</blockquote>
<ul class="org-ul">
<li>Learning Large Vocabularies — A Predictable but Unpredicted
Problem for Software Reuse
<ul class="org-ul">
<li>The higher the level at which one thinks, the more numerous the
primitive thought-elements one has to deal with.</li>
<li>Whether we do this (reusing) by object class libraries or
procedure libraries, we must face the fact that <b>we are
radically raising the sizes of our programming vocabularies</b>.</li>
<li><b>How people acquire language</b>
<ul class="org-ul">
<li>People learn in sentence contexts, so we need to publish many
examples of composed products, not just libraries of parts.</li>
<li>People do not memorize anything but spelling. They learn
syntax and semantics incrementally, in context, by use.</li>
<li>People group word composition rules by syntactic classes, not
by compatible subsets of objects.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd361e61" class="outline-2">
<h2 id="orgd361e61">Chapter 18. Propositions of The Mythical Man-Month: True or False?</h2>
</div>
<div id="outline-container-org53eb28e" class="outline-2">
<h2 id="org53eb28e">Chapter 19. The Mythical Man-Month: after 20 years</h2>
<div class="outline-text-2" id="text-org53eb28e">
<ul class="org-ul">
<li>Why Is There a Twentieth Anniversary Edition?
<ol class="org-ol">
<li>The software development discipline has not advanced normally or
properly.
<ul class="org-ul">
<li>Chapter 16. No Silver Bullet - Essence and Accident in Software Engineering</li>
</ul></li>
<li>The Mythical Man-Month is only incidentally about software but
primarily about <b>how people in teams make things</b>.
<ul class="org-ul">
<li><b>Managing a software project is more like other management than
most programmers initially believe</b></li>
</ul></li>
</ol></li>
<li>What was right when written, and still is
<ul class="org-ul">
<li>The Central Argument: Conceptual Integrity and the Architect
<ul class="org-ul">
<li>Conceptual integrity</li>
<li>The architect</li>
<li>Separation of architecture from implementation and realization</li>
<li>Recursion of architects</li>
</ul></li>
<li>The Second-System Effect: Featuritis and Frequency-Guessing
<ul class="org-ul">
<li>Featuritis
<ul class="org-ul">
<li>The besetting temptation for the architect of a general
purpose tool is to <b>overload the product with features of
marginal utility</b>, at the expense of performance and even of
ease of use.</li>
<li>Frequently, the original system architect has gone on to
greater glories, and the architecture is in the hands of
people with less experience at representing the user's overall
interest in balance.</li>
</ul></li>
<li>Defining the user set
<ul class="org-ul">
<li>Each member of the design team will surely have an implicit
mental image of the users, and <b>each designer's image will be
different</b>.</li>
<li><b>Writing down the attributes of the expected user set</b>,
including:
<ol class="org-ol">
<li>Who they are</li>
<li>What they need</li>
<li>What they think they need</li>
<li>What they want</li>
</ol></li>
</ul></li>
<li>Frequencies
<ul class="org-ul">
<li>For any software product, any of the attributes of the user
set is in fact a distribution, with many possible values, each
<b>with its own frequency</b>.</li>
<li><b>Write down explicit guesses for the attributes of the user
set</b>. It is far better to be explicit and wrong than to be
vague.
<ol class="org-ol">
<li>The process of carefully guessing the frequencies will
cause the architect to think very carefully about the
expected user set.</li>
<li>Writing the frequencies down will subject them to debate,
which will illuminate all the participants and bring to the
surface the differences in the user images that the several
designers carry</li>
<li>Enumerating the frequencies explicitly helps everyone
recognize which decisions depend upon which user set
properties</li>
</ol></li>
</ul></li>
<li>2 Second-System in this book
<ul class="org-ul">
<li>The "second" system described in Chapter 5 is the second
system fielded, <i>the follow-on system that invites added
function and frills</i></li>
<li>The "second" system in Chapter 11 is <i>the second try at
building what should be the first system to be fielded</i>. It is
built under all the schedule, talent, and ignorance
constraints that characterize new projects—the constraints
that exert a slimness discipline.</li>
</ul></li>
</ul></li>
</ul></li>
<li>The Triumph of the WIMP Interface
<ul class="org-ul">
<li>WIMP
<ul class="org-ul">
<li>Windows</li>
<li>Icons</li>
<li>Menus</li>
<li>Pointing interface</li>
</ul></li>
<li>Conceptual integrity via a metaphor
<ul class="org-ul">
<li>The WIMP is a superb example of a user interface that has
conceptual integrity, achieved by the adoption of a familiar
mental model</li>
<li>The reliable interpretation of free-form generated English
commands is beyond the present state of the art
<ul class="org-ul">
<li>They wisely picked up from the usual desktop its one
example of command selection—the printed buck slip, on
which <b>the user selects from among a constrained menu of
commands</b> whose semantics are standardized.</li>
</ul></li>
</ul></li>
<li>Command utterances and the two-cursor problem
<ul class="org-ul">
<li>Two-cursor problem:
<b>One cursor is having to do the work of two</b>
<ol class="org-ol">
<li>pick an object in the desktop part of the window;</li>
<li>pick a verb in the menu portion</li>
</ol></li>
<li>A brilliant solution:
<b>Use one hand on the keyboard to specify verbs and the other
hand on a mouse to pick nouns</b></li>
<li>User power versus ease of use
<ul class="org-ul">
<li>One of the hardest issues facing software architects is
exactly <b>how to balance user power versus ease of use</b>.</li>
<li>The high-frequency menu verbs each have single-key +
command-key equivalents, mostly chosen so that they can
easily be struck as a single chord with the left hand.</li>
</ul></li>
<li>Incremental transition from novice to power user</li>
</ul></li>
<li>The fate of WIMP: Obsolescence
<ul class="org-ul">
<li>Pointing will still be the way to express nouns as we
command our machines;</li>
<li>Speech is surely the right way to express the verbs.</li>
</ul></li>
</ul></li>
<li>Don't Build One to Throw Away - The Waterfall Model Is Wrong!
<ol class="org-ol">
<li><b>it assumes a project goes through the process once</b>
<ul class="org-ul">
<li>The waterfall model assumes the mistakes will all be in the
realization,</li>
<li>Thus that their repair can be smoothly interspersed with
component and system testing.</li>
<li>One might discard and redesign the first system <b>piece by piece</b>,
rather than in one lump</li>
<li>The waterfall model puts system test, and therefore by implication
user testing, at the end of the construction process.</li>
</ul></li>
<li><b>It assumes one builds a whole system at once</b>
<ul class="org-ul">
<li>combining the pieces for an end-to-end system test after all
of the implementation design, most of the coding, and much of
the component testing has been done.</li>
<li><p>
<b>There has to be upstream movement</b>
</p>
<blockquote>
<p>
Designing the implementation will show that some
architectural features cripple performance; so the
architecture has to be reworked.
</p>
</blockquote></li>
</ul></li>
</ol></li>
<li>An Incremental-Build Model Is Better - Progressive Refinement
<ol class="org-ol">
<li><p>
Building an end-to-end skeleton system
</p>
<pre class="example">
Harlan Mills, working in a real-time system environment, early
advocated that we should build the basic polling loop of a real- time
system, with subroutine calls (stubs) for all the functions, but only
null subroutines. Compile it; test it. It goes round and round, doing
literally nothing, but doing it correctly.
</pre>
<ul class="org-ul">
<li><b>At every stage we have a running system</b></li>
<li>Since we have a working system at all times
<ol class="org-ol">
<li>we can begin user testing very early</li>
<li>we can adopt a build-to-budget strategy that protects
absolutely against schedule or budget overruns (at the cost
of possible functional shortfall).</li>
</ol></li>
</ul></li>
<li>Parnas Families
<ul class="org-ul">
<li><b>Designing a software product as a <i>family</i> of related products</b></li>
<li>To define their (both lateral extensions and succeeding
versions) function or platform differences so as to construct a
family tree of related products</li>
<li>Put near its root those design decisions that are less likely
to change.</li>
</ul></li>
<li><p>
Microsoft's "Build Every Night" Approach (CI/CD)
</p>
<blockquote>
<p>
After we first ship, we will be shipping later versions that add
more function to an existing, running product. Why should the
initial building process be different? Beginning at the time of
our first milestone [where the march to first ship has three
intermediate milestones] we rebuild the developing system every
night [and run the test cases]. The build cycle becomes the
heartbeat of the project. Every day one or more of the
programmer-tester teams check in modules with new
functions. After every build, we have a running system. If the
build breaks, we stop the whole process until the trouble is
found and fixed. At all times everybody on the team knows the
status.
</p>

<p>
It is really hard. You have to devote lots of resources, but it
is a disciplined process, a tracked and known process. It gives
the team credibility to itself. Your credibility determines your
morale, your emotional state.
</p>
</blockquote></li>
<li>Incremental-Build and Rapid Prototyping</li>
</ol></li>
<li>Parnas Was Right, and I Was Wrong about Information Hiding
<ul class="org-ul">
<li>Programmers are most effective if shielded from, not exposed to,
the innards of modules not their own</li>
<li><b>Information hiding is the only way of raising the level of
software design.</b></li>
<li>If we can limit design and building so that we only do the putting
together and parameterization of such chunks from pre-built
collections, we have radically raised the conceptual level, and
eliminated the vast amounts of work and the copious opportunities
for error that dwell at the individual statement level.</li>
<li>3 steps of information-hiding
<ol class="org-ol">
<li>Define a module as a software entity with its own data model
and its own set of operations</li>
<li>The upgrading of the module into an abstract data type
(<b>interface!</b>)
<ul class="org-ul">
<li>The abstract data type provides a uniform way of thinking about
and specifying <b>module interfaces</b>, and an access discipline
that is easy to enforce.</li>
</ul></li>
<li>OOP
<ul class="org-ul">
<li>inheritance</li>
</ul></li>
</ol></li>
<li>Modules are not just programs, but instead are <b>program products</b></li>
<li>Some people are vainly hoping for significant module reuse without
paying the initial cost of building product-quality
modules—generalized, robust, tested, and documented.</li>
</ul></li>
<li>How Mythical Is the Man-Month? Boehm's Model and Data
<ul class="org-ul">
<li>Adding more people to a late project always makes it more costly,
but it does not always cause it to be completed later</li>
<li>New people added late in a development project must be team
players willing to pitch in and work within the process, and not
attempt to alter or improve the process itself!</li>
<li><b>The work must be repartitioned</b>, a process I have often found to
be non trivial.</li>
</ul></li>
<li><b>People Are Everything</b> (Well, Almost Everything)
<ul class="org-ul">
<li><b>The quality of the people on a project</b>, and <b>their organization
and management</b>, are much more important factors in success than
are the tools they use or the technical approaches they take.</li>
<li>Peopleware
<ul class="org-ul">
<li><i>Peopleware: Productive Projects and Teams</i>
<ul class="org-ul">
<li><b>The manager's function is not to make people work, it is to
make it possible for people to work.</b></li>
</ul></li>
</ul></li>
</ul></li>
<li>The Power of Giving Up Power
<ul class="org-ul">
<li><b>Creativity comes from individuals and not from structures or
processes</b></li>
<li>The Principle of Subsidiary Function</li>
</ul></li>
<li>The State and Future of Software Engineering
<ul class="org-ul">
<li>Chemical engineering
<ol class="org-ol">
<li>rules of thumb</li>
<li>empirical nomograms</li>
<li>formulas for designing particular components</li>
<li>mathematical models for heat transport</li>
<li>mass transport</li>
<li>momentum transport in single vessels</li>
</ol></li>
<li>Software engineering is merely immature as chemical engineering
was in 1945</li>
<li>This complex craft will demand our continual development of the
discipline, our learning to compose in larger units, our best use
of new tools, our best adaptation of proven engineering management
methods, liberal application of common sense, and a God-given
humility to recognize our fallibility and limitations.</li>
</ul></li>
</ul>
</div>
</div>

    </div>
</section>


    <div class="post-meta">
        <span title="post date" class="post-info">2018-03-24</span>
        <span title="last modification date" class="post-info">2018-03-24</span>
        <span title="tags" class="post-info"><a href="/tags/clipping/">Clipping</a>, <a href="/tags/management/">Management</a></span>
        <span title="author" class="post-info">Yiming Chen</span>
    </div>
  <section>
    <h1>Comments</h1>
    <script src="https://utteranc.es/client.js"
      repo="dsdshcym/dsdshcym.github.io"
      issue-term="title"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </section>
<footer class="footer">
  <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> (<a href="http://orgmode.org">Org mode</a>)</p>
  <p>
    Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:dsdshcym &lt;at&gt; gmail &lt;dot&gt; com">Yiming Chen</a>
    &nbsp;&nbsp;-&nbsp;&nbsp;
    Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
    <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
  </p>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-152951733-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-152951733-1');
</script>

  </body>
</html>
