<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>Clippings from A Philosophy of Software Design - dsdshome</title>
  <meta charset="utf-8" />
  <meta name="author" content="Yiming Chen" />
  <meta name="keywords" content="Clipping, Notes, Philosophy, Software, Design" />

  <link rel="alternate" title="RSS Feed" href="/rss.xml" type="application/rss+xml">
  <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  <link rel="stylesheet" href="/media/css/posts.css" type="text/css">
  <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
  <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>

  <script src="/media/js/main.js"></script>
</head>

  <body class="container">
<header id="header">
    <body>
        <nav class="navbar navbar-default navbar-fixed-top" style="opacity: .9" role="navigation">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">dsdshome</a>
                </div>
                <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="/blog/">Blog</a></li>
                        <li><a href="/clipping/">Clipping</a></li>
                        <li><a href="/tags/">Tags</a></li>
                        <li><a href="/about/">About</a></li>
                        <li><a href="https://github.com/dsdshcym">GitHub</a></li>
                        <li><a href="/rss.xml">RSS</a></li>
                        <li><a href="https://webring.xxiivv.com/#random">Webring</a></li>
                    </ul>
                </div>
            </div>
        </nav>
    </body>
</header>

<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>Clippings from A Philosophy of Software Design</h1>
            <div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1d9ed2e">Preface</a></li>
<li><a href="#orgfc5f862">1 Introduction (It's All About Complexity)</a>
<ul>
<li><a href="#org69d85fb">1.1 How to use this book</a></li>
</ul>
</li>
<li><a href="#orgd871c48">2 The Nature of Complexity</a>
<ul>
<li><a href="#orgb2881e5">2.1 Complexity defined</a></li>
<li><a href="#orgf5ef24b">2.2 Symptoms of complexity</a></li>
<li><a href="#org13fa42c">2.3 Causes of complexity</a></li>
<li><a href="#org7cd10d3">2.4 Complexity is incremental</a></li>
<li><a href="#org8ce24f8">2.5 Conclusion</a></li>
</ul>
</li>
<li><a href="#orgba1d937">3 Working Code Isn't Enough</a>
<ul>
<li><a href="#orge37de46">3.1 Tactical programming</a></li>
<li><a href="#org3ed0a98">3.2 Strategic programming</a></li>
<li><a href="#orgac737fc">3.3 How much to invest?</a></li>
<li><a href="#org63fc05b">3.4 Startups and investment</a></li>
<li><a href="#org9f2b865">3.5 Conclusion</a></li>
</ul>
</li>
<li><a href="#org7cd2cad">4 Modules Should Be Deep</a>
<ul>
<li><a href="#org928ffe8">4.1 Modular design</a></li>
<li><a href="#org77b5b79">4.2 What’s in an interface?</a></li>
<li><a href="#org0ce7d2d">4.3 Abstractions</a></li>
<li><a href="#org5278897">4.4 Deep modules</a></li>
<li><a href="#org2d226c8">4.5 Shallow modules&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></a></li>
<li><a href="#org9b578ca">4.6 Classitis</a></li>
<li><a href="#org1b9174a">4.7 Examples: Java and Unix I/O</a></li>
<li><a href="#org1269e7b">4.8 Conclusion</a></li>
</ul>
</li>
<li><a href="#org9aa2ef0">5 Information Hiding (and Leakage)</a>
<ul>
<li><a href="#org669fa78">5.1 Information hiding</a></li>
<li><a href="#org4186877">5.2 Information leakage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></a></li>
<li><a href="#orgaec02da">5.3 Temporal decomposition&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></a></li>
<li><a href="#org91eb2cb">5.4 Example: HTTP server</a>
<ul>
<li><a href="#org0042bfa">5.5 Example: too many classes</a></li>
<li><a href="#org0b44f4f">5.6 Example: HTTP parameter handling</a></li>
<li><a href="#orgbe2ddcd">5.7 Example: defaults in HTTP responses</a></li>
</ul>
</li>
<li><a href="#orge9e3a2e">5.8 Information hiding within a class</a></li>
<li><a href="#orge64d313">5.9 Taking it too far</a></li>
<li><a href="#org1e87f39">5.10 Conclusion</a></li>
</ul>
</li>
<li><a href="#orgf31e735">6 General-Purpose Modules are Deeper</a>
<ul>
<li><a href="#org2cfee25">6.1 Make classes somewhat general-purpose</a></li>
<li><a href="#orgdfcb514">6.2 Example: storing text for an editor</a>
<ul>
<li><a href="#orgc82e266">6.3 A more general-purpose API</a></li>
<li><a href="#org5b5c2a3">6.4 Generality leads to better information hiding</a></li>
</ul>
</li>
<li><a href="#org96c0d02">6.5 Questions to ask yourself</a></li>
<li><a href="#org2fe3342">6.6 Conclusion</a></li>
</ul>
</li>
<li><a href="#org7e89f9f">7 Different Layer, Different Abstraction</a>
<ul>
<li><a href="#org11bcf10">7.1 Pass-through methods</a></li>
<li><a href="#orge9bfefd">7.2 When is interface duplication OK?</a></li>
<li><a href="#orge2d438d">7.3 Decorators</a></li>
<li><a href="#org2bbecb8">7.4 Interface versus implementation</a></li>
<li><a href="#orgb72eecc">7.5 Pass-through variables</a></li>
<li><a href="#org99f0566">7.6 Conclusion</a></li>
</ul>
</li>
<li><a href="#org44b1b0c">8 Pull Complexity Downwards</a>
<ul>
<li><a href="#org48567f6">8.1 Example: editor text class</a></li>
<li><a href="#org7ed6a09">8.2 Example: configuration parameters</a></li>
<li><a href="#orga01c139">8.3 Taking it too far</a></li>
<li><a href="#org4bb147f">8.4 Conclusion</a></li>
</ul>
</li>
<li><a href="#orgbfea5cc">9 Better Together Or Better Apart?</a>
<ul>
<li><a href="#org8322c61">9.1 Bring together if information is shared</a></li>
<li><a href="#orgc9fc10c">9.2 Bring together if it will simplify the interface</a></li>
<li><a href="#org8d45eb1">9.3 Bring together to eliminate duplication</a></li>
<li><a href="#orge385e94">9.4 Separate general-purpose and special-purpose code</a>
<ul>
<li><a href="#orge363abb">Red Flag: Repetition&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></a></li>
</ul>
</li>
<li><a href="#org0b59f61">9.5 Example: insertion cursor and selection</a>
<ul>
<li><a href="#orgbab8203">Red Flag: Special-General Mixture&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></a></li>
</ul>
</li>
<li><a href="#org1f1af79">9.6 Example: separate class for logging</a></li>
<li><a href="#org6669cef">9.7 Example: editor undo mechanism</a></li>
<li><a href="#orgfb912f7">9.8 Splitting and joining methods</a>
<ul>
<li><a href="#orgba28e4f">Red Flag: Conjoined Methods</a></li>
</ul>
</li>
<li><a href="#orgade6301">9.9 Conclusion</a></li>
</ul>
</li>
<li><a href="#orgc62fe20">10 Define Errors Out Of Existence</a>
<ul>
<li><a href="#org530df5b">10.1 Why exceptions add complexity</a></li>
<li><a href="#org25e7ea2">10.2 Too many exceptions</a></li>
<li><a href="#orgd2cab10">10.3 Define errors out of existence</a>
<ul>
<li><a href="#org5ad55c4">10.4 Example: file deletion in Windows</a></li>
<li><a href="#orga42e283">10.5 Example: Java substring method</a></li>
</ul>
</li>
<li><a href="#orgbdee626">10.6 Mask exceptions</a></li>
<li><a href="#orge29d90a">10.7 Exception aggregation</a></li>
<li><a href="#org4a79e5b">10.8 Just crash?</a></li>
<li><a href="#org7d53fec">10.9 Design special cases out of existence</a></li>
<li><a href="#org4835b88">10.10 Taking it too far</a></li>
<li><a href="#org3173f89">10.11 Conclusion</a></li>
</ul>
</li>
<li><a href="#orgab74cb5">11 Design it Twice</a></li>
<li><a href="#org4e1aa1d">12 Why Write Comments? The Four Excuses</a>
<ul>
<li><a href="#org0b6bda1">12.1 Good code is self-documenting</a></li>
<li><a href="#orgcbabf50">12.2 I don't have time to write comments</a></li>
<li><a href="#org96da643">12.3 Comments get out of date and become misleading</a></li>
<li><a href="#org2cbed86">12.4 All the comments I have seen are worthless</a></li>
<li><a href="#org5232fcc">12.5 Benefits of well-written comments</a></li>
</ul>
</li>
<li><a href="#org94aa247">13 Comments Should Describe Things that Aren't Obvious from the Code</a>
<ul>
<li><a href="#orgb250138">13.1 Pick conventions</a></li>
<li><a href="#orgae20215">13.2 Don't repeat the code</a>
<ul>
<li><a href="#org63a9ee6">Red Flag: Comment Repeats Code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></a></li>
</ul>
</li>
<li><a href="#orgc03dff3">13.3 Lower-level comments add precision</a></li>
<li><a href="#org3152093">13.4 Higher-level comments enhance intuition</a></li>
<li><a href="#org7b2e259">13.5 Interface documentation</a>
<ul>
<li><a href="#orgbb81e6f">Red Flag: Implementation Documentation Contaminates Interface&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></a></li>
</ul>
</li>
<li><a href="#orga03be36">13.6 Implementation comments: what and why, not how</a></li>
<li><a href="#orgf322738">13.7 Cross-module design decisions</a></li>
<li><a href="#org38979cd">13.8 Conclusion</a></li>
<li><a href="#org5a334aa">13.9 Answers to questions from Section 13.5</a></li>
</ul>
</li>
<li><a href="#org04d11c7">14 Choosing Names</a>
<ul>
<li><a href="#orgf9a274f">14.1 Example: bad names cause bugs</a></li>
<li><a href="#org16be545">14.2 Create an image</a></li>
<li><a href="#org3518aa1">14.3 Names should be precise</a>
<ul>
<li><a href="#org7380887">Red Flag: Vague Name&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></a></li>
<li><a href="#org447ca83">Red Flag: Hard to Pick Name&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></a></li>
</ul>
</li>
<li><a href="#org5e16465">14.4 Use names consistently</a></li>
<li><a href="#org58f7dda">14.5 A different opinion: Go style guide</a></li>
<li><a href="#org05ec677">14.6 Conclusion</a></li>
</ul>
</li>
<li><a href="#orgf14bd93">15 Write The Comments First</a>
<ul>
<li><a href="#org7680244">15.1 Delayed comments are bad comments</a></li>
<li><a href="#org5279497">15.2 Write the comments first</a></li>
<li><a href="#org5ce02e8">15.3 Comments are a design tool</a>
<ul>
<li><a href="#org0acf077">Red Flag: Hard to Describe</a></li>
</ul>
</li>
<li><a href="#orgf656501">15.4 Early comments are fun comments</a></li>
<li><a href="#orgac5d423">15.5 Are early comments expensive?</a></li>
<li><a href="#orga8441db">15.6 Conclusion</a></li>
</ul>
</li>
<li><a href="#org8e152da">16 Modifying Existing Code</a>
<ul>
<li><a href="#org6ec9eb0">16.1 Stay strategic</a></li>
<li><a href="#orgb0f30a2">16.2 Maintaining comments: keep the comments near the code</a></li>
<li><a href="#orgd17fcab">16.3 Comments belong in the code, not the commit log</a></li>
<li><a href="#org264e2c4">16.4 Maintaining comments: avoid duplication</a></li>
<li><a href="#orge1c0cea">16.5 Maintaining comments: check the diffs</a></li>
<li><a href="#org415840b">16.6 Higher-level comments are easier to maintain</a></li>
</ul>
</li>
<li><a href="#org5e8490e">17 Consistency</a>
<ul>
<li><a href="#org0b84cd2">17.1 Examples of consistency</a></li>
<li><a href="#orgf45f1c7">17.2 Ensuring consistency</a></li>
<li><a href="#org136a4aa">17.3 Taking it too far</a></li>
<li><a href="#org213e4b8">17.4 Conclusion</a></li>
</ul>
</li>
<li><a href="#org12d6eb2">18 Code Should be Obvious</a>
<ul>
<li><a href="#org4d8aa61">18.1 Things that make code more obvious</a></li>
<li><a href="#org2550bb1">18.2 Things that make code less obvious</a>
<ul>
<li><a href="#org643f8a5">Red Flag: Nonobvious Code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></a></li>
</ul>
</li>
<li><a href="#org0e0ab63">18.3 Conclusion</a></li>
</ul>
</li>
<li><a href="#org6d6d1a0">19 Software Trends</a>
<ul>
<li><a href="#orge8ac35e">19.1 Object-oriented programming and inheritance</a></li>
<li><a href="#org622c86f">19.2 Agile development</a></li>
<li><a href="#org579cdc2">19.3 Unit tests</a></li>
<li><a href="#orge5bf41e">19.4 Test-driven development</a></li>
<li><a href="#org6e66413">19.5 Design patterns</a></li>
<li><a href="#org47e0b51">19.6 Getters and setters</a></li>
<li><a href="#org6c143d6">19.7 Conclusion</a></li>
</ul>
</li>
<li><a href="#orgb73c199">20 Designing for Performance</a>
<ul>
<li><a href="#org7ec9efc">20.1 How to think about performance</a></li>
<li><a href="#orgcb43dd6">20.2 Measure before modifying</a></li>
<li><a href="#org9ea0cfb">20.3 Design around the critical path</a></li>
<li><a href="#org48e482f">20.4 An example: RAMCloud Buffers</a></li>
<li><a href="#org2fdbe76">20.5 Conclusion</a></li>
</ul>
</li>
<li><a href="#org7f6b8e6">21 Conclusion</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1d9ed2e" class="outline-2">
<h2 id="org1d9ed2e">Preface</h2>
<div class="outline-text-2" id="text-org1d9ed2e">
<ul class="org-ul">
<li><a href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf">On the Criteria To Be Used in Decomposing Systems into Modules</a></li>
<li>The most fundamental problem in computer science is <i>problem
decomposition</i>
<ul class="org-ul">
<li>The central design task we face every day</li>
<li>We teach <code>for</code> loops and object-oriented programming, but not
software design.</li>
</ul></li>
<li>There is a huge variation in quality and productivity among
programmers
<ul class="org-ul">
<li>We have made little attempt to understand what makes the best
programmers so much better or to teach those skills in our
classes.</li>
<li><b>Outstanding performance in many fields is related more to
high-quality practice than innate ability</b>
<ul class="org-ul">
<li>Students learn best by writing code, making mistakes, and then
seeing how their mistakes and the subsequent fixes relate to the
principles.</li>
</ul></li>
</ul></li>
<li>The overall goal is to <b>reduce complexity</b>; this is more important
than any particular principle or idea you read here</li>
</ul>
</div>
</div>
<div id="outline-container-orgfc5f862" class="outline-2">
<h2 id="orgfc5f862">1 Introduction (It's All About Complexity)</h2>
<div class="outline-text-2" id="text-orgfc5f862">
<ul class="org-ul">
<li>Why?
<ul class="org-ul">
<li>All programming requires is a creative mind and the ability to
organize your thoughts.</li>
<li>This means that the greatest limitation in writing software is our
ability to understand the systems we are creating.</li>
<li>The larger the program, and the more people that work on it, the
more difficult it is to manage complexity.</li>
</ul></li>
<li>How?
<ul class="org-ul">
<li>Good development tools can help us deal with complexity. But there
is a limit to what we can do with tools alone.</li>
<li>simpler designs allow us to build larger and more powerful systems
before complexity becomes overwhelming.</li>
<li>There are two general approaches to fighting complexity,
<ol class="org-ol">
<li>eliminate complexity by making code simpler and more obvious.</li>
<li>encapsulate it, so that programmers can work on a system without
being exposed to all of its complexity at once. (modular design)</li>
</ol></li>
<li>Because software is so malleable, software design is a continuous
process that spans the entire lifecycle of a software system;</li>
</ul></li>
<li>Incremental Development over Waterfall
<ul class="org-ul">
<li>It isn't possible to visualize the design for a large software
system well enough to understand all of its implications before
building anything.</li>
<li>The incremental approach works for software because software is
malleable enough to allow significant design changes partway through
implementation.</li>
<li>Incremental development means that
<ol class="org-ol">
<li>software design is never done.</li>
<li>continuous redesign.</li>
</ol></li>
</ul></li>
<li>This book is about how to use complexity to guide the design of
software throughout its lifetime.</li>
<li>This book has two overall goals.
<ol class="org-ol">
<li>describe the nature of software complexity:
<ul class="org-ul">
<li>what does "complexity" mean</li>
<li>why does it matter</li>
<li>how can you recognize when a program has unnecessary
complexity?</li>
</ul></li>
<li>present techniques you can use during the software development
process to minimize complexity.
<ul class="org-ul">
<li>there isn't a simple recipe that will guarantee great software
designs.</li>
<li>a collection of higher-level concepts that border on the
philosophical,</li>
<li>These concepts may not immediately identify the best design,
but you can use them to compare design alternatives and guide
your exploration of the design space.</li>
</ul></li>
</ol></li>
</ul>
</div>
<div id="outline-container-org69d85fb" class="outline-3">
<h3 id="org69d85fb">1.1 How to use this book</h3>
<div class="outline-text-3" id="text-org69d85fb">
<ul class="org-ul">
<li>The best way: <b>in conjunction with code reviews</b>
<ul class="org-ul">
<li>When you read other people’s code, think about whether it conforms
to the concepts discussed here and how that relates to the
complexity of the code.</li>
<li>It's easier to see design problems in someone else’s code than
your own</li>
<li>You can use the red flags described here to identify problems and
suggest improvements.</li>
<li>Reviewing code will also expose you to new design approaches and
programming techniques.</li>
</ul></li>
<li>One of the best ways to improve your design skills is to <b>learn to
recognize <i>red flags</i> (code smells):</b> signs that a piece of code is
probably more complicated than it needs to be.</li>
<li>Don't give up easily: the more alternatives you try before fixing
the problem, the more you will learn.</li>
<li>When applying the ideas from this book, it’s important to use
moderation and discretion
<ul class="org-ul">
<li>Every rule has its exceptions</li>
<li>Every principle has its limits</li>
<li><b>Beautiful designs reflect a balance between competing ideas and
approaches</b></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd871c48" class="outline-2">
<h2 id="orgd871c48">2 The Nature of Complexity</h2>
<div class="outline-text-2" id="text-orgd871c48">
<ul class="org-ul">
<li>This chapter:
<ol class="org-ol">
<li>understand the enemy at a high level
<ol class="org-ol">
<li>What is "complexity"?</li>
<li>Unnecessarily complex?</li>
<li>What causes systems to become complex?</li>
</ol></li>
<li>Lays out some basic assumptions that provide a foundation for the
rest of the book</li>
</ol></li>
<li><b>The ability to recognize complexity</b> is a crucial design skill.
<ol class="org-ol">
<li>allows you to identify problems before you invest a lot of effort
in them</li>
<li>allows you to make good choices among alternatives
<ul class="org-ul">
<li>It's easier to tell whether a design is simple than it is to
create a simple design</li>
<li>Once you can recognize that a system is too complicated, you
can use that ability to guide your design philosophy towards
simplicity. -&gt; Try a different approach and see if that is
simpler.</li>
<li>Over time, you will notice that certain techniques tend to
result in simpler designs, while others correlate with
complexity. -&gt; This allows you to produce simpler designs more
quickly.</li>
</ul></li>
</ol></li>
</ul>
</div>
<div id="outline-container-orgb2881e5" class="outline-3">
<h3 id="orgb2881e5">2.1 Complexity defined</h3>
<div class="outline-text-3" id="text-orgb2881e5">
<ul class="org-ul">
<li>Complexity is anything related to the structure of a software system
that <b>makes it hard to understand and modify the system</b></li>
<li>Complexity can take many forms</li>
<li>Complexity is determined by the activities that are most common (the
part that are touched often)
\(C=\sum_p{c_p t_p}\)
<ul class="org-ul">
<li>The overall complexity of a system (C) is determined by the
complexity of each part p (c_p) weighted by the fraction of time
developers spend working on that part (t_p).</li>
<li>Isolating complexity in a place where it will never be seen is
almost as good as eliminating the complexity entirely.</li>
</ul></li>
<li>Complexity is more apparent to readers than writers.
<ul class="org-ul">
<li>Your job as a developer is not just to create code that you can
work with easily, but to <b>create code that others can also work
with easily.</b></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf5ef24b" class="outline-3">
<h3 id="orgf5ef24b">2.2 Symptoms of complexity</h3>
<div class="outline-text-3" id="text-orgf5ef24b">
<ul class="org-ul">
<li><a id="orgeae23c4"></a>
<ol class="org-ol">
<li>Change amplification
<ul class="org-ul">
<li>A seemingly simple change requires code modifications in many
different places.</li>
<li>One of the goals of good design is to <b>reduce the amount of
code that is affected by each design decision</b>, so design
changes don’t require very many code modifications.</li>
</ul></li>
<li>Cognitive load
<ul class="org-ul">
<li>Refers to how much a developer needs to know in order to
complete a task.</li>
<li>Why a higher cognitive load is bad: <i>there is a greater risk of
bugs because they have missed something important.</i></li>
<li>Cognitive load arises in many ways, such as
<ul class="org-ul">
<li>APIs with many methods,</li>
<li>global variables,</li>
<li>inconsistencies,</li>
<li>dependencies between modules.</li>
</ul></li>
<li>System designers sometimes assume that complexity can be
measured by lines of code
<ul class="org-ul">
<li>There are costs (of fewer LoCs) associated with cognitive
load</li>
<li><b>Sometimes an approach that requires more lines of code is
actually simpler, because it reduces cognitive load.</b></li>
</ul></li>
</ul></li>
<li>Unknown unknowns
<ul class="org-ul">
<li>It is not obvious
<ol class="org-ol">
<li>which pieces of code must be modified to complete a task,</li>
<li>what information a developer must have to carry out the task
successfully</li>
</ol></li>
<li>The worst: <b>it is unclear what to do or whether a proposed
solution will even work</b>
<ol class="org-ol">
<li>There is something you need to know</li>
<li>But there is no way for you to find out what it is, or even
whether there is an issue</li>
<li>You won't find out about it until bugs appear after you make
a change</li>
<li>The only way to be certain is to read every line of code in
the system, which is impossible for systems of any size</li>
</ol></li>
</ul></li>
</ol></li>
<li>One of the most important goals of good design is for a system to be
<i>obvious</i>
<ul class="org-ul">
<li>This is the opposite of high cognitive load and unknown unknowns</li>
<li>In an obvious system, a developer can
<ol class="org-ol">
<li>quickly understand how the existing code works and what is
required to make a change</li>
<li>make a quick guess about what to do, without thinking very
hard, and yet be confident that the guess is correct</li>
</ol></li>
<li><i>18 Code Should be Obvious</i></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org13fa42c" class="outline-3">
<h3 id="org13fa42c">2.3 Causes of complexity</h3>
<div class="outline-text-3" id="text-org13fa42c">
<ul class="org-ul">
<li>Complexity is caused by two things
<ol class="org-ol">
<li><p>
<a id="org6333295"></a>
</p>
<blockquote>
<p>
A dependency exists when a given piece of code cannot be
understood and modified in isolation
</p>
</blockquote>
<ul class="org-ul">
<li>Dependencies are a fundamental part of software and can’t be
completely eliminated.</li>
<li>However, one of the goals of software design is to reduce the
number of dependencies and to make the dependencies that remain
<b>as simple and obvious as possible.</b></li>
</ul></li>
<li><p>
<a id="org54b0136"></a>
</p>
<blockquote>
<p>
Obscurity occurs when important information is not obvious.
</p>
</blockquote>
<ul class="org-ul">
<li>Obscurity is often associated with <i>dependencies</i>, where it is
not obvious that a dependency exist</li>
<li><i>Inconsistency</i> is also a major contributor to obscurity:</li>
<li>In many cases, obscurity comes about because of <i>inadequate
documentation</i></li>
<li>However, obscurity is also a <i>design issue</i>
<ul class="org-ul">
<li>If a system has a clean and obvious design, then it will need
less documentation.</li>
<li>The need for extensive documentation is often a red flag that
the design isn't quite right.</li>
<li><b>The best way to reduce obscurity is by simplifying the
system design.</b></li>
</ul></li>
</ul></li>
</ol></li>
<li>Together, dependencies and obscurity account for the <a href="#orgeae23c4">three
manifestations of complexity</a>
<ul class="org-ul">
<li>Dependencies lead to change amplification and a high cognitive
load.</li>
<li>Obscurity creates unknown unknowns, and also contributes to
cognitive load</li>
<li>f we can find design techniques that minimize dependencies and
obscurity, then we can reduce the complexity of software.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7cd10d3" class="outline-3">
<h3 id="org7cd10d3">2.4 Complexity is incremental</h3>
<div class="outline-text-3" id="text-org7cd10d3">
<ul class="org-ul">
<li>Complexity isn't caused by a single catastrophic error; it
accumulates in lots of small chunks</li>
<li>A single dependency or obscurity, by itself, is unlikely to affect
significantly the maintainability of a software system.</li>
<li>The incremental nature of complexity makes it <b>hard to control</b></li>
<li>Once complexity has accumulated, it is hard to eliminate, since
fixing a single dependency or obscurity will not, by itself, make a
big difference</li>
<li>In order to slow the growth of complexity, you must adopt <i>a "zero
tolerance" philosophy</i></li>
</ul>
</div>
</div>
<div id="outline-container-org8ce24f8" class="outline-3">
<h3 id="org8ce24f8">2.5 Conclusion</h3>
<div class="outline-text-3" id="text-org8ce24f8">
<blockquote>
<p>
Complexity comes from an accumulation of dependencies and
obscurities. As complexity increases, it leads to change
amplification, a high cognitive load, and unknown unknowns. As a
result, it takes more code modifications to implement each new
feature. In addition, developers spend more time acquiring enough
information to make the change safely and, in the worst case, they
can't even find all the information they need. The bottom line is that
complexity makes it difficult and risky to modify an existing code
base.
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgba1d937" class="outline-2">
<h2 id="orgba1d937">3 Working Code Isn't Enough</h2>
<div class="outline-text-2" id="text-orgba1d937">
<ul class="org-ul">
<li>This chapter:
<ol class="org-ol">
<li>If you want a good design, you must take a more strategic
approach where you invest time to produce clean designs and fix
problems.</li>
<li>Why the strategic approach produces better designs and is
actually cheaper than the tactical approach over the long run</li>
</ol></li>
</ul>
</div>
<div id="outline-container-orge37de46" class="outline-3">
<h3 id="orge37de46">3.1 Tactical programming</h3>
<div class="outline-text-3" id="text-orge37de46">
<ul class="org-ul">
<li>In the tactical approach, your main focus is to get something
working</li>
<li>Tactical programming makes it nearly impossible to produce a good
system design</li>
<li>The problem is that it's <b>short-sighted</b>
<ul class="org-ul">
<li>Planning for the future isn't a priority</li>
<li>You don't spend much time looking for the best design</li>
<li>You tell yourself that it's OK to add a bit of complexity or
introduce a small kludge or two</li>
<li>This is <i>how systems become complicated</i></li>
</ul></li>
<li>Almost every software development organization has at least one
developer who takes tactical programming to the extreme: a <i>tactical
tornado</i></li>
</ul>
</div>
</div>
<div id="outline-container-org3ed0a98" class="outline-3">
<h3 id="org3ed0a98">3.2 Strategic programming</h3>
<div class="outline-text-3" id="text-org3ed0a98">
<ul class="org-ul">
<li>The first step towards becoming a good software designer is to
<b>realize that working code isn't enough.</b>
<ul class="org-ul">
<li>It's not acceptable to introduce unnecessary complexities in order
to finish your current task faster.</li>
<li>The most important thing is the long-term structure of the system.</li>
</ul></li>
<li><a id="orgd3f716e"></a>
<ul class="org-ul">
<li>Your primary goal must be to <b>produce a great design, which also
happens to work.</b></li>
<li>Strategic programming requires an <i>investment mindset</i>.
<ul class="org-ul">
<li>Invest time to improve the design of the system.</li>
<li>These investments will slow you down a bit in the short term,
but they will speed you up in the long term</li>
<li>Proactive investments
<ol class="org-ol">
<li>it's worth taking a little extra time to find a simple design
for each new class; rather than implementing the first idea
that comes to mind, try a couple of alternative designs and
pick the cleanest one.</li>
<li>Try to imagine a few ways in which the system might need to be
changed in the future and make sure that will be easy with
your design.</li>
<li>Writing good documentation is another example of a proactive
investment.</li>
</ol></li>
<li>Reactive investments
(No matter how much you invest up front, there will inevitably
be mistakes in your design decisions.)
<ul class="org-ul">
<li>When you discover a design problem, don't just ignore it or
patch around it; take a little extra time to fix it.</li>
<li>If you program strategically, you will continually make small
improvements to the system design.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgac737fc" class="outline-3">
<h3 id="orgac737fc">3.3 How much to invest?</h3>
<div class="outline-text-3" id="text-orgac737fc">
<ul class="org-ul">
<li>The ideal design tends to emerge in bits and pieces, as you get
experience with the system</li>
<li>The best approach is to <b>make lots of small investments on a
continual basis</b>
<ul class="org-ul">
<li>Spend about 10-20% of the total development time on investments
<ul class="org-ul">
<li>Small enough that it won't impact your schedules significantly</li>
<li>Large enough to produce significant benefits over time
<ul class="org-ul">
<li>It won't be long before you're developing at least 10–20%
faster than you would if you had programmed tactically.</li>
<li>At this point your investments become free: the benefits from
your past investments will save enough time to cover the cost
of future investments.</li>
</ul></li>
</ul></li>
<li>Poor code quality slows development by at least 20%</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org63fc05b" class="outline-3">
<h3 id="org63fc05b">3.4 Startups and investment</h3>
<div class="outline-text-3" id="text-org63fc05b">
<ul class="org-ul">
<li>In some environments (early-stage startups) there are strong forces
working against the strategic approach
<ul class="org-ul">
<li><b>Once a code base turns to spaghetti, it is nearly impossible to
fix.</b></li>
<li>The payoff for good (or bad) design comes pretty quickly, so
there's a good chance that the tactical approach won't even speed
up your first product release.</li>
<li>One of the most important factors for success of a company is <b>the
quality of its engineers.</b>
<ul class="org-ul">
<li>The best way to lower development costs is to hire great
engineers</li>
<li>The best engineers care deeply about good design.</li>
<li>If your code base is a wreck, word will get out, and this will
make it harder for you to recruit.</li>
<li>As a result, you are likely to end up with mediocre engineers.</li>
</ul></li>
<li>Facebook changed its motto (from "Move fast and break things") to
"Move fast with solid infrastructure" to encourage its engineers
to invest more in good design.</li>
</ul></li>
<li>Fortunately, it is also possible to succeed in Silicon Valley with
a strategic approach.
<ul class="org-ul">
<li>Google</li>
<li>VMware</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org9f2b865" class="outline-3">
<h3 id="org9f2b865">3.5 Conclusion</h3>
<div class="outline-text-3" id="text-org9f2b865">
<ul class="org-ul">
<li>Good design doesn't come for free. It has to be something you invest
in continually, so that small problems don't accumulate into big</li>
<li>It's crucial to be consistent in applying the strategic approach and
to think of investment as something to do today, not tomorrow.
ones. Fortunately, good design eventually pays for itself, and
sooner than you might think.</li>
<li>The most effective approach is one where <b>every engineer makes
continuous small investments in good design.</b></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7cd2cad" class="outline-2">
<h2 id="org7cd2cad">4 Modules Should Be Deep</h2>
<div class="outline-text-2" id="text-org7cd2cad">
<ul class="org-ul">
<li>modular design:
<ul class="org-ul">
<li>design systems so that developers only need to face a small
fraction of the overall complexity at any given time.</li>
<li>One of the most important techniques for managing software
complexity</li>
</ul></li>
<li>this chapter: basic principles of modular design</li>
</ul>
</div>
<div id="outline-container-org928ffe8" class="outline-3">
<h3 id="org928ffe8">4.1 Modular design</h3>
<div class="outline-text-3" id="text-org928ffe8">
<ul class="org-ul">
<li>In modular design, a software system is decomposed into a collection
of modules that are relatively independent.</li>
<li>Modules can take many forms,</li>
<li>In an ideal world, each module would be completely independent of
the others:
<ul class="org-ul">
<li>a developer could work in any of the modules without knowing
anything about any of the other modules.</li>
<li>In this world, the complexity of a system would be the complexity
of its worst module.</li>
<li>Unfortunately, this ideal is not achievable.</li>
</ul></li>
<li>The goal of modular design is to <b>minimize the dependencies between
modules</b>.</li>
<li>In order to manage dependencies, we think of each module in two
parts:
<ol class="org-ol">
<li>Interface
<ul class="org-ul">
<li>The interface consists of everything that a developer working
in a different module must know in order to use the given
module.</li>
<li>Typically, the interface describes what the module does but not
how it does it.</li>
</ul></li>
<li>Implementation
<ul class="org-ul">
<li>The implementation consists of the code that carries out the
promises made by the interface.</li>
<li>A developer should not need to understand the implementations
of modules other than the one he or she is working in.</li>
</ul></li>
</ol></li>
<li>The best modules are those whose interfaces are much simpler than
their implementations.
<ol class="org-ol">
<li>a simple interface minimizes the complexity that a module imposes
on the rest of the system.</li>
<li>if a module is modified in a way that does not change its
interface, then no other module will be affected by the
modification.  -&gt; If a module’s interface is much simpler than
its implementation, there will be many aspects of the module that
can be changed without affecting other modules.</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org77b5b79" class="outline-3">
<h3 id="org77b5b79">4.2 What’s in an interface?</h3>
<div class="outline-text-3" id="text-org77b5b79">
<ul class="org-ul">
<li>The interface to a module contains two kinds of information:
<ul class="org-ul">
<li>formal
<ul class="org-ul">
<li>specified explicitly in the code,</li>
<li>some of these can be checked for correctness by the programming
language.</li>
</ul></li>
<li>informal
<ul class="org-ul">
<li>These are not specified in a way that can be understood or
enforced by the programming language.
<ul class="org-ul">
<li>its high-level behavior,</li>
<li>constraints on the usage of a class</li>
</ul></li>
<li>an interface described in English is likely to be more intuitive
and understandable for developers than one written in a formal
specification language.</li>
<li>For most interfaces the informal aspects are larger and more
complex than the formal aspects.</li>
</ul></li>
</ul></li>
<li>One of the benefits of a clearly specified interface is that it
indicates exactly what developers need to know in order to use the
associated module. -&gt; helps to eliminate the unknown unknowns</li>
</ul>
</div>
</div>
<div id="outline-container-org0ce7d2d" class="outline-3">
<h3 id="org0ce7d2d">4.3 Abstractions</h3>
<div class="outline-text-3" id="text-org0ce7d2d">
<ul class="org-ul">
<li>An abstraction is <b>a simplified view of an entity</b>, which omits
<b>unimportant</b> details.</li>
<li>Abstractions are useful because they make it easier for us to think
about and manipulate complex things.</li>
<li>In modular programming, each module provides an abstraction in form
of its interface.
<ul class="org-ul">
<li>The interface presents a simplified view of the module’s
functionality;</li>
<li>the details of the implementation are unimportant from the
standpoint of the module’s abstraction, so they are omitted from
the interface.</li>
</ul></li>
<li>the word "unimportant" is crucial.
<ul class="org-ul">
<li>The more unimportant details that are omitted from an abstraction,
the better.</li>
<li>However, a detail can only be omitted from an abstraction if it is
unimportant.</li>
</ul></li>
<li>An abstraction can go wrong in two ways.
<ol class="org-ol">
<li>it can include details that are not really important;</li>
<li>omits details that really are important.
<ul class="org-ul">
<li>An abstraction that omits important details is a false
abstraction: it might appear simple, but in reality it isn’t.</li>
</ul></li>
</ol></li>
<li>The key to designing abstractions is
<ol class="org-ol">
<li>to understand what is important</li>
<li>to look for designs that minimize the amount of information that
is important.</li>
</ol></li>
<li>We depend on abstractions to manage complexity not just in
programming, but pervasively in our everyday lives.</li>
</ul>
</div>
</div>
<div id="outline-container-org5278897" class="outline-3">
<h3 id="org5278897">4.4 Deep modules</h3>
<div class="outline-text-3" id="text-org5278897">
<ul class="org-ul">
<li>The best modules are deep: they have a lot of functionality hidden
behind a simple interface.</li>
<li>Module depth is a way of thinking about cost versus benefit.
<ul class="org-ul">
<li>The benefit provided by a module is its functionality.</li>
<li>The cost of a module (in terms of system complexity) is its
interface.</li>
<li>Interfaces are good, but more, or larger, interfaces are not
necessarily better!</li>
</ul></li>
<li>Examples
<ul class="org-ul">
<li>Unix I/O</li>
<li>garbage collectors</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2d226c8" class="outline-3">
<h3 id="org2d226c8">4.5 Shallow modules&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></h3>
<div class="outline-text-3" id="text-org2d226c8">
<ul class="org-ul">
<li>Shallow classes are sometimes unavoidable, but they don’t provide
help much in managing complexity.</li>
<li>Small modules tend to be shallow.</li>
<li>Red Flag: Shallow Module</li>
</ul>
</div>
</div>
<div id="outline-container-org9b578ca" class="outline-3">
<h3 id="org9b578ca">4.6 Classitis</h3>
<div class="outline-text-3" id="text-org9b578ca">
<ul class="org-ul">
<li>The conventional wisdom in programming is that classes should be
small, not deep.</li>
<li>The extreme of the "classes should be small" approach is a syndrome
I call <i>classitis</i>,
<ul class="org-ul">
<li>which stems from the mistaken view that "classes are good, so more
classes are better."</li>
<li>Classitis may result in classes that are individually simple, but
it increases the complexity of the overall system.
<ol class="org-ol">
<li>Small classes don’t contribute much functionality, so there
have to be a lot of them, each with its own interface. These
interfaces accumulate to create tremendous complexity at the
system level.</li>
<li>Small classes also result in a verbose programming style, due
to the boilerplate required for each class.</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1b9174a" class="outline-3">
<h3 id="org1b9174a">4.7 Examples: Java and Unix I/O</h3>
<div class="outline-text-3" id="text-org1b9174a">
<ul class="org-ul">
<li>interfaces should be designed to make the common case as simple as
possible</li>
<li>If an interface has many features, but most developers only need to
be aware of a few of them, the effective complexity of that
interface is just the complexity of the commonly used features.</li>
</ul>
</div>
</div>
<div id="outline-container-org1269e7b" class="outline-3">
<h3 id="org1269e7b">4.8 Conclusion</h3>
<div class="outline-text-3" id="text-org1269e7b">
<ul class="org-ul">
<li>By separating the interface of a module from its implementation, we
can hide the complexity of the implementation from the rest of the
system.</li>
<li>Users of a module need only understand the abstraction provided by
its interface.</li>
<li>The most important issue in designing classes and other modules is
to make them deep, so that they have simple interfaces for the
common use cases, yet still provide significant functionality. This
maximizes the amount of complexity that is concealed.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9aa2ef0" class="outline-2">
<h2 id="org9aa2ef0">5 Information Hiding (and Leakage)</h2>
<div class="outline-text-2" id="text-org9aa2ef0">
<ul class="org-ul">
<li>Techniques for creating deep modules.</li>
</ul>
</div>
<div id="outline-container-org669fa78" class="outline-3">
<h3 id="org669fa78">5.1 Information hiding</h3>
<div class="outline-text-3" id="text-org669fa78">
<ul class="org-ul">
<li>The most important technique for achieving deep modules</li>
<li><a href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf">On the Criteria To Be Used in Decomposing Systems into Modules</a>
<ul class="org-ul">
<li>The basic idea is that each module should encapsulate a few pieces
of knowledge, which represent design decisions.</li>
<li>The knowledge is embedded in the module's implementation but does
not appear in its interface, so it is not visible to other
modules.</li>
</ul></li>
<li>The information hidden within a module usually consists of details
about how to implement some mechanism.</li>
<li>The hidden information includes data structures and algorithms
related to the mechanism.</li>
<li>Information hiding reduces complexity in two ways.
<ol class="org-ol">
<li>it simplifies the interface to a module.
<ul class="org-ul">
<li>The interface reflects a simpler, more abstract view of the
module's functionality and hides the details;</li>
<li>this reduces the cognitive load on developers who use the
module.</li>
</ul></li>
<li>information hiding makes it easier to evolve the system.
<ul class="org-ul">
<li>If a piece of information is hidden, there are no dependencies
on that information outside the module containing the
information,</li>
<li>so a design change related to that information will affect only
the one module.</li>
</ul></li>
</ol></li>
<li>When designing a new module, you should think carefully about what
information can be hidden in that module.
<ul class="org-ul">
<li>If you can hide more information, you should also be able to
simplify the module's interface, and this makes the module deeper.</li>
<li>Hiding variables and methods in a class by declaring them private
isn't the same thing as information hiding.
<ul class="org-ul">
<li>Private elements can help with information hiding</li>
<li>However, information about the private items can still be
exposed through public methods.</li>
</ul></li>
</ul></li>
<li>The best form of information hiding is when information is totally
hidden within a module
<ul class="org-ul">
<li>So that it is irrelevant and invisible to users of the module</li>
</ul></li>
<li>Partial information hiding also has value
<ul class="org-ul">
<li>If a particular feature or piece of information is only needed by
a few of a class's users, and it is accessed through separate
methods so that it isn't visible in the most common use cases,
then that information is mostly hidden.</li>
<li>Such information will create fewer dependencies than information
that is visible to every user of the class.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4186877" class="outline-3">
<h3 id="org4186877">5.2 Information leakage&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></h3>
<div class="outline-text-3" id="text-org4186877">
<ul class="org-ul">
<li>The opposite of information hiding</li>
<li>Information leakage occurs <b>when a design decision is reflected in
multiple modules.</b> (<b>when the same knowledge is used in multiple
places</b>)
<ul class="org-ul">
<li><a id="org7ef3398"></a>: If a piece of information is
reflected in the interface for a module, then by definition it has
been leaked;</li>
<li><a id="org2e313ff"></a>: Information can be leaked even if it
doesn't appear in a module's interface
<ul class="org-ul">
<li>e.g. two classes both have knowledge of a particular file format</li>
<li>more pernicious than leakage through an interface, because it
isn't obvious.</li>
</ul></li>
</ul></li>
<li>One of the most important red flags in software design.
<ul class="org-ul">
<li>One of the best skills you can learn as a software designer is <b>a
high level of sensitivity to information leakage.</b></li>
<li>If you encounter information leakage between classes, ask yourself
"How can I reorganize these classes so that this particular piece
of knowledge only affects a single class?"
<ol class="org-ol">
<li>If the affected classes are relatively small and closely tied
to the leaked information, it may make sense to merge them into
a single class.</li>
<li>Pull the information out of all of the affected classes and
create a new class that encapsulates just that information.
<ul class="org-ul">
<li>However, this approach will be effective only if you can find
a simple interface that abstracts away from the details;</li>
<li>if the new class exposes most of the knowledge through its
interface, then it won't provide much value (you've simply
replaced back-door leakage with leakage through an
interface).</li>
</ul></li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgaec02da" class="outline-3">
<h3 id="orgaec02da">5.3 Temporal decomposition&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></h3>
<div class="outline-text-3" id="text-orgaec02da">
<pre class="example">
Consider an application that reads a file in a particular format,
modifies the contents of the file, and then writes the file out
again. With temporal decomposition, this application might be broken
into three classes: one to read the file, another to perform the
modifications, and a third to write out the new version. Both the file
reading and file writing steps have knowledge about the file format,
which results in information leakage. The solution is to combine the
core mechanisms for reading and writing files into a single
class. This class will get used during both the reading and writing
phases of the application.
</pre>
<ul class="org-ul">
<li>A design style</li>
<li>In temporal decomposition, the structure of a system corresponds to
the time order in which operations will occur</li>
<li>It's easy to fall into the trap of temporal decomposition, because
the order in which operations must occur is often on your mind when
you code.</li>
<li>Most design decisions manifest themselves at several different times
over the life of the application; <b>as a result, temporal
decomposition often results in information leakage.</b></li>
<li>Order usually does matter, so it will be reflected somewhere in the
application
<ul class="org-ul">
<li>However, it shouldn't be reflected in the module structure</li>
<li>Unless that structure is consistent with information hiding
(perhaps the different stages use totally different information).</li>
</ul></li>
<li><b>When designing modules, focus on the knowledge that's needed to
perform each task, not the order in which tasks occur.</b></li>
</ul>
</div>
</div>
<div id="outline-container-org91eb2cb" class="outline-3">
<h3 id="org91eb2cb">5.4 Example: HTTP server</h3>
<div class="outline-text-3" id="text-org91eb2cb">
<ul class="org-ul">
<li>The students in the course were asked to implement one or more
classes to make it easy for Web servers to receive incoming HTTP
requests and send responses.</li>
</ul>
</div>
<div id="outline-container-org0042bfa" class="outline-4">
<h4 id="org0042bfa">5.5 Example: too many classes</h4>
<div class="outline-text-4" id="text-org0042bfa">
<ul class="org-ul">
<li>The most common mistake made by students was to divide their code
into a large number of shallow classes, which led to information
leakage between the classes.</li>
<li><b>Information hiding can often be improved by making a class slightly
larger.</b>
<ol class="org-ol">
<li>Bring together all of the code related to a particular capability
<ul class="org-ul">
<li>(such as parsing an HTTP request),</li>
<li>so that the resulting class contains everything related to that
capability.</li>
</ul></li>
<li>Raise the level of the interface</li>
</ol></li>
<li>Of course, it is possible to take the notion of larger classes too
far (such as a single class for the entire application).
<i>9 Better Together Or Better Apart?</i></li>
</ul>
</div>
</div>
<div id="outline-container-org0b44f4f" class="outline-4">
<h4 id="org0b44f4f">5.6 Example: HTTP parameter handling</h4>
<div class="outline-text-4" id="text-org0b44f4f">
<ul class="org-ul">
<li>It's important to avoid exposing internal data structures
<ul class="org-ul">
<li>Example:
<ul class="org-ul">
<li>bad: <code>getParams</code></li>
<li>better: <code>getParameter</code></li>
<li>even better?: <code>getIntParameter</code>
<ul class="org-ul">
<li>This saves the caller from having to request string-to-integer
conversion separately, and hides that mechanism from the
caller.</li>
<li>Additional methods for other data types, such as
<code>getDoubleParameter</code>, could be defined if needed.</li>
<li>(All of these methods will throw exceptions if the desired
parameter doesn't exist, or if it can't be converted to the
requested type; the exception declarations have been omitted
in the code above).</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgbe2ddcd" class="outline-4">
<h4 id="orgbe2ddcd">5.7 Example: defaults in HTTP responses</h4>
<div class="outline-text-4" id="text-orgbe2ddcd">
<ul class="org-ul">
<li>Interfaces should be designed to make the common case as simple as
possible.</li>
<li>Whenever possible, classes should "do the right thing" without being
explicitly asked.</li>
</ul>
</div>
<ul class="org-ul">
<li><a id="org9ac45d8"></a>Red Flag: Overexposure&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span><br />
<div class="outline-text-5" id="text-org9ac45d8">
<blockquote>
<p>
If the API for a commonly used feature forces users to learn about
other features that are rarely used, this increases the cognitive load
on users who don’t need the rarely used features.
</p>
</blockquote>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-orge9e3a2e" class="outline-3">
<h3 id="orge9e3a2e">5.8 Information hiding within a class</h3>
<div class="outline-text-3" id="text-orge9e3a2e">
<ol class="org-ol">
<li>Try to design the private methods within a class so that each
method encapsulates some information or capability and hides it
from the rest of the class.</li>
<li>In addition, try to minimize the number of places where each
instance variable is used.
<ul class="org-ul">
<li>if you can reduce the number of places where a variable is used,
you will eliminate dependencies within the class and reduce its
complexity.</li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-orge64d313" class="outline-3">
<h3 id="orge64d313">5.9 Taking it too far</h3>
<div class="outline-text-3" id="text-orge64d313">
<ul class="org-ul">
<li>Information hiding only makes sense when the information being
hidden is not needed outside its module.</li>
<li>If the information is needed outside the module, then you must <i>not</i>
hide it.</li>
<li>As a software designer, your goal should be to <b>minimize the amount
of information needed outside a module</b></li>
<li>But, it's important to recognize which information is needed outside
a module and make sure it is exposed.</li>
</ul>
</div>
</div>
<div id="outline-container-org1e87f39" class="outline-3">
<h3 id="org1e87f39">5.10 Conclusion</h3>
<div class="outline-text-3" id="text-org1e87f39">
<ul class="org-ul">
<li>Information hiding and deep modules are closely related.
<ul class="org-ul">
<li>If a module hides a lot of information, that tends to increase the
amount of functionality provided by the module while also reducing
its interface. This makes the module deeper</li>
<li>Conversely, if a module doesn't hide much information, then either
it doesn't have much functionality, or it has a complex interface;
either way, the module is shallow.</li>
</ul></li>
<li>When decomposing a system into modules, try not to be influenced by
the order in which operations will occur at runtime; that will lead
you down the path of temporal decomposition, which will result in
information leakage and shallow modules.</li>
<li>Instead, <b>think about the different pieces of knowledge that are
needed to carry out the tasks of your application</b>, and design each
module to encapsulate one or a few of those pieces of knowledge.
<ul class="org-ul">
<li>This will produce a clean and simple design with deep modules.</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf31e735" class="outline-2">
<h2 id="orgf31e735">6 General-Purpose Modules are Deeper</h2>
<div class="outline-text-2" id="text-orgf31e735">
<ul class="org-ul">
<li>The general-purpose approach seems consistent with the investment
mindset discussed in <i>Chapter 3</i>, where you spend a bit more time up
front to save time later on.</li>
<li>The special-purpose approach seems consistent with an incremental
approach to software development.</li>
</ul>
</div>
<div id="outline-container-org2cfee25" class="outline-3">
<h3 id="org2cfee25">6.1 Make classes somewhat general-purpose</h3>
<div class="outline-text-3" id="text-org2cfee25">
<ul class="org-ul">
<li>In my experience, the sweet spot is to implement new modules in a
<i>somewhat general-purpose</i> fashion.
<ul class="org-ul">
<li>The module's functionality should reflect your current needs, but
its interface should not.</li>
<li>Instead, the interface should be general enough to support
multiple uses.</li>
</ul></li>
<li>The most important (and perhaps surprising) benefit of the
general-purpose approach is that <b>it results in simpler and deeper
interfaces</b> than a special-purpose approach.
<ul class="org-ul">
<li>The general-purpose approach can also save you time in the future,
if you reuse the class for other purposes.</li>
<li>However, even if the module is only used for its original purpose,
the general-purpose approach is <b>still better because of its
simplicity.</b></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgdfcb514" class="outline-3">
<h3 id="orgdfcb514">6.2 Example: storing text for an editor</h3>
<div class="outline-text-3" id="text-orgdfcb514">
<div class="org-src-container">
<pre class="src src-java">void backspace(Cursor cursor);
void delete(Cursor cursor);
void deleteSelection(Selection selection);
</pre>
</div>
<ul class="org-ul">
<li>Each new user interface operation required a new method to be
defined in the text class, so a developer working on the user
interface was likely to end up working on the text class as well.</li>
<li><b>One of the goals in class design is to allow each class to be
developed independently</b>, but the specialized approach tied the user
interface and text classes together.</li>
</ul>
</div>
<div id="outline-container-orgc82e266" class="outline-4">
<h4 id="orgc82e266">6.3 A more general-purpose API</h4>
<div class="outline-text-4" id="text-orgc82e266">
<div class="org-src-container">
<pre class="src src-java">void insert(Position position, String newText);
void delete(Position start, Position end);
Position changePosition(Position position, int numChars);


text.delete(cursor, text.changePosition(cursor, 1)); // delete
text.delete(text.changePosition(cursor, -1), cursor); // backspace
</pre>
</div>
</div>
</div>
<div id="outline-container-org5b5c2a3" class="outline-4">
<h4 id="org5b5c2a3">6.4 Generality leads to better information hiding</h4>
<div class="outline-text-4" id="text-org5b5c2a3">
<ul class="org-ul">
<li>One of the most important elements of software design is
<b>determining who needs to know what, and when.</b>
<ul class="org-ul">
<li>When the details are important, it is better to make them explicit
and as obvious as possible,</li>
<li>Hiding this information behind an interface just creates
obscurity.</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org96c0d02" class="outline-3">
<h3 id="org96c0d02">6.5 Questions to ask yourself</h3>
<div class="outline-text-3" id="text-org96c0d02">
<ul class="org-ul">
<li>What is the simplest interface that will cover all my current needs?
<ul class="org-ul">
<li>If you reduce the number of methods in an API without reducing its
overall capabilities, then you are probably creating more
general-purpose methods</li>
<li>Reducing the number of methods makes sense only as long as the API
for each individual method stays simple; if you have to introduce
lots of additional arguments in order to reduce the number of
methods, then you may not really be simplifying things.</li>
</ul></li>
<li>In how many situations will this method be used?</li>
<li>Is this API easy to use for my current needs?
<ul class="org-ul">
<li>This question can help you to determine when you have gone too far
in making an API simple and general-purpose.</li>
<li>If you have to write a lot of additional code to use a class for
your current purpose, that’s a red flag that the interface doesn’t
provide the right functionality</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2fe3342" class="outline-3">
<h3 id="org2fe3342">6.6 Conclusion</h3>
<div class="outline-text-3" id="text-org2fe3342">
<ul class="org-ul">
<li>General-purpose interfaces have many advantages over special-purpose
ones.
<ul class="org-ul">
<li>They tend to be simpler, with fewer methods that are deeper.</li>
<li>They also provide a cleaner separation between classes, whereas
special-purpose interfaces tend to leak information between
classes.</li>
</ul></li>
<li>Making your modules somewhat general-purpose is one of the best ways
to reduce overall system complexity.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7e89f9f" class="outline-2">
<h2 id="org7e89f9f">7 Different Layer, Different Abstraction</h2>
<div class="outline-text-2" id="text-org7e89f9f">
<ul class="org-ul">
<li>If a system contains adjacent layers with similar abstractions, this
is a red flag that suggests a problem with the class decomposition.</li>
<li>This chapter discusses situations where this happens, the problems
that result, and how to refactor to eliminate the problems.</li>
</ul>
</div>
<div id="outline-container-org11bcf10" class="outline-3">
<h3 id="org11bcf10">7.1 Pass-through methods</h3>
<div class="outline-text-3" id="text-org11bcf10">
<ul class="org-ul">
<li>When adjacent layers have similar abstractions, the problem often
manifests itself in the form of pass-through methods.</li>
<li>A pass-through method is one that does little except invoke another
method, whose signature is similar or identical to that of the
calling method.</li>
<li>This typically indicates that there is not a clean division of
responsibility between the classes.</li>
<li>Pass-through methods make classes shallower:
<ul class="org-ul">
<li>they increase the interface complexity of the class, which adds
complexity,</li>
<li>but they don't increase the total functionality of the system.</li>
</ul></li>
<li>Pass-through methods also create dependencies between classes:
<ul class="org-ul">
<li>the interface to a piece of functionality should be in the same
class that implements the functionality.</li>
<li>consider the two classes and ask yourself "Exactly which features
and abstractions is each of these classes responsible for?"</li>
<li>The solution is to refactor the classes so that each class has a
distinct and coherent set of responsibilities.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge9bfefd" class="outline-3">
<h3 id="orge9bfefd">7.2 When is interface duplication OK?</h3>
<div class="outline-text-3" id="text-orge9bfefd">
<ul class="org-ul">
<li>Having methods with the same signature is not always bad.
<ul class="org-ul">
<li>The important thing is that each new method should contribute
significant functionality.</li>
<li>Pass-through methods are bad because they contribute no new
functionality.</li>
</ul></li>
<li>One example is a dispatcher.
<ul class="org-ul">
<li>A dispatcher is a method that uses its arguments to select one of
several other methods to invoke; then it passes most or all of its
arguments to the chosen method.</li>
<li>the dispatcher provides useful functionality: it chooses which of
several other methods should carry out each task.</li>
</ul></li>
<li>Another example is interfaces with multiple implementations,
<ul class="org-ul">
<li>When several methods provide different implementations of the same
interface, it reduces cognitive load.</li>
<li>Once you have worked with one of these methods, it's easier to
work with the others, since you don't need to learn a new
interface.</li>
<li>Methods like this are usually in the same layer and they don't
invoke each other.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge2d438d" class="outline-3">
<h3 id="orge2d438d">7.3 Decorators</h3>
<div class="outline-text-3" id="text-orge2d438d">
<ul class="org-ul">
<li>The motivation for decorators is to separate special-purpose
extensions of a class from a more generic core.</li>
<li>However, decorator classes tend to be shallow: they introduce a
large amount of boilerplate for a small amount of new functionality.</li>
<li>Decorator classes often contain many pass-through methods.</li>
<li>It's easy to overuse the decorator pattern, creating a new class for
every small new feature.</li>
<li>Before creating a decorator class, consider alternatives such as the
following:
<ul class="org-ul">
<li>Could you add the new functionality directly to the underlying
class, rather than creating a decorator class?
<ul class="org-ul">
<li>This makes sense if
<ul class="org-ul">
<li>the new functionality is relatively general-purpose,</li>
<li>it is logically related to the underlying class,</li>
<li>most uses of the underlying class will also use the new
functionality.</li>
</ul></li>
</ul></li>
<li>If the new functionality is specialized for a particular use case,
would it make sense to merge it with the use case, rather than
creating a separate class?</li>
<li>Could you merge the new functionality with an existing decorator,
rather than creating a new decorator?
<ul class="org-ul">
<li>This would result in a single deeper decorator class rather than
multiple shallow ones.</li>
</ul></li>
<li>ask yourself whether the new functionality really needs to wrap
the existing functionality:
<ul class="org-ul">
<li>could you implement it as a stand-alone class that is
independent of the base class?</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2bbecb8" class="outline-3">
<h3 id="org2bbecb8">7.4 Interface versus implementation</h3>
<div class="outline-text-3" id="text-org2bbecb8">
<ul class="org-ul">
<li>The interface of a class should normally be different from its
implementation: the representations used internally should be
different from the abstractions that appear in the interface.</li>
<li>If the two have similar abstractions, then the class probably isn't
very deep.</li>
<li>The difference represents valuable functionality provided by the
class.</li>
</ul>
</div>
</div>
<div id="outline-container-orgb72eecc" class="outline-3">
<h3 id="orgb72eecc">7.5 Pass-through variables</h3>
<div class="outline-text-3" id="text-orgb72eecc">
<ul class="org-ul">
<li>a variable that is passed down through a long chain of methods.</li>
<li>Pass-through variables add complexity because
<ol class="org-ol">
<li>they force all of the intermediate methods to be aware of their
existence, even though the methods have no use for the variables.</li>
<li>Furthermore, if a new variable comes into existence, you may have
to modify a large number of interfaces and methods to pass the
variable through all of the relevant paths.</li>
</ol></li>
<li>Eliminating pass-through variables can be challenging.
<ol class="org-ol">
<li>see if there is already an object shared between the topmost and
bottommost methods.
<ul class="org-ul">
<li>However, if there is such an object, then it may itself be a
pass-through variable</li>
</ul></li>
<li>store the information in a global variable,
<ul class="org-ul">
<li>but global variables almost always create other problems.</li>
</ul></li>
<li>introduce a context object (The solution I use most often)
<ul class="org-ul">
<li>A context stores all of the application's global state
(anything that would otherwise be a pass-through variable or
global variable).</li>
<li>The context allows multiple instances of the system to coexist
in a single process, each with its own context.</li>
<li>Unfortunately, the context will probably be needed in many
places, so it can potentially become a pass-through variable.
<ul class="org-ul">
<li>To reduce the number of methods that must be aware of it, a
reference to the context can be saved in most of the system's
major objects.</li>
<li>With this approach, the context is available everywhere, but
it only appears as an explicit argument in constructors.</li>
</ul></li>
<li>The context object unifies the handling of all system-global
information and eliminates the need for pass-through variables.
<ul class="org-ul">
<li>The context makes it easy to identify and manage the global
state of the system, since it is all stored in one place.</li>
<li>The context is also convenient for testing: test code can
change the global configuration of the application by
modifying fields in the context.</li>
</ul></li>
<li>Contexts are far from an ideal solution.
<ul class="org-ul">
<li>The variables stored in a context have most of the
disadvantages of global variables;</li>
<li>Without discipline, a context can turn into a huge grab-bag
of data that creates nonobvious dependencies throughout the
system.</li>
<li>Contexts may also create thread-safety issues;
<ul class="org-ul">
<li>the best way to avoid problems is for variables in a
context to be immutable.</li>
</ul></li>
</ul></li>
<li>Unfortunately, I haven't found a better solution than contexts.</li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org99f0566" class="outline-3">
<h3 id="org99f0566">7.6 Conclusion</h3>
<div class="outline-text-3" id="text-org99f0566">
<ul class="org-ul">
<li>Each piece of design infrastructure added to a system, such as an
interface, argument, function, class, or definition, adds
complexity, since developers must learn about this element.
<ul class="org-ul">
<li>In order for an element to provide a net gain against complexity,
it must eliminate some complexity that would be present in the
absence of the design element.</li>
<li>Otherwise, you are better off implementing the system without that
particular element.</li>
</ul></li>
<li>The "different layer, different abstraction" rule is just an
application of this idea:</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org44b1b0c" class="outline-2">
<h2 id="org44b1b0c">8 Pull Complexity Downwards</h2>
<div class="outline-text-2" id="text-org44b1b0c">
<ul class="org-ul">
<li>This chapter
<ul class="org-ul">
<li>introduces another way of thinking about how to create deeper
classes.</li>
</ul></li>
<li>It is more important for a module to have a simple interface than a
simple implementation.
<ul class="org-ul">
<li>Most modules have more users than developers, so it is better
for the developers to suffer than the users.</li>
<li>As a module developer, you should strive to make life as easy as
possible for the users of your module, even if that means extra
work for you.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org48567f6" class="outline-3">
<h3 id="org48567f6">8.1 Example: editor text class</h3>
<div class="outline-text-3" id="text-org48567f6">
<ul class="org-ul">
<li>A character-oriented interface such as the one described in <i>Section
6.3</i> pulls complexity downward.</li>
<li>This approach is better because it encapsulates the complexity of
splitting and merging within the text class, which reduces the
overall complexity of the system.</li>
</ul>
</div>
</div>
<div id="outline-container-org7ed6a09" class="outline-3">
<h3 id="org7ed6a09">8.2 Example: configuration parameters</h3>
<div class="outline-text-3" id="text-org7ed6a09">
<ul class="org-ul">
<li>Configuration parameters are an example of moving complexity upwards
instead of down.</li>
<li>an easy excuse to avoid dealing with important issues and pass them
on to someone else.
<ul class="org-ul">
<li>In many cases, it's difficult or impossible for users or
administrators to determine the right values for the parameters.</li>
<li>In other cases, the right values could have been determined
automatically with a little extra work in the system
implementation.</li>
</ul></li>
<li>Configuration parameters can easily become out of date.</li>
<li>Before exporting a configuration parameter, ask yourself: “will
users (or higher-level modules) be able to determine a better value
than we can determine here?”</li>
<li>Ideally, each module should solve a problem completely;
configuration parameters result in an incomplete solution, which
adds to system complexity.</li>
</ul>
</div>
</div>
<div id="outline-container-orga01c139" class="outline-3">
<h3 id="orga01c139">8.3 Taking it too far</h3>
<div class="outline-text-3" id="text-orga01c139">
<ul class="org-ul">
<li>This is an idea that can easily be overdone.</li>
<li>Pulling complexity down makes the most sense if
<ol class="org-ol">
<li>the complexity being pulled down is closely related to the
class's existing functionality,</li>
<li>pulling the complexity down will result in many simplifications
elsewhere in the application, and</li>
<li>pulling the complexity down simplifies the class's interface.</li>
</ol></li>
<li>Remember that the goal is to minimize overall system complexity.</li>
</ul>
</div>
</div>
<div id="outline-container-org4bb147f" class="outline-3">
<h3 id="org4bb147f">8.4 Conclusion</h3>
<div class="outline-text-3" id="text-org4bb147f">
<ul class="org-ul">
<li>When developing a module, look for opportunities to take a little
bit of extra suffering upon yourself in order to reduce the
suffering of your users.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbfea5cc" class="outline-2">
<h2 id="orgbfea5cc">9 Better Together Or Better Apart?</h2>
<div class="outline-text-2" id="text-orgbfea5cc">
<ul class="org-ul">
<li>One of the most fundamental questions in software design is this:
given two pieces of functionality, should they be implemented
together in the same place, or should their implementations be
separated?
<ul class="org-ul">
<li>This question applies at all levels in a system, such as functions,
methods, classes, and services.</li>
</ul></li>
<li>This chapter discusses the factors to consider when making these
decisions.</li>
<li>When deciding whether to combine or separate, <b>the goal is to reduce
the complexity of the system as a whole and improve its modularity</b>.</li>
<li>The act of subdividing creates additional complexity that was not
present before subdivision:
<ul class="org-ul">
<li>Some complexity comes just from the number of components:
<ul class="org-ul">
<li>the more components, the harder to keep track of them all and
the harder to find a desired component within the large
collection.</li>
<li>Subdivision usually results in more interfaces, and every new
interface adds complexity.</li>
</ul></li>
<li>Subdivision can result in additional code to manage the
components.</li>
<li>Subdivision creates separation:
<ul class="org-ul">
<li>the subdivided components will be farther apart than they were
before subdivision.</li>
<li>Separation makes it harder for developers to see the components
at the same time, or even to be aware of their existence.</li>
<li>If the components are truly independent, then separation is
good: it allows the developer to focus on a single component at
a time, without being distracted by the other components.</li>
<li>On the other hand, if there are dependencies between the
components, then separation is bad: developers will end up
flipping back and forth between the components.</li>
<li>Even worse, they may not be aware of the dependencies, which can
lead to bugs.</li>
</ul></li>
<li>Subdivision can result in duplication: code that was present in a
single instance before subdivision may need to be present in each
of the subdivided components.</li>
</ul></li>
<li>Here are a few indications that two pieces of code are related:
<ul class="org-ul">
<li>They share information;</li>
<li>They are used together: anyone using one of the pieces of code is
likely to use the other as well.</li>
<li>They overlap conceptually, in that there is a simple higher-level
category that includes both of the pieces of code.</li>
<li>It is hard to understand one of the pieces of code without looking
at the other.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org8322c61" class="outline-3">
<h3 id="org8322c61">9.1 Bring together if information is shared</h3>
<div class="outline-text-3" id="text-org8322c61">
<ul class="org-ul">
<li><i>Section 5.4</i> introduced this principle in the context of a project
implementing an HTTP server.</li>
<li>Because of this shared information, it is better to both read and
parse the request in the same place; when the two classes were
combined into one, the code got shorter and simpler.</li>
</ul>
</div>
</div>
<div id="outline-container-orgc9fc10c" class="outline-3">
<h3 id="orgc9fc10c">9.2 Bring together if it will simplify the interface</h3>
<div class="outline-text-3" id="text-orgc9fc10c">
<ul class="org-ul">
<li>This often happens when the original modules each implement part of
the solution to a problem.</li>
<li>In addition, when the functionality of two or more classes is
combined, it may be possible to perform some functions
automatically, so that most users need not be aware of them.</li>
</ul>
</div>
</div>
<div id="outline-container-org8d45eb1" class="outline-3">
<h3 id="org8d45eb1">9.3 Bring together to eliminate duplication</h3>
<div class="outline-text-3" id="text-org8d45eb1">
<ul class="org-ul">
<li>If you find the same pattern of code repeated over and over, see if
you can reorganize the code to eliminate the repetition.</li>
<li>Approaches
<ol class="org-ol">
<li>Factor the repeated code out into a separate method and replace
the repeated code snippets with calls to the method.
<ul class="org-ul">
<li>This approach is most effective if the repeated code snippet is
long and the replacement method has a simple signature.</li>
<li>If the snippet interacts in complex ways with its environment
(such as by accessing numerous local variables), then the
replacement method might require a complex signature (such as
many pass-by-reference arguments), which would reduce its value.</li>
</ul></li>
<li>Refactor the code so that the snippet in question only needs to
be executed in one place.
<ul class="org-ul">
<li><code>goto</code></li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-orge385e94" class="outline-3">
<h3 id="orge385e94">9.4 Separate general-purpose and special-purpose code</h3>
<div class="outline-text-3" id="text-orge385e94">
<ul class="org-ul">
<li>If a module contains a mechanism that can be used for several
different purposes, then it should provide just that one
general-purpose mechanism.
<ul class="org-ul">
<li>It should not include code that specializes the mechanism for a
particular use, nor should it contain other general-purpose
mechanisms.</li>
<li>Special-purpose code associated with a general-purpose mechanism
should normally go in a different module (typically one associated
with the particular purpose).</li>
</ul></li>
<li>This approach eliminated information leakage and additional
interfaces</li>
<li>In general, the lower layers of a system tend to be more
general-purpose and the upper layers more special-purpose.</li>
<li>The way to separate special-purpose code from general-purpose code
is to
<ol class="org-ol">
<li>pull the special-purpose code upwards, into the higher layers,</li>
<li>leaving the lower layers general-purpose.</li>
</ol></li>
</ul>
</div>
<div id="outline-container-orge363abb" class="outline-4">
<h4 id="orge363abb">Red Flag: Repetition&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></h4>
<div class="outline-text-4" id="text-orge363abb">
<ul class="org-ul">
<li>If the same piece of code (or code that is almost the same) appears
over and over again, that's a red flag that you haven't found the
right abstractions.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0b59f61" class="outline-3">
<h3 id="org0b59f61">9.5 Example: insertion cursor and selection</h3>
<div class="outline-text-3" id="text-org0b59f61">
</div>
<div id="outline-container-orgbab8203" class="outline-4">
<h4 id="orgbab8203">Red Flag: Special-General Mixture&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></h4>
<div class="outline-text-4" id="text-orgbab8203">
<ul class="org-ul">
<li>This red flag occurs when a general-purpose mechanism also contains
code specialized for a particular use of that mechanism.</li>
<li>This makes the mechanism more complicated and creates information
leakage between the mechanism and the particular use case: future
modifications to the use case are likely to require changes to the
underlying mechanism as well.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1f1af79" class="outline-3">
<h3 id="org1f1af79">9.6 Example: separate class for logging</h3>
<div class="outline-text-3" id="text-org1f1af79">
<ul class="org-ul">
<li>This separation added complexity with no benefit.</li>
<li>The logging methods were shallow:
<ul class="org-ul">
<li>most consisted of a single line of code, but they required a
considerable amount of documentation.</li>
<li>Each method was only invoked in a single place.</li>
<li>The logging methods were highly dependent on their invocations:
<ul class="org-ul">
<li>someone reading the invocation would most likely flip over to
the logging method to make sure that the right information was
being logged;</li>
<li>similarly, someone reading the logging method would probably
flip over to the invocation site to understand the purpose of
the method.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6669cef" class="outline-3">
<h3 id="org6669cef">9.7 Example: editor undo mechanism</h3>
<div class="outline-text-3" id="text-org6669cef">
<ul class="org-ul">
<li>The key design decision was the one that separated the
general-purpose part of the undo mechanism from the special-purpose
parts and put the general-purpose part in a class by itself. Once
that was done, the rest of the design fell out naturally.</li>
<li>Note: the suggestion to separate general-purpose code from
special-purpose code refers to <b>code related to a particular
mechanism</b>.
<ul class="org-ul">
<li>For example, special-purpose undo code (such as code to undo a
text insertion) should be separated from general-purpose undo code
(such as code to manage the history list).</li>
<li>However, <b>it often makes sense to combine special-purpose code for
one mechanism with general-purpose code for another</b>.
<ul class="org-ul">
<li>The text class is an example of this:
<ul class="org-ul">
<li>it implements a general-purpose mechanism for managing text,</li>
<li>but it includes special-purpose code related to undoing.
<ul class="org-ul">
<li>The undo code is special-purpose because it only handles
undo operations for text modifications.</li>
</ul></li>
<li>It doesn't make sense to combine this code with the
general-purpose undo infrastructure in the History class, but
it does make sense to put it in the text class, since it is
closely related to other text functions.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgfb912f7" class="outline-3">
<h3 id="orgfb912f7">9.8 Splitting and joining methods</h3>
<div class="outline-text-3" id="text-orgfb912f7">
<ul class="org-ul">
<li>Length by itself is rarely a good reason for splitting up a method.
<ul class="org-ul">
<li>In general, developers tend to break up methods too much.</li>
<li>Splitting up a method introduces additional interfaces, which add
to complexity.</li>
<li>You shouldn't break up a method unless it makes the overall system
simpler;</li>
</ul></li>
<li>Long methods aren't always bad.
<ul class="org-ul">
<li>For example, suppose a method contains five 20-line blocks of code
that are executed in order.
<ul class="org-ul">
<li>If the blocks are relatively independent, then the method can be
read and understood one block at a time; there's not much
benefit in moving each of the blocks into a separate method.</li>
<li>If the blocks have complex interactions, it's even more
important to keep them together so readers can see all of the
code at once;</li>
<li>If each block is in a separate method, readers will have to flip
back and forth between these spread-out methods in order to
understand how they work together.</li>
</ul></li>
<li>Methods containing hundreds of lines of code are fine if they have
a simple signature and are easy to read. These methods are deep
(lots of functionality, simple interface), which is good.</li>
</ul></li>
<li>When designing methods, the most important goal is to <b>provide clean
and simple abstractions.</b>
<ul class="org-ul">
<li>Each method should do one thing and do it completely.
<ul class="org-ul">
<li>The method should have a clean and simple interface, so that
users don't need to have much information in their heads in
order to use it correctly.</li>
<li>The method should be deep: its interface should be much simpler
than its implementation.</li>
</ul></li>
<li>If a method has all of these properties, then it probably doesn't
matter whether it is long or not.</li>
</ul></li>
<li>Splitting up a method only makes sense if it results in cleaner
abstractions, overall.
<ul class="org-ul">
<li>A method can be split either
<ol class="org-ol">
<li>(The best way) by extracting a subtask
<ul class="org-ul">
<li>This form of subdivision makes sense if there is a subtask
that is cleanly separable from the rest of the original
method,</li>
<li>which means
<ol class="org-ol">
<li>someone reading the child method doesn't need to know
anything about the parent method</li>
<li>someone reading the parent method doesn't need to
understand the implementation of the child method.</li>
</ol></li>
<li>Typically this means that the child method is relatively
general-purpose: it could conceivably be used by other methods
besides the parent.</li>
<li>If you make a split of this form and then find yourself
flipping back and forth between the parent and child to
understand how they work together, that is a red flag
(<i>"Conjoined Methods"</i>) indicating that the split was probably
a bad idea.</li>
</ul></li>
<li>by dividing its functionality into two separate methods.
<ul class="org-ul">
<li>This makes sense if the original method had an overly complex
interface because it tried to do multiple things that were not
closely related.</li>
<li>Ideally, most callers should only need to invoke one of the
two new methods;
<ul class="org-ul">
<li>if callers must invoke both of the new methods, then that
adds complexity, which makes it less likely that the split
is a good idea.</li>
</ul></li>
<li>The new methods will be more focused in what they do.
<ul class="org-ul">
<li>It is a good sign if the new methods are more
general-purpose than the original method (i.e., you can
imagine using them separately in other situations).</li>
</ul></li>
<li>(This approach) don't make sense very often, because they
result in callers having to deal with multiple methods
instead of one.</li>
<li>When you split this way, you run the risk of ending up with
several shallow methods,</li>
<li>If the caller has to invoke each of the separate methods,
passing state back and forth between them, then splitting is
not a good idea.</li>
<li>judge it based on whether it simplifies things for callers.</li>
<li>A method should not be split if it results in shallow methods,
as in.</li>
</ul></li>
</ol></li>
<li>There are also situations where a system can be made simpler by
joining methods together.
<ul class="org-ul">
<li>it (joining methods) might replace two shallow methods with one
deeper method;</li>
<li>it might eliminate duplication of code;</li>
<li>it might eliminate dependencies between the original methods, or
intermediate data structures;</li>
<li>it might result in better encapsulation, so that knowledge that
was previously present in multiple places is now isolated in a
single place; or</li>
<li>it might result in a simpler interface,</li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgba28e4f" class="outline-4">
<h4 id="orgba28e4f">Red Flag: Conjoined Methods</h4>
<div class="outline-text-4" id="text-orgba28e4f">
<ul class="org-ul">
<li>It should be possible to understand each method independently.</li>
<li>If you can't understand the implementation of one method without
also understanding the implementation of another, that's a red flag.</li>
<li>This red flag can occur in other contexts as well: if two pieces of
code are physically separated, but each can only be understood by
looking at the other, that is a red flag.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgade6301" class="outline-3">
<h3 id="orgade6301">9.9 Conclusion</h3>
<div class="outline-text-3" id="text-orgade6301">
<ul class="org-ul">
<li>The decision to split or join modules should be based on complexity.</li>
<li>Pick the structure that results in
<ul class="org-ul">
<li>the best information hiding,</li>
<li>the fewest dependencies,</li>
<li>the deepest interfaces.</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc62fe20" class="outline-2">
<h2 id="orgc62fe20">10 Define Errors Out Of Existence</h2>
<div class="outline-text-2" id="text-orgc62fe20">
<ul class="org-ul">
<li>Exception handling is one of the worst sources of complexity in
software systems.
<ul class="org-ul">
<li>Code that deals with special conditions is inherently harder to
write than code that deals with normal cases,</li>
<li>developers often define exceptions without considering how they
will be handled.</li>
</ul></li>
<li>This chapter discusses
<ul class="org-ul">
<li>why exceptions contribute disproportionately to complexity</li>
<li>how to simplify exception handling</li>
</ul></li>
<li>The key overall lesson from this chapter is to <b>reduce the number of
places where exceptions must be handled</b>;
<ul class="org-ul">
<li>in many cases the semantics of operations can be modified so that
the normal behavior handles all situations and there is no
exceptional condition to report (hence the title of this chapter).</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org530df5b" class="outline-3">
<h3 id="org530df5b">10.1 Why exceptions add complexity</h3>
<div class="outline-text-3" id="text-org530df5b">
<ul class="org-ul">
<li><i>exception</i>: any uncommon condition that alters the normal flow of
control in a program.
<ul class="org-ul">
<li>Formal exception mechanism (try-catch)</li>
<li>Informal exception mechanism (returning special values)</li>
</ul></li>
<li>When an exception occurs, the programmer can deal with it in two
ways, each of which can be complicated.
<ol class="org-ol">
<li>move forward and complete the work in progress in spite of the
exception.</li>
<li>abort the operation in progress and report the exception upwards.
<ul class="org-ul">
<li>aborting can be complicated because the exception may have
occurred at a point where system state is inconsistent</li>
<li>the exception handling code must restore consistency, such as
by unwinding any changes made before the exception occurred.</li>
</ul></li>
</ol></li>
<li>Furthermore, exception handling code creates opportunities for more
exceptions.
<ul class="org-ul">
<li>Secondary exceptions occurring during recovery are often more
subtle and complex than the primary exceptions.</li>
<li>To prevent an unending cascade of exceptions, the developer must
eventually find a way to handle exceptions without introducing
more exceptions.</li>
</ul></li>
<li>Language support for exceptions tends to be verbose and clunky,
which makes exception handling code hard to read.</li>
<li>It’s difficult to ensure that exception handling code really works.
<ul class="org-ul">
<li>Some exceptions, such as I/O errors, can’t easily be generated in
a test environment, so it’s hard to test the code that handles
them.</li>
<li>Exceptions don’t occur very often in running systems, so exception
handling code rarely executes.
<ul class="org-ul">
<li>Bugs can go undetected for a long time, and when the exception
handling code is finally needed, there’s a good chance that it
won’t work</li>
<li>“code that hasn’t been executed doesn’t work”</li>
<li>When exception handling code fails, it’s difficult to debug the
problem, since it occurs so infrequently.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org25e7ea2" class="outline-3">
<h3 id="org25e7ea2">10.2 Too many exceptions</h3>
<div class="outline-text-3" id="text-org25e7ea2">
<ul class="org-ul">
<li>Programmers exacerbate the problems related to exception handling by
<b>defining unnecessary exceptions</b>.
<ul class="org-ul">
<li>Most programmers are taught that it’s important to detect and
report errors; they often interpret this to mean “the more errors
detected, the better.”</li>
<li>This leads to an over-defensive style where anything that looks
even a bit suspicious is rejected with an exception, which results
in a proliferation of unnecessary exceptions that increase the
complexity of the system.</li>
</ul></li>
<li>It’s tempting to use exceptions to avoid dealing with difficult
situations: rather than figuring out a clean way to handle it, just
throw an exception and punt the problem to the caller.
<ul class="org-ul">
<li>if you are having trouble figuring out what to do for the
particular situation, there’s a good chance that the caller won’t
know what to do either.</li>
<li>The exceptions thrown by a class are part of its interface;
classes with lots of exceptions have complex interfaces, and they
are shallower than classes with fewer exceptions.</li>
<li>It can propagate up through several stack levels before being
caught, so it affects not just the method’s caller, but
potentially also higher-level callers (and their interfaces).</li>
</ul></li>
<li>Throwing exceptions is easy; handling them is hard.
<ul class="org-ul">
<li>The best way to reduce the complexity damage caused by exception
handling is to <b>reduce the number of places where exceptions have
to be handled</b>.</li>
<li>The rest of this chapter will discuss four techniques for reducing
the number of exception handlers.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd2cab10" class="outline-3">
<h3 id="orgd2cab10">10.3 Define errors out of existence</h3>
<div class="outline-text-3" id="text-orgd2cab10">
<ul class="org-ul">
<li>The best way to eliminate exception handling complexity is to define
your APIs so that there are no exceptions to handle: define errors
out of existence.</li>
<li>I should have changed the definition of <code>unset</code> slightly: rather
than deleting a variable, unset should ensure that a variable no
longer exists.</li>
</ul>
</div>
<div id="outline-container-org5ad55c4" class="outline-4">
<h4 id="org5ad55c4">10.4 Example: file deletion in Windows</h4>
<div class="outline-text-4" id="text-org5ad55c4">
<ul class="org-ul">
<li>Delaying the file deletion defines errors out of existence.</li>
</ul>
</div>
</div>
<div id="outline-container-orga42e283" class="outline-4">
<h4 id="orga42e283">10.5 Example: Java substring method</h4>
<div class="outline-text-4" id="text-orga42e283">
<ul class="org-ul">
<li>If errors are defined out of existence, won’t that result in buggier software?
<ul class="org-ul">
<li>The error-ful approach may catch some bugs, but it also increases
complexity, which results in other bugs.
<ul class="org-ul">
<li>In the error-ful approach, developers must write additional code
to avoid or ignore the errors, and this increases the likelihood
of bugs</li>
<li>or, they may forget to write the additional code, in which case
unexpected errors may be thrown at runtime</li>
</ul></li>
<li>In contrast, defining errors out of existence simplifies APIs and
it reduces the amount of code that must be written.</li>
</ul></li>
<li><b>Overall, the best way to reduce bugs is to make software simpler.</b></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgbdee626" class="outline-3">
<h3 id="orgbdee626">10.6 Mask exceptions</h3>
<div class="outline-text-3" id="text-orgbdee626">
<ul class="org-ul">
<li>With this approach (<i>exception masking</i>), an exceptional condition
is detected and handled at a low level in the system, so that higher
levels of software need not be aware of the condition</li>
<li>Exception masking doesn’t work in all situations, but it is a
powerful tool in the situations where it works.
<ul class="org-ul">
<li>It results in deeper classes, since
<ol class="org-ol">
<li>it reduces the class’s interface (fewer exceptions for users to
be aware of)</li>
<li>adds functionality in the form of the code that masks the
exception.</li>
</ol></li>
<li>Exception masking is an example of pulling complexity downward.
(<i>8 Pull Complexity Downwards</i>)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge29d90a" class="outline-3">
<h3 id="orge29d90a">10.7 Exception aggregation</h3>
<div class="outline-text-3" id="text-orge29d90a">
<ul class="org-ul">
<li>The idea behind <i>exception aggregation</i> is to handle many exceptions
with a single piece of code;
<ul class="org-ul">
<li>rather than writing distinct handlers for many individual
exceptions,</li>
<li>handle them all in one place with a single handler.</li>
</ul></li>
<li>A generally-useful design pattern for exception handling.
<ul class="org-ul">
<li>If a system processes a series of requests, it’s useful to define an
exception that aborts the current request, cleans up the system’s
state, and continues with the next request.</li>
<li>The exception is caught in a single place near the top of the
system’s request-handling loop.</li>
<li>This exception can be thrown at any point in the processing of a
request to abort the request; different subclasses of the
exception can be defined for different conditions.</li>
<li><b>Exceptions of this type should be clearly distinguished from
exceptions that are fatal to the entire system.</b></li>
</ul></li>
<li>Exception aggregation works best <b>if an exception propagates several
levels up the stack before it is handled;</b>
<ul class="org-ul">
<li>this allows more exceptions from more methods to be handled in the
same place.</li>
<li>This is the opposite of exception masking:
<ul class="org-ul">
<li>masking usually works best if an exception is handled in a
low-level method.</li>
<li>For masking, the low-level method is typically a library method
used by many other methods, so allowing the exception to
propagate would increase the number of places where it is
handled</li>
</ul></li>
</ul></li>
<li>One way of thinking about exception aggregation is that it replaces
several special-purpose mechanisms, each tailored for a particular
situation, with a single <b>general-purpose mechanism</b> that can handle
multiple situations</li>
</ul>
</div>
</div>
<div id="outline-container-org4a79e5b" class="outline-3">
<h3 id="org4a79e5b">10.8 Just crash?</h3>
<div class="outline-text-3" id="text-org4a79e5b">
<ul class="org-ul">
<li>In most applications there will be certain errors that it’s not
worth trying to handle.
<ol class="org-ol">
<li>difficult or impossible to handle</li>
<li>don’t occur very often</li>
</ol></li>
<li>Whether or not it is acceptable to crash on a particular error
depends on the application.</li>
</ul>
</div>
</div>
<div id="outline-container-org7d53fec" class="outline-3">
<h3 id="org7d53fec">10.9 Design special cases out of existence</h3>
<div class="outline-text-3" id="text-org7d53fec">
<ul class="org-ul">
<li>For the same reason that it makes sense to <i>define errors out of
existence</i>, it also makes sense to define other special cases out of
existence
<ul class="org-ul">
<li>Special cases can result in code that is riddled with if
statements, which make the code hard to understand and lead to
bugs.</li>
<li>The best way to do this is by <b>designing the normal case in a way
that automatically handles the special cases</b> without any extra
code.</li>
</ul></li>
<li><p>
<i>7 Different Layer, Different Abstraction</i>
</p>
<pre class="example">
The notion of “no selection” makes sense in terms of how the user
thinks about the application’s interface, but that doesn’t mean it has
to be represented explicitly inside the application. Having a
selection that always exists, but is sometimes empty and thus
invisible, results in a simpler implementation.
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-org4835b88" class="outline-3">
<h3 id="org4835b88">10.10 Taking it too far</h3>
<div class="outline-text-3" id="text-org4835b88">
<ul class="org-ul">
<li>Defining away exceptions, or masking them inside a module, only
makes sense <b>if the exception information isn’t needed outside the
module.</b>
<ul class="org-ul">
<li>in the rare situations where a caller cares about the special
cases detected by the exceptions, there are other ways for it to
get this information.</li>
</ul></li>
<li>With exceptions, as with many other areas in software design, you
must <b>determine what is important and what is not important</b>.
<ul class="org-ul">
<li>Things that are not important should be hidden, and the more of
them the better.</li>
<li>But when something is important, it must be exposed.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3173f89" class="outline-3">
<h3 id="org3173f89">10.11 Conclusion</h3>
<div class="outline-text-3" id="text-org3173f89">
<ul class="org-ul">
<li>Together, these techniques can have a significant impact on overall
system complexity.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgab74cb5" class="outline-2">
<h2 id="orgab74cb5">11 Design it Twice</h2>
<div class="outline-text-2" id="text-orgab74cb5">
<ul class="org-ul">
<li>Designing software is hard, so it’s unlikely that your first
thoughts about how to structure a module or system will produce
the best design.
<ul class="org-ul">
<li>You’ll end up with a much better result if you consider multiple
options for each major design decision: design it twice.</li>
<li><b>You don’t need to pin down every feature of each alternative;</b> it’s
sufficient at this point to sketch out a few of the most important
methods.</li>
<li>Try to pick approaches that are radically different from each other;
you’ll learn more that way.
<ul class="org-ul">
<li>Even if you are certain that there is only one reasonable
approach, consider a second design anyway, no matter how bad you
think it will be.</li>
<li>It will be instructive to think about the weaknesses of that
design and contrast them with the features of other designs.</li>
</ul></li>
<li>After you have roughed out the designs for the alternatives, make a
list of the pros and cons of each one.
<ul class="org-ul">
<li>The most important consideration for an interface is ease of use
for higher level software.</li>
<li>It is also worth considering other factors:
<ul class="org-ul">
<li>Does one alternative have a simpler interface than another?</li>
<li>Is one interface more general-purpose than another?</li>
<li>Does one interface enable a more efficient implementation than
another?</li>
</ul></li>
</ul></li>
<li>Once you have compared alternative designs, you will be in a better
position to identify the best design.
<ul class="org-ul">
<li>The best choice may be one of the alternatives,</li>
<li>or you may discover that you can combine features of multiple
alternatives into a new design that is better than any of the
original choices.</li>
</ul></li>
<li>Sometimes none of the alternatives is particularly attractive; when
this happens, see if you can come up with additional schemes
<ul class="org-ul">
<li>Use the problems you identified with the original alternatives to
drive the new design(s)</li>
</ul></li>
</ul></li>
<li>The design-it-twice principle can be applied at many levels in a
system</li>
<li>Designing it twice does not need to take a lot of extra time
<ul class="org-ul">
<li>The initial design experiments will probably result in a
significantly better design, which will more than pay for the time
spent designing it twice.</li>
</ul></li>
<li>The design-it-twice principle is sometimes hard for really smart
people to embrace.
<ul class="org-ul">
<li>if you want to get really great results, you have to consider a
second possibility, or perhaps a third, no matter how smart you
are.</li>
<li>The design of large software systems falls in this category:
<b>no-one is good enough to get it right with their first try.</b></li>
<li>It isn’t that you aren’t smart; it’s that the problems are really
hard</li>
<li>Furthermore, that's a good thing: <b>it’s much more fun to work on a
difficult problem where you have to think carefully</b>, rather than
an easy problem where you don’t have to think at all.</li>
</ul></li>
<li>The design-it-twice approach not only improves your designs, but it
also improves your design skills.
<ul class="org-ul">
<li>The process of devising and comparing multiple approaches will
teach you about the factors that make designs better or worse.</li>
<li>Over time, this will make it easier for you to rule out bad
designs and hone in on really great ones.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4e1aa1d" class="outline-2">
<h2 id="org4e1aa1d">12 Why Write Comments? The Four Excuses</h2>
<div class="outline-text-2" id="text-org4e1aa1d">
<ul class="org-ul">
<li>In-code documentation plays a crucial role in software design.
<ul class="org-ul">
<li>Comments are essential to help developers understand a system and
work efficiently,</li>
<li>Documentation also plays an important role in abstraction; without
comments, you can't hide complexity.</li>
<li>the process of writing comments, if done correctly, will actually
improve a system's design.</li>
</ul></li>
<li>I hope these chapters will convince you of three things:
<ol class="org-ol">
<li>good comments can make a big difference in the overall quality of
software;</li>
<li>it isn't hard to write good comments;</li>
<li>(this may be hard to believe) writing comments can actually be
fun.</li>
</ol></li>
</ul>
</div>
<div id="outline-container-org0b6bda1" class="outline-3">
<h3 id="org0b6bda1">12.1 Good code is self-documenting</h3>
<div class="outline-text-3" id="text-org0b6bda1">
<ul class="org-ul">
<li>Nonetheless, there is still a significant amount of design
information that can't be represented in code.
<ul class="org-ul">
<li>The informal aspects of an interface, such as a high-level
description of what each method does or the meaning of its result,
can only be described in comments.</li>
<li>the rationale for a particular design decision,</li>
<li>the conditions under which it makes sense to call a particular
method.</li>
</ul></li>
<li>Some developers argue that if others want to know what a method
does, they should just read the code of the method: this will be
more accurate than any comment.
<ul class="org-ul">
<li>It's possible that a reader could deduce the abstract interface of
the method by reading its code, but it would be time-consuming and
painful.</li>
<li>In addition, if you write code with the expectation that users
will read method implementations, you will try to make each method
as short as possible, so that it's easy to read. If the method
does anything nontrivial, you will break it up into several
smaller methods. This will result in a large number of shallow
methods.</li>
<li>Furthermore, it doesn't really make the code easier to read: in
order to understand the behavior of the top-level method, readers
will probably need to understand the behaviors of the nested
methods.</li>
<li>For large systems it isn't practical for users to read the code to
learn the behavior.</li>
</ul></li>
<li>Moreover, comments are fundamental to abstractions.
<ul class="org-ul">
<li>If users must read the code of a method in order to use it, then
there is no abstraction:</li>
<li>Without comments, the only abstraction of a method is its
declaration, which specifies its name and the names and types of
its arguments and results.</li>
<li>The declaration is missing too much essential information to
provide a useful abstraction by itself.</li>
<li>Comments allow us to capture the additional information that
callers need, thereby completing the simplified view while hiding
implementation details.</li>
<li>It's also important that comments are written in a human language
such as English; this makes them less precise than code, but it
provides more expressive power, so we can create simple, intuitive
descriptions.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgcbabf50" class="outline-3">
<h3 id="orgcbabf50">12.2 I don't have time to write comments</h3>
<div class="outline-text-3" id="text-orgcbabf50">
<ul class="org-ul">
<li>However, software projects are almost always under time pressure,
and there will always be things that seem higher priority than
writing comments.</li>
<li>Thus, if you allow documentation to be de-prioritized, you'll end up
with no documentation.</li>
<li>The counter-argument to this excuse is the investment mindset
<ul class="org-ul">
<li>If you want a clean software structure, which will allow you to
work efficiently over the long-term, then you must take some extra
time up front in order to create that structure.</li>
</ul></li>
<li>Furthermore, writing comments needn't take a lot of time.</li>
<li>Furthermore, many of the most important comments are those related
to abstractions, such as the top-level documentation for classes and
methods.
<ul class="org-ul">
<li>these comments should be written as part of the design process,
(chapter 15)</li>
<li>the act of writing the documentation serves as an important design
tool that improves the overall design. These comments pay for
themselves immediately.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org96da643" class="outline-3">
<h3 id="org96da643">12.3 Comments get out of date and become misleading</h3>
<div class="outline-text-3" id="text-org96da643">
<ul class="org-ul">
<li>Keeping documentation up-to-date does not require an enormous
effort.
<ul class="org-ul">
<li>Chapter 16 discusses how to organize documentation so that it is
as easy as possible to keep it updated after code modifications</li>
<li>(the key ideas are to avoid duplicated documentation and keep the
documentation close to the corresponding code).</li>
</ul></li>
<li>Large changes to the documentation are only required if there have
been large changes to the code, and the code changes will take more
time than the documentation changes.</li>
<li>Code reviews provide a great mechanism for detecting and fixing
stale comments.</li>
</ul>
</div>
</div>
<div id="outline-container-org2cbed86" class="outline-3">
<h3 id="org2cbed86">12.4 All the comments I have seen are worthless</h3>
<div class="outline-text-3" id="text-org2cbed86">
<ul class="org-ul">
<li>writing solid documentation is not hard, once you know how.</li>
<li>The next chapters will lay out a framework for how to write good
documentation and maintain it over time.</li>
</ul>
</div>
</div>
<div id="outline-container-org5232fcc" class="outline-3">
<h3 id="org5232fcc">12.5 Benefits of well-written comments</h3>
<div class="outline-text-3" id="text-org5232fcc">
<ul class="org-ul">
<li>The overall idea behind comments is to capture information that was
in the mind of the designer but couldn't be represented in the code.
<ul class="org-ul">
<li>When other developers come along later to make modifications, the
comments will allow them to work more quickly and accurately.</li>
<li>Without documentation, future developers will have to rederive or
guess at the developer's original knowledge;
<ul class="org-ul">
<li>this will take additional time,</li>
<li>and there is a risk of bugs if the new developer misunderstands
the original designer's intentions.</li>
</ul></li>
</ul></li>
<li>Comments are valuable even when the original designer is the one
making the changes: if it has been more than a few weeks since you
last worked in a piece of code, you will have forgotten many of the
details of the original design.</li>
<li>Good documentation helps with the last two of these issues
(describes in chapter 2)
<ul class="org-ul">
<li>Documentation can reduce cognitive load by providing developers
with the information they need to make changes and by making it
easy for developers to ignore information that is irrelevant.</li>
<li>Documentation can also reduce the unknown unknowns by clarifying
the structure of the system, so that it is clear what information
and code is relevant for any given change.</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org94aa247" class="outline-2">
<h2 id="org94aa247">13 Comments Should Describe Things that Aren't Obvious from the Code</h2>
<div class="outline-text-2" id="text-org94aa247">
<ul class="org-ul">
<li>The reason for writing comments is that
<ol class="org-ol">
<li>statements in a programming language can't capture all of the
important information that was in the mind of the developer when
the code was written.</li>
<li>Comments record this information so that developers who come along
later can easily understand and modify the code.</li>
<li>The guiding principle for comments is that comments should
describe things that aren't obvious from the code.</li>
</ol></li>
<li>There are many things that aren't obvious from the code.
<ul class="org-ul">
<li>low-level details</li>
<li>Why code is needed</li>
<li>Why it was implemented in a particular way</li>
<li>Rules the developer followed</li>
</ul></li>
<li>One of the most important reasons for comments is abstractions,
which include a lot of information that isn't obvious from the code.
<ul class="org-ul">
<li>The idea of an abstraction is to provide a simple way of thinking
about something,</li>
<li>but code is so detailed that it can be hard to see the abstraction
just from reading the code.</li>
<li>Developers should be able to understand the abstraction provided
by a module <b>without reading any code other than its externally
visible declarations</b>.</li>
<li>The only way to do this is by supplementing the declarations with
comments.</li>
</ul></li>
<li>This chapter discusses
<ul class="org-ul">
<li>what information needs to be described in comments</li>
<li>how to write good comments.</li>
</ul></li>
<li>As you will see, good comments typically <b>explain things at a
different level of detail than the code</b>, which is
<ul class="org-ul">
<li>more detailed in some situations</li>
<li>less detailed (more abstract) in others.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgb250138" class="outline-3">
<h3 id="orgb250138">13.1 Pick conventions</h3>
<div class="outline-text-3" id="text-orgb250138">
<ul class="org-ul">
<li>conventions for commenting, such as
<ul class="org-ul">
<li>what you will comment</li>
<li>the format you will use for comments.</li>
</ul></li>
<li>If you are programming in a language for which there exists a
document compilation tool,
<ul class="org-ul">
<li>follow the conventions of the tools.</li>
<li>None of these conventions is perfect,</li>
<li>but the tools provide enough benefits to make up for that.</li>
</ul></li>
<li>If you are programming in an environment where there are no existing
conventions to follow,
<ul class="org-ul">
<li>try to adopt the conventions from some other language or project
that is similar;</li>
<li>this will make it easier for other developers to understand and
adhere to your conventions.</li>
</ul></li>
<li>Conventions serve two purposes.
<ol class="org-ol">
<li>they ensure consistency,
<ul class="org-ul">
<li>which makes comments easier to read and understand.</li>
</ul></li>
<li>they help to ensure that you actually write comments.
<ul class="org-ul">
<li>If you don't have a clear idea what you are going to comment
and how, it's easy to end up writing no comments at all.</li>
</ul></li>
</ol></li>
<li>Most comments fall into one of the following categories:
<dl class="org-dl">
<dt><a id="orgfc26b94"></a></dt><dd>a comment block that immediately precedes the declaration of a
module such as a class, data structure, function, or method.
The comment describe's the module's interface.
<ul class="org-ul">
<li>For a class, the comment describes the overall abstraction
provided by the class.</li>
<li>For a method or function, the comment describes its overall
behavior, its arguments and return value, if any, any side
effects or exceptions that it generates, and any other
requirements the caller must satisfy before invoking the method.</li>
</ul></dd>
<dt><a id="org848d7a4"></a></dt><dd>a comment next to the declaration of a field in a data
structure,</dd>
<dt><a id="org1422d86"></a></dt><dd>a comment inside the code of a method or function, which
describes how the code works internally.</dd>
<dt><a id="org47074f9"></a></dt><dd>a comment describing dependencies that cross module boundaries.</dd>
</dl></li>
<li>The most important comments are those in the first two
categories. (Interface &amp; Data structure member)
<ul class="org-ul">
<li>Every class should have an interface comment,</li>
<li>every class variable should have a comment,</li>
<li>every method should have an interface comment.</li>
</ul></li>
<li>it is easier to comment everything rather than spend energy worrying
about whether a comment is needed.</li>
<li>Implementation comments are often unnecessary (see Section 13.6
below).</li>
<li>Cross-module comments are the most rare of all and they are
problematic to write, but when they are needed they are quite
important; Section 13.7 discusses them in more detail.</li>
</ul>
</div>
</div>
<div id="outline-container-orgae20215" class="outline-3">
<h3 id="orgae20215">13.2 Don't repeat the code</h3>
<div class="outline-text-3" id="text-orgae20215">
<ul class="org-ul">
<li>many comments are not particularly helpful.
<ul class="org-ul">
<li>The most common reason is that the comments repeat the code:
<ul class="org-ul">
<li>After you have written a comment, ask yourself the following
question: <i>could someone who has never seen the code write the
comment just by looking at the code next to the comment?</i></li>
</ul></li>
<li>Another common mistake is to use the same words in the comment
that appear in the name of the entity being documented:
<ul class="org-ul">
<li>These comments just take the words from the method or variable
name, perhaps add a few words from argument names and types, and
form them into a sentence.</li>
</ul></li>
</ul></li>
<li>A first step towards writing good comments is to *use different
words in the comment from those in the name of the entity being
described*.
<ul class="org-ul">
<li>Pick words for the comment that provide additional information
about the meaning of the entity,</li>
<li>rather than just repeating its name.</li>
</ul></li>
<li><p>
example
</p>
<div class="org-src-container">
<pre class="src src-java">/*
 * The amount of blank space to leave on the left and right sides of
 * each line of text, in pixels.
 */
private static final int textHorizontalPadding = 4;
</pre>
</div>
<ul class="org-ul">
<li>This comment provides additional information that is not obvious
from the declaration itself, such as the units (pixels) and the
fact that padding applies to both sides of each line.</li>
<li>Instead of using the term “padding”, the comment explains what
padding is, in case the reader isn't already familiar with the
term.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org63a9ee6" class="outline-4">
<h4 id="org63a9ee6">Red Flag: Comment Repeats Code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></h4>
<div class="outline-text-4" id="text-org63a9ee6">
<ul class="org-ul">
<li>If the information in a comment is already obvious from the code
next to the comment, then the comment isn't helpful.</li>
<li>One example of this is when the comment uses the same words that
make up the name of the thing it is describing.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc03dff3" class="outline-3">
<h3 id="orgc03dff3">13.3 Lower-level comments add precision</h3>
<div class="outline-text-3" id="text-orgc03dff3">
<ul class="org-ul">
<li><b>Comments augment the code by providing information at a different
level of detail.</b></li>
<li>Different levels of comments
<ul class="org-ul">
<li><a id="orgefe8f6d"></a> add <i>precision</i>
<ul class="org-ul">
<li>by clarifying the exact meaning of the code</li>
</ul></li>
<li><a id="org66ea043"></a> offer <i>intuition</i>
<ul class="org-ul">
<li>the reasoning behind the code</li>
<li>a simpler and more abstract way of thinking about the code</li>
</ul></li>
<li>Comments at the same level as the code are likely to repeat the
code (<i>Red Flag: Comment Repeats Code</i>)</li>
</ul></li>
<li><i>Precision</i> is most useful when commenting variable declarations
<ul class="org-ul">
<li>such as
<ul class="org-ul">
<li>class instance variables</li>
<li>method arguments</li>
<li>return values</li>
</ul></li>
<li>The name and type in a variable declaration are typically not very
precise</li>
<li>Comments can fill in missing details such as:
<ul class="org-ul">
<li>What are the units for this variable?</li>
<li>Are the boundary conditions inclusive or exclusive?</li>
<li>If a null value is permitted, what does it imply?</li>
<li>If a variable refers to a resource that must eventually be freed
or closed, who is responsible for freeing or closing it?</li>
<li>Are there certain properties that are always true for the
variable (invariants), such as “this list always contains at
least one entry”?</li>
</ul></li>
<li>Some of this information could potentially be figured out by
examining all of the code where the variable is used.
<ul class="org-ul">
<li>However, this is time-consuming and error-prone;</li>
<li>the declaration's comment should be clear and complete enough to
make this unnecessary</li>
</ul></li>
<li>When documenting a variable, think <i>nouns</i>, not <i>verbs</i>.
<ul class="org-ul">
<li>Focus on <b>what the variable represents</b>, not how it is
manipulated.</li>
<li>Examples
<ul class="org-ul">
<li><p>
verbs (how it is manipulated)
</p>
<div class="org-src-container">
<pre class="src src-java">/* FOLLOWER VARIABLE: indicator variable that allows the Receiver and
 * the PeriodicTasks thread to communicate about whether a heartbeat
 * has been received within the follower's election timeout window.
 * Toggled to TRUE when a valid heartbeat is received.
 * Toggled to FALSE when the election timeout window is reset. */
private boolean receivedValidHeartbeat;
</pre>
</div></li>
<li><p>
nouns (what it represents)
</p>
<div class="org-src-container">
<pre class="src src-java">/* True means that a heartbeat has been received since the last time
 * the election timer was reset. Used for communication between the
 * Receiver and PeriodicTasks threads. */
private boolean receivedValidHeartbeat;
</pre>
</div></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3152093" class="outline-3">
<h3 id="org3152093">13.4 Higher-level comments enhance intuition</h3>
<div class="outline-text-3" id="text-org3152093">
<ul class="org-ul">
<li>They omit details and help the reader to understand the overall
intent and structure of the code.</li>
<li>This approach is commonly used for comments inside methods, and for
interface comments.</li>
<li>Higher-level comments are more difficult to write than lower-level
comments because <b>you must think about the code in a different way</b>.</li>
<li>Ask yourself:
<ul class="org-ul">
<li>What is this code trying to do?</li>
<li>What is the simplest thing you can say that explains everything in
the code?</li>
<li>What is the most important thing about this code?</li>
</ul></li>
<li>Engineers tend to be very detail-oriented.
<ul class="org-ul">
<li>We love details and are good at managing lots of them; this is
essential for being a good engineer.</li>
<li>But, great software designers can also step back from the details
and think about a system at a higher level.
<ul class="org-ul">
<li>This means
<ol class="org-ol">
<li>deciding which aspects of the system are most important,</li>
<li>and being able to ignore the low-level details and think
about the system only in terms of its most fundamental
characteristics</li>
</ol></li>
<li>This is the essence of abstraction (finding a simple way to
think about a complex entity),</li>
<li>And it's also what you must do when writing higher-level
comments.</li>
</ul></li>
</ul></li>
<li>A good higher-level comment expresses one or a few simple ideas that
<b>provide a conceptual framework,</b>
<ul class="org-ul">
<li>Given the framework, it becomes easy to see how specific code
statements relate to the overall goal.</li>
</ul></li>
<li>Comments of the form "how we get here" are very useful for helping
people to understand code.
<ul class="org-ul">
<li>it explains (in high level terms) <i>why</i> the code is executed.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7b2e259" class="outline-3">
<h3 id="org7b2e259">13.5 Interface documentation</h3>
<div class="outline-text-3" id="text-org7b2e259">
<ul class="org-ul">
<li>One of the most important roles for comments is to <b>define
abstractions</b>
<ul class="org-ul">
<li><i>4.3 Abstractions</i></li>
<li>Code isn't suitable for describing abstractions
<ol class="org-ol">
<li>it's too low level</li>
<li>it includes implementation details that shouldn't be visible in
the abstraction</li>
</ol></li>
<li>If you want code that presents good abstractions, you must
document those abstractions with comments.</li>
</ul></li>
<li>The first step in documenting abstractions is to separate <i>interface
comments</i> from <i>implementation comments</i>.
<ul class="org-ul">
<li>Differences
<ul class="org-ul">
<li>Interface comments provide information that someone needs to
know in order to use a class or method; they define the
abstraction.</li>
<li>Implementation comments describe how a class or method works
internally in order to implement the abstraction.</li>
</ul></li>
<li><b>If interface comments must also describe the implementation, then
the class or method is shallow.</b>
<ul class="org-ul">
<li>The act of writing comments can provide clues about the quality of
a design</li>
<li>(<i>15.3 Comments are a design tool</i>)</li>
</ul></li>
<li>The interface comment for a method includes both <a href="clippings-from-a-philosophy-of-software-design.html#MissingReference">higher-level
information</a> for abstraction and <a href="clippings-from-a-philosophy-of-software-design.html#MissingReference">lower-level details</a> for precision
<ul class="org-ul">
<li>The comment usually starts with a sentence or two describing the
behavior of the method as perceived by callers; this is the
higher-level abstraction.</li>
<li>The comment must describe each argument and the return value (if
any). These comments must be very precise, and must describe any
constraints on argument values as well as dependencies between
arguments.</li>
<li>If the method has any side effects, these must be documented in
the interface comment.</li>
<li>A method's interface comment must describe any exceptions that
can emanate from the method.</li>
<li>If there are any preconditions that must be satisfied before a
method is invoked, these must be described. It is a good idea to
minimize preconditions, but any that remain must be documented.</li>
</ul></li>
<li><b>It can be helpful to have examples in the class documentation
that illustrate how its methods work together</b>, particularly for
deep classes with usage patterns that are non-obvious.</li>
<li>Some of the implementation documentation is useful, but it should
go inside the method, where it will be clearly separated from
interface documentation</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgbb81e6f" class="outline-4">
<h4 id="orgbb81e6f">Red Flag: Implementation Documentation Contaminates Interface&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></h4>
<div class="outline-text-4" id="text-orgbb81e6f">
<p>
This red flag occurs when interface documentation, such as that for a
method, describes implementation details that aren't needed in order
to use the thing being documented.
</p>
</div>
</div>
</div>
<div id="outline-container-orga03be36" class="outline-3">
<h3 id="orga03be36">13.6 Implementation comments: what and why, not how</h3>
<div class="outline-text-3" id="text-orga03be36">
<ul class="org-ul">
<li>Most methods are so short and simple that they don't need any
implementation comments: given the code and the interface comments,
it's easy to figure out how a method works</li>
<li>The main goal of implementation comments is to <b>help readers
understand what the code is doing</b> (not how it does it).</li>
<li>In addition to describing what the code is doing, implementation
comments are also useful to explain <i>why</i>.</li>
<li>For longer methods, it can be helpful to write comments for a few of
the most important local variables. However, most local variables
don't need documentation if they have good names.</li>
<li>If the variable is used over a large span of code, then you should
consider adding a comment to describe the variable. When documenting
variables, focus on <i>what</i> the variable represents, not how it is
manipulated in the code.</li>
</ul>
</div>
</div>
<div id="outline-container-orgf322738" class="outline-3">
<h3 id="orgf322738">13.7 Cross-module design decisions</h3>
<div class="outline-text-3" id="text-orgf322738">
<ul class="org-ul">
<li>The biggest challenge with cross-module documentation is finding a
place to put it where it will naturally be discovered by developers.
<ul class="org-ul">
<li>Sometimes there is an obvious central place to put such
documentation.</li>
<li>Unfortunately, in many cases there is not an obvious central place
to put cross-module documentation
<ul class="org-ul">
<li>One possibility is to duplicate parts of the documentation in
each location that depends on it. However, this is awkward, and
it is difficult to keep such documentation up to date as the
system evolves</li>
<li>Alternatively, the documentation can be located in one of the
places where it is needed, but in this case it's unlikely that
developers will see the documentation or know where to look for
it.</li>
<li>I have recently been experimenting with an approach where
cross-module issues are documented in a central file called
<code>designNotes</code>.
<ul class="org-ul">
<li>The file is divided up into clearly labeled sections, one for
each major topic.</li>
<li>Then, in any piece of code that relates to one of these issues
there is a short comment referring to the designNotes file:</li>
<li>However, this has the disadvantage that the documentation is
not near any of the pieces of code that depend on it, so it
may be difficult to keep up-to-date as the system evolves.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org38979cd" class="outline-3">
<h3 id="org38979cd">13.8 Conclusion</h3>
<div class="outline-text-3" id="text-org38979cd">
<ul class="org-ul">
<li>The goal of comments is to ensure that the structure and behavior of
the system is obvious to readers, so they can quickly find the
information they need and make modifications to the system with
confidence that they will work.
<ul class="org-ul">
<li>Some of this information can be represented in the code in a way
that will already be obvious to readers, but there is a
significant amount of information that can't easily be deduced
from the code.</li>
<li>Comments fill in this information.</li>
</ul></li>
<li>When writing comments, <b>try to put yourself in the mindset of the
reader</b> and ask yourself what are the key things he or she will need
to know</li>
<li>If your code is undergoing review and a reviewer tells you that
something is not obvious,
<ul class="org-ul">
<li>don't argue with them; if a reader thinks it's not obvious, then
it's not obvious.</li>
<li>Instead of arguing, try to understand what they found confusing
and see if you can clarify that, either with better comments or
better code.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5a334aa" class="outline-3">
<h3 id="org5a334aa">13.9 Answers to questions from Section 13.5</h3>
</div>
</div>
<div id="outline-container-org04d11c7" class="outline-2">
<h2 id="org04d11c7">14 Choosing Names</h2>
<div class="outline-text-2" id="text-org04d11c7">
<ul class="org-ul">
<li>Good names are a form of documentation:
<ul class="org-ul">
<li>they make code easier to understand.</li>
<li>They reduce the need for other documentation and make it easier to
detect errors.</li>
</ul></li>
<li>Conversely, poor name choices
<ul class="org-ul">
<li>increase the complexity of code</li>
<li>create ambiguities and misunderstandings that can result in bugs.</li>
</ul></li>
<li>Name choice is an example of the principle that complexity is
incremental.
<ul class="org-ul">
<li>Choosing a mediocre name for a particular variable, as opposed to
the best possible name, probably won’t have much impact on the
overall complexity of a system.</li>
<li>However, software systems have thousands of variables; choosing
good names for all of these will have a significant impact on
complexity and manageability.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgf9a274f" class="outline-3">
<h3 id="orgf9a274f">14.1 Example: bad names cause bugs</h3>
<div class="outline-text-3" id="text-orgf9a274f">
<ul class="org-ul">
<li>The problem was actually quite simple (as are most bugs, once you
figure them out).</li>
<li>It took a long process of instrumentation, which eventually showed
that the corruption must be happening in a particular statement,
before I was able to get past the mental block created by the name
and check to see exactly where its value came from.</li>
<li>Unfortunately, most developers don’t spend much time thinking about
names.
<ul class="org-ul">
<li>They tend to use the first name that comes to mind, as long as
it’s reasonably close to matching the thing it names.</li>
</ul></li>
<li>Take a bit of extra time to choose great names, which are <b>precise,
unambiguous, and intuitive.</b>
<ul class="org-ul">
<li>The extra attention will pay for itself quickly,</li>
<li>and over time you’ll learn to choose good names quickly.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org16be545" class="outline-3">
<h3 id="org16be545">14.2 Create an image</h3>
<div class="outline-text-3" id="text-org16be545">
<ul class="org-ul">
<li>When choosing a name, the goal is to <b>create an image in the mind of
the reader about the nature of the thing being named.</b>
<ul class="org-ul">
<li>A good name conveys a lot of information about what the underlying
entity is, and, just as important, what it is not.</li>
<li>When considering a particular name, ask yourself: “If someone sees
this name in isolation, without seeing its declaration, its
documentation, or any code that uses the name, how closely will
they be able to guess what the name refers to? Is there some other
name that will paint a clearer picture?”</li>
</ul></li>
<li>Names are a form of abstraction:
<ul class="org-ul">
<li>they provide a simplified way of thinking about a more complex
underlying entity.</li>
<li>Like other forms of abstraction, the best names are those that
focus attention on what is most important about the underlying
entity while omitting details that are less important.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3518aa1" class="outline-3">
<h3 id="org3518aa1">14.3 Names should be precise</h3>
<div class="outline-text-3" id="text-org3518aa1">
<ul class="org-ul">
<li>Good names have two properties:
<ol class="org-ol">
<li>precision</li>
<li>consistency</li>
</ol></li>
<li>The most common problem with names is that they are too generic or
vague;
<ul class="org-ul">
<li>as a result, it’s hard for readers to tell what the name refers
to;</li>
<li>the reader may assume that the name refers to something different
from reality,</li>
</ul></li>
<li>Like all rules, the rule about choosing precise names has a few
exceptions.
<ol class="org-ol">
<li>If you can see the entire range of usage of a variable, then the
meaning of the variable will probably be obvious from the code so
you don’t need a long name.</li>
<li>It’s also possible for a name to be too specific,</li>
<li>If you find it difficult to come up with a name for a particular
variable that is precise, intuitive, and not too long, this is a
red flag.
<ul class="org-ul">
<li>It suggests that the variable may not have a clear definition
or purpose.</li>
<li>When this happens, consider alternative factorings.</li>
<li>The process of choosing good names can improve your design by
identifying weaknesses.</li>
</ul></li>
</ol></li>
</ul>
</div>
<div id="outline-container-org7380887" class="outline-4">
<h4 id="org7380887">Red Flag: Vague Name&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></h4>
<div class="outline-text-4" id="text-org7380887">
<ul class="org-ul">
<li>If a variable or method name is broad enough to refer to many
different things, then
<ul class="org-ul">
<li>it doesn’t convey much information to the developer</li>
<li>the underlying entity is more likely to be misused.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org447ca83" class="outline-4">
<h4 id="org447ca83">Red Flag: Hard to Pick Name&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></h4>
<div class="outline-text-4" id="text-org447ca83">
<p>
If it’s hard to find a simple name for a variable or method that
creates a clear image of the underlying object, that’s a hint that the
underlying object may not have a clean design.
</p>
</div>
</div>
</div>
<div id="outline-container-org5e16465" class="outline-3">
<h3 id="org5e16465">14.4 Use names consistently</h3>
<div class="outline-text-3" id="text-org5e16465">
<ul class="org-ul">
<li>In any program there are certain variables that are used over and
over again.</li>
<li>Consistent naming reduces cognitive load in much the same way as
reusing a common class:
<ul class="org-ul">
<li>once the reader has seen the name in one context, they can reuse
their knowledge and instantly make assumptions when they see the
name in a different context.</li>
</ul></li>
<li>Consistency has three requirements:
<ol class="org-ol">
<li>always use the common name for the given purpose</li>
<li>never use the common name for anything other than the given purpose</li>
<li>make sure that the purpose is narrow enough that all variables
with the name have the same behavior</li>
</ol></li>
<li>Sometimes you will need multiple variables that refer to the same
general sort of thing
<ul class="org-ul">
<li>When this happens, use the common name for each variable but add a
distinguishing prefix, such as <code>srcFileBlock</code> and <code>dstFileBlock</code>.</li>
</ul></li>
<li>Loops are another area where consistent naming can help
<ul class="org-ul">
<li>If you use names such as i and j for loop variables, always use i
in outermost loops and j for nested loops.</li>
<li>This allows readers to make instant (safe) assumptions about
what’s happening in the code when they see a given name.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org58f7dda" class="outline-3">
<h3 id="org58f7dda">14.5 A different opinion: Go style guide</h3>
<div class="outline-text-3" id="text-org58f7dda">
<ul class="org-ul">
<li>Some of the developers of the Go language argue that names should be
very short, often only a single character</li>
<li>In a presentation on name choice for Go, Andrew Gerrand states that
“long names obscure what the code does.”</li>
<li>The Go culture encourages the use of the same short name for
multiple different things: ch for character or channel, d for data,
difference, or distance, and so on. To me, ambiguous names like
these are likely to result in confusion and error, just as in the
block example.</li>
<li>Overall, I would argue that <b>readability must be determined by
readers, not writers.</b></li>
<li>Gerrand makes one comment that I agree with: “The greater the
distance between a name’s declaration and its uses, the longer the
name should be.”</li>
</ul>
</div>
</div>
<div id="outline-container-org05ec677" class="outline-3">
<h3 id="org05ec677">14.6 Conclusion</h3>
<div class="outline-text-3" id="text-org05ec677">
<ul class="org-ul">
<li>Well chosen names help to make code more obvious;
<ul class="org-ul">
<li>when someone encounters the variable for the first time, their
first guess about its behavior, made without much thought, will be
correct.</li>
</ul></li>
<li>Choosing good names is an example of the investment mindset
discussed in <i>Chapter 3</i>:
<ul class="org-ul">
<li>if you take a little extra time up front to select good names, it
will be easier for you to work on the code in the future.</li>
<li>In addition, you will be less likely to introduce bugs.</li>
</ul></li>
<li>Developing a skill for naming is also an investment
<ul class="org-ul">
<li>When you first decide to stop settling for mediocre names, you may
find it frustrating and time-consuming to come up with good names.</li>
<li>However, as you get more experience you’ll find that it becomes
easier; eventually, you’ll get to the point where it takes almost
no extra time to choose good names, so you will get the benefits
almost for free.</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf14bd93" class="outline-2">
<h2 id="orgf14bd93">15 Write The Comments First</h2>
<div class="outline-text-2" id="text-orgf14bd93">
<ul class="org-ul">
<li>The best time to write comments is at the beginning of the process,
as you write the code.
<ol class="org-ol">
<li>Writing the comments first makes documentation part of the design
process.</li>
<li>Not only does this produce better documentation, but it also
produces better designs and it makes the process of writing
documentation more enjoyable.</li>
</ol></li>
</ul>
</div>
<div id="outline-container-org7680244" class="outline-3">
<h3 id="org7680244">15.1 Delayed comments are bad comments</h3>
<div class="outline-text-3" id="text-org7680244">
<ol class="org-ol">
<li>Delaying documentation often means that it never gets written at
all. (<a href="http://on-agile.blogspot.com/2007/04/why-you-wont-fix-it-later.html">LeBlanc's Law / On Agile: Why You Won't Fix It Later</a>)
<ul class="org-ul">
<li>Once you start delaying, it's easy to delay a bit more; after
all, the code will be even more stable in a few more weeks.</li>
<li>By the time the code has inarguably stabilized, there is a lot of
it, which means the task of writing documentation has become huge
and even less attractive.</li>
<li>There's never a convenient time to stop for a few days and fill
in all of the missing comments,</li>
<li>it's easy to rationalize that the best thing for the project is
to move on and fix bugs or write the next new feature.</li>
<li>This will create even more undocumented code.</li>
</ul></li>
<li>Even if you do have the self-discipline to go back and write the
comments (and don't fool yourself: you probably don't), the
comments won't be very good.
<ul class="org-ul">
<li>By this time in the process, you have checked out mentally.
<ul class="org-ul">
<li>In your mind, this piece of code is done;</li>
<li>you are eager to move on to your next project.</li>
</ul></li>
<li>You know that writing comments is the right thing to do, but it's
no fun.
<ul class="org-ul">
<li>You just want to get through it as quickly as possible.</li>
<li>Thus, you make a quick pass over the code, adding just enough
comments to look respectable.</li>
</ul></li>
<li>By now, it's been a while since you designed the code, so your
memories of the design process are becoming fuzzy.
<ul class="org-ul">
<li>You look at the code as you are writing the comments, so the
comments repeat the code.</li>
<li>Even if you try to reconstruct the design ideas that aren't
obvious from the code, there will be things you don't remember.</li>
</ul></li>
<li>Thus, the comments are missing some of the most important things
they should describe.</li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-org5279497" class="outline-3">
<h3 id="org5279497">15.2 Write the comments first</h3>
<div class="outline-text-3" id="text-org5279497">
<ul class="org-ul">
<li>A different approach
<ul class="org-ul">
<li>For a new class, I start by writing the class interface comment.</li>
<li>Next, I write interface comments and signatures for the most
important public methods, but I leave the method bodies empty.</li>
<li>I iterate a bit over these comments until the basic structure
feels about right.</li>
<li>At this point I write declarations and comments for the most
important class instance variables in the class.</li>
<li>Finally, I fill in the bodies of the methods, adding
implementation comments as needed.</li>
<li>While writing method bodies, I usually discover the need for
additional methods and instance variables. For each new method I
write the interface comment before the body of the method; for
instance variables I fill in the comment at the same time that I
write the variable declaration.</li>
</ul></li>
<li>The comments-first approach has three benefits.
<ol class="org-ol">
<li>it produces better comments.
<ul class="org-ul">
<li>If you write the comments as you are designing the class, the
key design issues will be fresh in your mind, so it's easy to
record them.</li>
<li>It's better to write the interface comment for each method
before its body, so you can focus on the method's abstraction
and interface without being distracted by its implementation.</li>
<li>During the coding and testing process you will notice and fix
problems with the comments. As a result, the comments improve
over the course of development.</li>
</ul></li>
<li><i>it improves the system design.</i> (The most important)</li>
<li><i>it makes comment-writing more fun.</i></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org5ce02e8" class="outline-3">
<h3 id="org5ce02e8">15.3 Comments are a design tool</h3>
<div class="outline-text-3" id="text-org5ce02e8">
<ul class="org-ul">
<li>Comments provide the only way to fully capture abstractions, and
good abstractions are fundamental to good system design.</li>
<li>If you write comments describing the abstractions at the beginning,
you can <b>review and tune them before writing implementation code</b>.</li>
<li>To write a good comment, you must identify the essence of a variable
or piece of code: what are the most important aspects of this thing?
It's important to do this early in the design process; otherwise you
are just hacking code.</li>
<li>Comments serve as a canary in the coal mine of complexity.
<ul class="org-ul">
<li>If a method or variable requires a long comment, it is a red flag
that you don't have a good abstraction.</li>
<li>The best way to judge the complexity of an interface is from the
comments that describe it.
<ul class="org-ul">
<li>If the interface comment for a method provides all the
information needed to use the method and is also short and
simple, that indicates that the method has a simple interface.</li>
<li>Conversely, if there's no way to describe a method completely
without a long and complicated comment, then the method has a
complex interface.</li>
</ul></li>
<li>You can compare a method's interface comment with the
implementation to get a sense of how deep the method is: if the
interface comment must describe all the major features of the
implementation, then the method is shallow.</li>
<li>The same idea applies to variables: if it takes a long comment to
fully describe a variable, it's a red flag that suggests you may
not have chosen the right variable decomposition.</li>
</ul></li>
<li>Of course, comments are only a good indicator of complexity if they
are complete and clear.</li>
</ul>
</div>
<div id="outline-container-org0acf077" class="outline-4">
<h4 id="org0acf077">Red Flag: Hard to Describe</h4>
<div class="outline-text-4" id="text-org0acf077">
<ul class="org-ul">
<li>The comment that describes a method or variable should be simple and
yet complete.</li>
<li>If you find it difficult to write such a comment, that's an
indicator that there may be a problem with the design of the thing
you are describing.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf656501" class="outline-3">
<h3 id="orgf656501">15.4 Early comments are fun comments</h3>
<div class="outline-text-3" id="text-orgf656501">
<ul class="org-ul">
<li>Finding simple comments is a source of pride.
<ul class="org-ul">
<li>The comments are how I record and test the quality of my design
decisions.</li>
<li>Looking for the design that can be expressed completely and clearly
in the fewest words.</li>
<li>The simpler the comments, the better I feel about my design,</li>
</ul></li>
<li>If you are programming strategically, where your main goal is a
great design rather than just writing code that works, then writing
comments should be fun, since that's how you identify the best
designs.</li>
</ul>
</div>
</div>
<div id="outline-container-orgac5d423" class="outline-3">
<h3 id="orgac5d423">15.5 Are early comments expensive?</h3>
<div class="outline-text-3" id="text-orgac5d423">
<ol class="org-ol">
<li>Even if half of your total code lines are comments, writing comments
probably doesn't account for more than about 5% of your total
development time.
<ul class="org-ul">
<li>Delaying the comments until the end will save only a fraction of
this, which isn't very much.</li>
</ul></li>
<li>Writing the comments first will mean that the abstractions will be
more stable before you start writing code.</li>
</ol>
</div>
</div>
<div id="outline-container-orga8441db" class="outline-3">
<h3 id="orga8441db">15.6 Conclusion</h3>
<div class="outline-text-3" id="text-orga8441db">
<p>
If you haven't ever tried writing the comments first, give it a
try. Stick with it long enough to get used to it. Then think about how
it affects the quality of your comments, the quality of your design,
and your overall enjoyment of software development.
</p>
</div>
</div>
</div>
<div id="outline-container-org8e152da" class="outline-2">
<h2 id="org8e152da">16 Modifying Existing Code</h2>
<div class="outline-text-2" id="text-org8e152da">
<ul class="org-ul">
<li>A large software system develops through a series of evolutionary
stages, where each stage adds new capabilities and modifies existing
modules.
<ul class="org-ul">
<li>This means that a system's design is constantly evolving.</li>
<li>It isn't possible to conceive the right design for a system at the
outset;</li>
<li><b>the design of a mature system is determined more by changes made
during the system's evolution than by any initial conception.</b></li>
</ul></li>
<li>this chapter discusses how to keep complexity from creeping in as
the system evolves.</li>
</ul>
</div>
<div id="outline-container-org6ec9eb0" class="outline-3">
<h3 id="org6ec9eb0">16.1 Stay strategic</h3>
<div class="outline-text-3" id="text-org6ec9eb0">
<ul class="org-ul">
<li>This idea (from chapter 3) also applies when you are modifying
existing code.</li>
<li>Unfortunately, when developers go into existing code to make changes
such as bug fixes or new features, they don't usually think
strategically.
<ul class="org-ul">
<li>A typical mindset is "what is the smallest possible change I can
make that does what I need?"</li>
<li>Sometimes developers justify this because they are not comfortable
with the code being modified; they worry that larger changes carry
a greater risk of introducing new bugs.</li>
<li>However, this results in tactical programming.
<ul class="org-ul">
<li>Each one of these minimal changes introduces a few special
cases, dependencies, or other forms of complexity.</li>
<li>As a result, the system design gets just a bit worse, and the
problems accumulate with each step in the system's evolution.</li>
</ul></li>
</ul></li>
<li>If you want to maintain a clean design for a system, you must take a
strategic approach when modifying existing code.
<ul class="org-ul">
<li>*Ideally, when you have finished with each change, the system will
have the structure it would have had if you had designed it from
the start with that change in mind.*</li>
<li>To achieve this goal,
<ul class="org-ul">
<li>you must resist the temptation to make a quick fix.</li>
<li>Instead, think about whether the current system design is still
the best one, in light of the desired change.</li>
<li>If not, refactor the system so that you end up with the best
possible design.</li>
</ul></li>
</ul></li>
<li>This is also an example of the investment mindset
<ul class="org-ul">
<li>Even if your particular change doesn't require refactoring, you
should still be on the lookout for design imperfections that you
can fix while you're in the code.</li>
<li>Whenever you modify any code, try to find a way to improve the
system design at least a little bit in the process.</li>
<li><b>If you're not making the design better, you are probably making
it worse.</b></li>
</ul></li>
<li>an investment mindset sometimes conflicts with the realities of
commercial software development.
<ul class="org-ul">
<li>Nonetheless, you should resist these compromises as much as
possible.</li>
<li>Ask yourself "Is this the best I can possibly do to create a clean
system design, given my current constraints?"
<ul class="org-ul">
<li>Perhaps there's an alternative approach that would be almost as
clean as the 3-month refactoring but could be done in a couple
of days?</li>
<li>Or, if you can't afford to do a large refactoring now, get your
boss to allocate time for you to come back to it after the
current deadline.</li>
</ul></li>
</ul></li>
<li>Every development organization should plan to spend a small fraction
of its total effort on cleanup and refactoring; this work will pay
for itself over the long run.</li>
</ul>
</div>
</div>
<div id="outline-container-orgb0f30a2" class="outline-3">
<h3 id="orgb0f30a2">16.2 Maintaining comments: keep the comments near the code</h3>
<div class="outline-text-3" id="text-orgb0f30a2">
<ul class="org-ul">
<li>When you change existing code, there's a good chance that the
changes will invalidate some of the existing comments.</li>
<li>with a little discipline and a couple of guiding rules, it's
possible to keep comments up-to-date without a huge effort.</li>
<li>The best way to ensure that comments get updated is to <b>position
them close to the code they describe</b>,
<ul class="org-ul">
<li>so developers will see them when they change the code.</li>
<li>The farther a comment is from its associated code, the less likely
it is that it will be updated properly.</li>
</ul></li>
<li>users should not need to read either code or header files; they
should get their information from documentation compiled by tools
<ul class="org-ul">
<li>Given tools such as these, the documentation should be located in
the place that is most convenient for developers working on the
code.</li>
</ul></li>
<li>When writing implementation comments, don't put all the comments for
an entire method at the top of the method.
<ul class="org-ul">
<li>Spread them out, pushing each comment down to the narrowest scope
that includes all of the code referred to by the comment.</li>
</ul></li>
<li>In general, the farther a comment is from the code it describes, the
more abstract it should be
<ul class="org-ul">
<li>this reduces the likelihood that the comment will be invalidated
by code changes</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd17fcab" class="outline-3">
<h3 id="orgd17fcab">16.3 Comments belong in the code, not the commit log</h3>
<div class="outline-text-3" id="text-orgd17fcab">
<ul class="org-ul">
<li>A common mistake when modifying code is to put detailed information
about the change in the commit message for the source code
repository, but then not to document it in the code.</li>
<li>Although commit messages can be browsed in the future by scanning
the repository's log,
<ul class="org-ul">
<li>a developer who needs the information is unlikely to think of
scanning the repository log.</li>
<li>Even if they do scan the log, it will be tedious to find the right
log message.</li>
</ul></li>
<li>When writing a commit message, ask yourself whether developers will
need to use that information in the future.
<ul class="org-ul">
<li>If so, then document this information in the code.</li>
</ul></li>
<li>If you want to include a copy of this information in the commit
message as well, that's fine, but the most important thing is to get
it in the code.</li>
<li>This illustrates the principle of placing documentation in the place
where developers are most likely to see it; the commit log is rarely
that place.</li>
</ul>
</div>
</div>
<div id="outline-container-org264e2c4" class="outline-3">
<h3 id="org264e2c4">16.4 Maintaining comments: avoid duplication</h3>
<div class="outline-text-3" id="text-org264e2c4">
<ul class="org-ul">
<li>The second technique for keeping comments up to date is to avoid
duplication.</li>
<li>If documentation is duplicated, it is more difficult for developers
to find and update all of the relevant copies.</li>
<li>Instead, try to document each design decision exactly once.
<ul class="org-ul">
<li>If there are multiple places in the code that are affected by a
particular decision, don't repeat the documentation at each of
these points.</li>
<li>Find the most obvious single place to put the documentation.</li>
</ul></li>
<li>If there is no "obvious" single place to put a particular piece of
documentation where developers will find it,
<ul class="org-ul">
<li>create a designNotes file as described in Section 13.7.</li>
<li>Or, pick the best of the available places and put the
documentation there.</li>
<li>In addition, add short comments in the other places that refer to
the central location:
<ul class="org-ul">
<li>If the reference becomes obsolete because the master comment was
moved or deleted, this inconsistency will be self-evident
because developers won't find the comment at the indicated
place; they can use revision control history to find out what
happened to the comment and then update the reference.</li>
<li>In contrast, if the documentation is duplicated and some of the
copies don't get updated, there will be no indication to
developers that they are using stale information.</li>
</ul></li>
</ul></li>
<li>Don't redocument one module's design decisions in another module.
<ul class="org-ul">
<li>don't put comments before a method call that explain what happens
in the called method.</li>
<li>If readers want to know, they should look at the interface
comments for the method.</li>
<li>Good development tools will usually provide this information
automatically,</li>
</ul></li>
<li>If information is already documented someplace outside your program,
don't repeat the documentation inside the program; just reference
the external documentation.</li>
<li>It's important that readers can easily find all the documentation
needed to understand your code, but that doesn't mean you have to
write all of that documentation.</li>
</ul>
</div>
</div>
<div id="outline-container-orge1c0cea" class="outline-3">
<h3 id="orge1c0cea">16.5 Maintaining comments: check the diffs</h3>
<div class="outline-text-3" id="text-orge1c0cea">
<ul class="org-ul">
<li>One good way to make sure documentation stays up to date is to
<ol class="org-ol">
<li>take a few minutes before committing a change to your revision
control system to scan over all the changes for that commit;</li>
<li>make sure that each change is properly reflected in the
documentation.</li>
</ol></li>
<li>These pre-commit scans will also detect several other problems, such
as accidentally leaving debugging code in the system or failing to
fix TODO items.</li>
</ul>
</div>
</div>
<div id="outline-container-org415840b" class="outline-3">
<h3 id="org415840b">16.6 Higher-level comments are easier to maintain</h3>
<div class="outline-text-3" id="text-org415840b">
<ul class="org-ul">
<li>comments are easier to maintain if they are higher-level and more
abstract than the code.</li>
<li>These comments do not reflect the details of the code,
<ul class="org-ul">
<li>so they will not be affected by minor code changes;</li>
<li>only changes in overall behavior will affect these comments.</li>
</ul></li>
<li>in general, the comments that are most useful (they don't simply
repeat the code) are also easiest to maintain.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5e8490e" class="outline-2">
<h2 id="org5e8490e">17 Consistency</h2>
<div class="outline-text-2" id="text-org5e8490e">
<ul class="org-ul">
<li>If a system is consistent, it means that
<ol class="org-ol">
<li>similar things are done in similar ways</li>
<li>dissimilar things are done in different ways</li>
</ol></li>
<li>Consistency creates cognitive leverage: once you have learned how
something is done in one place, you can use that knowledge to
immediately understand other places that use the same approach.</li>
<li>If a system is not implemented in a consistent fashion, developers
must learn about each situation separately. This will take more
time.</li>
<li>Consistency reduces mistakes.
<ul class="org-ul">
<li>If a system is not consistent, two situations may appear the same
when in fact they are different. A developer may see a pattern
that looks familiar and make incorrect assumptions based on
previous encounters with that pattern.</li>
<li>On the other hand, if the system is consistent, assumptions made
based on familiar-looking situations will be safe. Consistency
allows developers to work more quickly with fewer mistakes.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org0b84cd2" class="outline-3">
<h3 id="org0b84cd2">17.1 Examples of consistency</h3>
<div class="outline-text-3" id="text-org0b84cd2">
<ul class="org-ul">
<li>Consistency can be applied at many levels in a system;
<ul class="org-ul">
<li>Names</li>
<li>Coding style</li>
<li>Interfaces</li>
<li>Design patterns</li>
<li>Invariants</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf45f1c7" class="outline-3">
<h3 id="orgf45f1c7">17.2 Ensuring consistency</h3>
<div class="outline-text-3" id="text-orgf45f1c7">
<ul class="org-ul">
<li>consistency is hard to maintain</li>
<li>A few tips for establishing and maintaining consistency
<ul class="org-ul">
<li>Document
<ul class="org-ul">
<li>Create a document that lists the most important overall
conventions</li>
<li>Place the document in a spot where developers are likely to see
it</li>
<li>Encourage new people joining the group to read the document</li>
<li>Encourage existing people to review it every once in a while</li>
<li>For conventions that are more localized, find an appropriate
spot in the code to document them</li>
</ul></li>
<li>Enforce
<ul class="org-ul">
<li>The best way to enforce conventions is to write a tool that
checks for violations
<ul class="org-ul">
<li>Make sure that code cannot be committed to the repository
unless it passes the checker</li>
</ul></li>
<li>Code reviews provide another opportunity for enforcing
conventions and for educating new developers about the
conventions
<ul class="org-ul">
<li>The more nit-picky that code reviewers are, the more quickly
everyone on the team will learn the conventions, and the
cleaner the code will be</li>
</ul></li>
</ul></li>
<li>When in Rome
<ul class="org-ul">
<li>When working in a new file, look around to see how the existing
code is structured</li>
<li>When making a design decision,
<ul class="org-ul">
<li>ask yourself if it's likely that a similar decision was made
elsewhere in the project</li>
<li>if so, find an existing example and use the same approach in
your new code</li>
</ul></li>
</ul></li>
<li>Don't change existing conventions
<ul class="org-ul">
<li><b>Having a "better idea" is not a sufficient excuse to introduce
inconsistencies</b>
<ul class="org-ul">
<li>The value of consistency over inconsistency is almost always
greater than the value of one approach over another</li>
<li>Before introducing inconsistent behavior, ask yourself two
questions
<ol class="org-ol">
<li>Do you have significant new information justifying your
approach that wasn't available when the old convention was
established?</li>
<li>Is the new approach so much better that it is worth taking
the time to update all of the old uses?</li>
</ol></li>
</ul></li>
<li>When you are done (upgrading from the old convention to the new
convention)
<ul class="org-ul">
<li>There should be no sign of the old convention</li>
<li>However, you still run the risk that other developers will not
know about the new convention, so they may reintroduce the old
approach in the future</li>
</ul></li>
<li>Overall, reconsidering establishes conventions is rarely a good
use of developer time</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org136a4aa" class="outline-3">
<h3 id="org136a4aa">17.3 Taking it too far</h3>
<div class="outline-text-3" id="text-org136a4aa">
<ul class="org-ul">
<li>If you become overzealous about consistency and try to force
dissimilar things into the same approach, you'll create complexity
and confusion</li>
<li>Consistency only provides benefits when developers have confidence
that "if it looks like an x, it really is an x"</li>
</ul>
</div>
</div>
<div id="outline-container-org213e4b8" class="outline-3">
<h3 id="org213e4b8">17.4 Conclusion</h3>
<div class="outline-text-3" id="text-org213e4b8">
<ul class="org-ul">
<li>Consistency is another example of the investment mindset
<ul class="org-ul">
<li>It will take a bit of extra work to ensure consistency
<ul class="org-ul">
<li>Work to decide on conventions</li>
<li>Work to crate automated checkers</li>
<li>Work to look for similar situations to mimic in new code</li>
<li>Work in code reviews to educate the team</li>
</ul></li>
<li>The return on this investment is that your code will be more
obvious
<ul class="org-ul">
<li>Developers will be able to understand the code's behavior more
quickly and accurately</li>
<li>This will allow them to work faster, with fewer bugs</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org12d6eb2" class="outline-2">
<h2 id="org12d6eb2">18 Code Should be Obvious</h2>
<div class="outline-text-2" id="text-org12d6eb2">
<ul class="org-ul">
<li>The solution to the obscurity problem (<i>Section 2.3</i>) is to write code
in a way that makes it obvious;</li>
<li>this chapter discusses some of the factors that make code more or
less obvious.</li>
<li>If code is obvious, it means that
<ul class="org-ul">
<li>someone can read the code quickly, without much thought, and their
first guesses about the behavior or meaning of the code will be
correct.</li>
<li>a reader doesn't need to spend much time or effort to gather all
the information they need to work with the code.</li>
</ul></li>
<li>If code is not obvious, then a reader must expend a lot of time and
energy to understand it.
<ul class="org-ul">
<li>Not only does this reduce their efficiency,</li>
<li>but it also increases the likelihood of misunderstanding and bugs.</li>
</ul></li>
<li>Obvious code needs fewer comments than nonobvious code.</li>
<li>"Obvious" is in the mind of the reader:
<ul class="org-ul">
<li>it's easier to notice that someone else's code is nonobvious than
to see problems with your own code.</li>
<li>Thus, the best way to determine the obviousness of code is through
code reviews.
<ul class="org-ul">
<li>If someone reading your code says it's not obvious, then it's
not obvious, no matter how clear it may seem to you.</li>
<li>By trying to understand what made the code nonobvious, you will
learn how to write better code in the future.</li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org4d8aa61" class="outline-3">
<h3 id="org4d8aa61">18.1 Things that make code more obvious</h3>
<div class="outline-text-3" id="text-org4d8aa61">
<ul class="org-ul">
<li>Two of the most important techniques for making code obvious have
already been discussed in previous chapters.
<ol class="org-ol">
<li>The first is choosing good names
<ul class="org-ul">
<li>Precise and meaningful names clarify the behavior of the code
and reduce the need for documentation.</li>
<li>If a name is vague or ambiguous, then readers will have read
through the code in order to deduce the meaning of the named
entity; this is time-consuming and error-prone.</li>
</ul></li>
<li>consistency (<i>Chapter 17</i>).
<ul class="org-ul">
<li>If similar things are always done in similar ways, then readers
can recognize patterns they have seen before and immediately
draw (safe) conclusions without analyzing the code in detail.</li>
</ul></li>
</ol></li>
<li>Here are a few other general-purpose techniques for making code more
obvious:
<ul class="org-ul">
<li>Judicious use of white space.
<ul class="org-ul">
<li>The way code is formatted can impact how easy it is to
understand.</li>
</ul></li>
<li>Comments.
<ul class="org-ul">
<li>Sometimes it isn't possible to avoid code that is
nonobvious. When this happens, it's important to use comments to
compensate by providing the missing information.</li>
<li>To do this well, you must put yourself in the position of the
reader and figure out what is likely to confuse them, and what
information will clear up that confusion.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2550bb1" class="outline-3">
<h3 id="org2550bb1">18.2 Things that make code less obvious</h3>
<div class="outline-text-3" id="text-org2550bb1">
<p>
Some of these, such as event-driven programming, are useful in some
situations, so you may end up using them anyway. When this happens,
extra documentation can help to minimize reader confusion.
</p>

<ul class="org-ul">
<li>Event-driven programming.
<ul class="org-ul">
<li>Event-driven programming makes it hard to follow the flow of
control.</li>
<li>To compensate for this obscurity, use the interface comment for
each handler function to indicate when it is invoked,</li>
</ul></li>
<li>Generic containers.
<ul class="org-ul">
<li>Many languages provide generic classes for grouping two or more
items into a single object, such as Pair in Java or std::pair in
C++.</li>
<li>These classes are tempting because they make it easy to pass
around several objects with a single variable.</li>
<li>Unfortunately, generic containers result in nonobvious code
because the grouped elements have generic names that obscure their
meaning.</li>
<li>Thus, it's better not to use generic containers.
<ul class="org-ul">
<li>If you need a container, define a new class or structure that is
specialized for the particular use.</li>
<li>You can then use meaningful names for the elements, and you can
provide additional documentation in the declaration, which is
not possible with the generic container.</li>
</ul></li>
<li>a general rule: <b>software should be designed for ease of reading,
not ease of writing</b>.</li>
</ul></li>
<li>Different types for declaration and allocation.</li>
<li>Code that violates reader expectations.
<ul class="org-ul">
<li>Code is most obvious if it conforms to the conventions that
readers will be expecting;</li>
<li>if it doesn't, then it's important to document the behavior so
readers aren't confused.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org643f8a5" class="outline-4">
<h4 id="org643f8a5">Red Flag: Nonobvious Code&#xa0;&#xa0;&#xa0;<span class="tag"><span class="RedFlag">RedFlag</span></span></h4>
<div class="outline-text-4" id="text-org643f8a5">
<ul class="org-ul">
<li>If the meaning and behavior of code cannot be understood with a
quick reading, it is a red flag.</li>
<li>Often this means that there is important information that is not
immediately clear to someone reading the code.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0e0ab63" class="outline-3">
<h3 id="org0e0ab63">18.3 Conclusion</h3>
<div class="outline-text-3" id="text-org0e0ab63">
<ul class="org-ul">
<li>Another way of thinking about obviousness is in terms of
information.
<ul class="org-ul">
<li>If code is nonobvious, that usually means there is important
information about the code that the reader does not have:</li>
<li>To make code obvious, you must ensure that readers always have the
information they need to understand it.</li>
</ul></li>
<li>You can do this in three ways.
<ol class="org-ol">
<li>The best way is to reduce the amount of information that is
needed, using design techniques such as abstraction and
eliminating special cases.</li>
<li>take advantage of information that readers have already acquired
in other contexts (for example, by following conventions and
conforming to expectations) so readers don't have to learn new
information for your code.</li>
<li>present the important information to them in the code, using
techniques such as good names and strategic comments.</li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6d6d1a0" class="outline-2">
<h2 id="org6d6d1a0">19 Software Trends</h2>
<div class="outline-text-2" id="text-org6d6d1a0">
<ul class="org-ul">
<li>This chapter:
<ul class="org-ul">
<li>several trends and patterns that have become popular in software
development over the last few decades</li>
<li>For each trend:
<ul class="org-ul">
<li>how that trend relates to the principles in this book</li>
<li>use the principles to evaluate whether that trend provides
leverage against software complexity.</li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orge8ac35e" class="outline-3">
<h3 id="orge8ac35e">19.1 Object-oriented programming and inheritance</h3>
<div class="outline-text-3" id="text-orge8ac35e">
<ul class="org-ul">
<li>One of the key elements of object-oriented programming is
<i>inheritance</i>.</li>
<li>Inheritance comes in two forms, which have different implications
for software complexity
<ol class="org-ol">
<li>Interface inheritance
<ul class="org-ul">
<li>Interface inheritance provides leverage against complexity by
reusing the same interface for multiple purposes</li>
<li>It allows knowledge acquired in solving one problem to be
used to solve other problems.
<dl class="org-dl">
<dt>Knowledge acquired in solving one problem</dt><dd>such as how to use an I/O interface to read and write
disk files</dd>
<dt>Solve other problems</dt><dd>such as communicating over a network socket</dd>
</dl></li>
<li><b>The more different implementations there are of an interface,
the deeper the interface becomes</b></li>
<li>In order for an interface to have many implementations, it
must (this notion is at <i>the heart of abstraction</i>.)
<ol class="org-ol">
<li>capture the essential features of all the underlying
implementations</li>
<li>while steering clear of the details that differ between
the implementations;</li>
</ol></li>
</ul></li>
<li>Implementation inheritance
<ul class="org-ul">
<li>Without implementation inheritance, the same method
implementation might need to be duplicated in several
subclasses, which would create dependencies between those
subclasses</li>
<li>Thus, implementation inheritance reduces the amount of code
that needs to be modified as the system evolves</li>
<li>However, implementation inheritance creates dependencies
between the parent class and each of its subclasses
<ul class="org-ul">
<li>this results in information leakage between the classes in
the inheritance hierarchy and makes it hard to modify one
class in the hierarchy without looking at the others</li>
<li>In the worst case, programmers will need complete knowledge
of the entire class hierarchy underneath the parent class
in order to make changes to any of the classes.</li>
<li>Class hierarchies that use implementation inheritance
extensively tend to have high complexity.</li>
</ul></li>
<li>Thus, implementation inheritance should be used with caution.
<ul class="org-ul">
<li>Before using implementation inheritance, consider whether
an approach based on <i>composition</i> can provide the same
benefits (<i>Composition over Inheritance</i>)</li>
<li>If there is no viable alternative to implementation
inheritance, try to separate the state managed by the
parent class from that managed by subclasses
<ul class="org-ul">
<li>This applies the notion of information hiding within the
class hierarchy to reduce dependencies.</li>
</ul></li>
</ul></li>
</ul></li>
</ol></li>
<li>Although the mechanisms provided by object-oriented programming can
assist in implementing clean designs, <b>they do not, by themselves,
guarantee good design</b></li>
</ul>
</div>
</div>
<div id="outline-container-org622c86f" class="outline-3">
<h3 id="org622c86f">19.2 Agile development</h3>
<div class="outline-text-3" id="text-org622c86f">
<ul class="org-ul">
<li>One of the most important elements of agile development is the
notion that development should be <i>incremental</i> and <i>iterative</i>.
<ul class="org-ul">
<li><i>1 Introduction (It's All About Complexity)</i></li>
<li>The best way to end up with a good design is to develop a system
in increments, where each increment adds a few new abstractions
and refactors existing abstractions based on experience</li>
</ul></li>
<li>One of the risks of agile development is that it can lead to
tactical programming
<ul class="org-ul">
<li>Agile development tends to focus developers on features, not
abstractions, and it encourages developers to put off design
decisions in order to produce working software as soon as possible</li>
<li>For example, some agile practitioners argue that you shouldn’t
implement general-purpose mechanisms right away; implement a
minimal special-purpose mechanism to start with, and refactor into
something more generic later, once you know that it’s needed.
<ul class="org-ul">
<li>Although these arguments make sense to a degree, they argue
against an investment approach, and they encourage a more
tactical style of programming.</li>
<li>This can result in a rapid accumulation of complexity.</li>
</ul></li>
<li>Developing incrementally is generally a good idea, but <b>the
increments of development should be abstractions</b>, not features.
<ul class="org-ul">
<li>It’s fine to put off all thoughts about a particular abstraction
until it’s needed by a feature.</li>
<li>Once you need the abstraction,
<ul class="org-ul">
<li>invest the time to design it cleanly;</li>
<li>follow the advice of <i>Chapter 6</i> and make it somewhat
general-purpose.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org579cdc2" class="outline-3">
<h3 id="org579cdc2">19.3 Unit tests</h3>
<div class="outline-text-3" id="text-org579cdc2">
<ul class="org-ul">
<li>Tests, particularly unit tests, play an important role in software
design because they <b>facilitate refactoring</b>
<ul class="org-ul">
<li>Without a test suite, it’s dangerous to make major structural
changes to a system
<ul class="org-ul">
<li>There’s no easy way to find bugs, so it’s likely that bugs will go
undetected until the new code is deployed, where they are much
more expensive to find and fix.</li>
<li>As a result, developers avoid refactoring in systems without good
test suites;
<ul class="org-ul">
<li>they try to minimize the number of code changes for each new
feature or bug fix,</li>
<li>which means that complexity accumulates and design mistakes
don’t get corrected.</li>
</ul></li>
</ul></li>
<li>With a good set of tests, developers can be more confident when
refactoring
<ul class="org-ul">
<li>because the test suite will find most bugs that are introduced.</li>
<li>This encourages developers to make structural improvements to a
system, which results in a better design.</li>
<li>Unit tests are particularly valuable: they provide a higher
degree of code coverage than system tests, so they are more
likely to uncover any bugs.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge5bf41e" class="outline-3">
<h3 id="orge5bf41e">19.4 Test-driven development</h3>
<div class="outline-text-3" id="text-orge5bf41e">
<ul class="org-ul">
<li>The problem with test-driven development is that it focuses
attention on getting specific features working, rather than finding
the best design.
<ul class="org-ul">
<li>This is tactical programming pure and simple, with all of its
disadvantages</li>
<li>Test-driven development is too incremental: at any point in time,
it’s tempting to just hack in the next feature to make the next
test pass.</li>
<li>There’s no obvious time to do design, so it’s easy to end up with
a mess.</li>
</ul></li>
<li>The units of development should be abstractions, not features. (<i>19.2
Agile development</i>)
<ul class="org-ul">
<li>Once you discover the need for an abstraction,
<ul class="org-ul">
<li>don’t create the abstraction in pieces over time;</li>
<li>design it all at once (or at least enough to provide a
reasonably comprehensive set of core functions).</li>
</ul></li>
<li>This is more likely to produce a clean design whose pieces fit
together well.</li>
</ul></li>
<li>One place where it makes sense to write the tests first is when
fixing bugs.
<ul class="org-ul">
<li><b>Before fixing a bug, write a unit test that fails because of the
bug.</b></li>
<li>Then fix the bug and make sure that the unit test now passes.</li>
<li>This is the best way to make sure you really have fixed the bug.
<ul class="org-ul">
<li>If you fix the bug before writing the test, it’s possible that
the new unit test doesn’t actually trigger the bug, in which
case it won’t tell you whether you really fixed the problem.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6e66413" class="outline-3">
<h3 id="org6e66413">19.5 Design patterns</h3>
<div class="outline-text-3" id="text-org6e66413">
<ul class="org-ul">
<li>Design patterns represent an alternative to design: rather than
designing a new mechanism from scratch, just apply a well-known
design pattern.</li>
<li>For the most part, this is good: design patterns arose because
<ol class="org-ol">
<li>they solve common problems,</li>
<li>they are generally agreed to provide clean solutions.</li>
</ol></li>
<li>The greatest risk with design patterns is over-application.
<ul class="org-ul">
<li>Not every problem can be solved cleanly with an existing design
pattern;</li>
<li>Don’t try to force a problem into a design pattern when a custom
approach will be cleaner</li>
<li>Using design patterns doesn’t automatically improve a software
system; it only does so if the design patterns fit.</li>
</ul></li>
<li>As with many ideas in software design, the notion that design
patterns are good doesn’t necessarily mean that more design patterns
are better.</li>
</ul>
</div>
</div>
<div id="outline-container-org47e0b51" class="outline-3">
<h3 id="org47e0b51">19.6 Getters and setters</h3>
<div class="outline-text-3" id="text-org47e0b51">
<ul class="org-ul">
<li>Getters and setters are shallow methods (typically only a single
line), so they add clutter to the class’s interface without
providing much functionality.</li>
<li>It’s better to avoid getters and setters (or any exposure of
implementation data) as much as possible.</li>
<li>One of the risks of establishing a design pattern is that
<b>developers assume the pattern is good and try to use it as much as
possible.</b>
<ul class="org-ul">
<li>This has led to overusage of getters and setters in Java.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6c143d6" class="outline-3">
<h3 id="org6c143d6">19.7 Conclusion</h3>
<div class="outline-text-3" id="text-org6c143d6">
<ul class="org-ul">
<li>Whenever you encounter a proposal for a new software development
paradigm, challenge it from the standpoint of complexity:
<ul class="org-ul">
<li><b>does the proposal really help to minimize complexity in large
software systems?</b></li>
<li>Many proposals sound good on the surface, but if you look more
deeply you will see that some of them make complexity worse, not
better.</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb73c199" class="outline-2">
<h2 id="orgb73c199">20 Designing for Performance</h2>
<div class="outline-text-2" id="text-orgb73c199">
<ul class="org-ul">
<li>This chapter discusses
<ul class="org-ul">
<li>What if you are working on a system that needs to be fast?</li>
<li>How should performance considerations affect the design process?</li>
<li>how to achieve high performance without sacrificing clean design.</li>
</ul></li>
<li>The most important idea is still <b>simplicity</b>:
<ul class="org-ul">
<li>not only does simplicity improve a system's design,</li>
<li>but it usually makes systems faster.</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org7ec9efc" class="outline-3">
<h3 id="org7ec9efc">20.1 How to think about performance</h3>
<div class="outline-text-3" id="text-org7ec9efc">
<ul class="org-ul">
<li>How much should you worry about performance during the normal
development process?
<ul class="org-ul">
<li>If you try to optimize every statement for maximum speed,
<ul class="org-ul">
<li>it will slow down development and create a lot of unnecessary
complexity.</li>
<li>Furthermore, many of the “optimizations” won't actually help
performance.</li>
</ul></li>
<li>On the other hand, if you completely ignore performance issues,
<ul class="org-ul">
<li>it's easy to end up with a large number of significant
inefficiencies spread throughout the code;</li>
<li>the resulting system can easily be 5–10x slower than it needs to
be.</li>
</ul></li>
<li>The best approach is something between these extremes, where you
<b>use basic knowledge of performance to choose design alternatives
that are “naturally efficient” yet also clean and simple.</b>
<ul class="org-ul">
<li>The key is to develop an awareness of which operations are
fundamentally expensive
<ul class="org-ul">
<li><a href="https://gist.github.com/hellerbarde/2843375">Latency numbers every programmer should know</a></li>
<li>The best way to learn which things are expensive is to run
micro-benchmarks (small programs that measure the cost of a
single operation in isolation).</li>
</ul></li>
<li>Once you have a general sense for what is expensive and what is
cheap, you can use that information to choose cheap operations
whenever possible
<ul class="org-ul">
<li>In many cases, a more efficient approach will be just as
simple as a slower approach.</li>
<li>If the only way to improve efficiency is by adding complexity,
then the choice is more difficult
<ul class="org-ul">
<li>If the more efficient design adds only a small amount of
complexity, and if the complexity is hidden, so it doesn't
affect any interfaces, then it may be worthwhile (but
beware: complexity is incremental).</li>
<li>If the faster design adds a lot of implementation
complexity, or if it results in more complicated interfaces,
then it may be better to start off with the simpler approach
and optimize later if performance turns out to be a problem.
<ul class="org-ul">
<li>However, if you have clear evidence that performance will
be important in a particular situation, then you might as
well implement the faster approach immediately.</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>In general, simpler code tends to run faster than complex code.
<ul class="org-ul">
<li>If you have defined away special cases and exceptions, then no
code is needed to check for those cases and the system runs
faster.</li>
<li>Deep classes are more efficient than shallow ones, because they
get more work done for each method call. Shallow classes result in
more layer crossings, and each layer crossing adds overhead.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgcb43dd6" class="outline-3">
<h3 id="orgcb43dd6">20.2 Measure before modifying</h3>
<div class="outline-text-3" id="text-orgcb43dd6">
<ul class="org-ul">
<li>Programmers' intuitions about performance are unreliable
<ul class="org-ul">
<li>If you start making changes based on intuition, you'll waste time
on things that don't actually improve performance, and you'll
probably make the system more complicated in the process.</li>
</ul></li>
<li><b>Before making any changes, measure the system's existing behavior</b>
<ol class="org-ol">
<li>the measurements will identify the places where performance
tuning will have the biggest impact.
<ul class="org-ul">
<li>You'll need to measure deeper to identify in detail the
factors that contribute to overall performance;</li>
<li>the goal is to identify a small number of very specific
places where the system is currently spending a lot of time,
and where you have ideas for improvement</li>
</ul></li>
<li>provide a baseline, so that you can re-measure performance
after making your changes to ensure that performance actually
improved
<ul class="org-ul">
<li>If the changes didn't make a measurable difference in
performance, then back them out (unless they made the system
simpler).</li>
<li><b>There's no point in retaining complexity unless it provides
a significant speedup.</b></li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org9ea0cfb" class="outline-3">
<h3 id="org9ea0cfb">20.3 Design around the critical path</h3>
<div class="outline-text-3" id="text-org9ea0cfb">
<ul class="org-ul">
<li>The best way to improve its performance is with a “fundamental”
change, such as introducing a cache, or using a different
algorithmic approach</li>
<li>Unfortunately, situations will sometimes arise where there isn't a
fundamental fix
<ul class="org-ul">
<li>This brings us to the core issue for this chapter, which is <b>how
to redesign an existing piece of code so that it runs faster.</b></li>
<li>The key idea is to <b>design the code around the critical path.</b>
<ul class="org-ul">
<li>Start off by asking yourself <b>what is the smallest amount of
code that must be executed</b> to carry out the desired task in the
common case</li>
<li>The ideal code probably clashes with your existing class
structure, and it may not be practical, but it provides a good
target: <b>this represents the simplest and fastest that the code
can ever be.</b></li>
<li>The next step is to look for a new design that comes as close as
possible to the ideal while still having a clean structure</li>
<li>One of the most important things that happens in this process is
to <b>remove special cases from the critical path</b>
<ul class="org-ul">
<li>When code is slow, it's often because it must handle a variety
of situations, and the code gets structured to simplify the
handling of all the different cases.</li>
<li>Ideally, there will be a single if statement at the beginning,
which detects all special cases with one test. In the normal
case, only this one test will need to be made, after which the
the critical path can be executed with no additional tests for
special cases</li>
<li>Performance isn't as important for special cases, so you can
structure the special-case code for simplicity rather than
performance.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org48e482f" class="outline-3">
<h3 id="org48e482f">20.4 An example: RAMCloud Buffers</h3>
<div class="outline-text-3" id="text-org48e482f">
</div>
</div>
<div id="outline-container-org2fdbe76" class="outline-3">
<h3 id="org2fdbe76">20.5 Conclusion</h3>
<div class="outline-text-3" id="text-org2fdbe76">
<ul class="org-ul">
<li><b>clean design and high performance are compatible.</b></li>
<li>Complicated code tends to be slow because it does extraneous or
redundant work.</li>
<li>On the other hand, if you write clean, simple code, your system will
probably be fast enough that you don't have to worry much about
performance in the first place.</li>
<li>In the few cases where you do need to optimize performance, the key
is simplicity again: find the critical paths that are most important
for performance and make them as simple as possible.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7f6b8e6" class="outline-2">
<h2 id="org7f6b8e6">21 Conclusion</h2>
<div class="outline-text-2" id="text-org7f6b8e6">
<ul class="org-ul">
<li>This book is about one thing: complexity</li>
<li>Dealing with complexity is the most important challenge in software
design.
<ul class="org-ul">
<li>It is what makes systems hard to build and maintain,</li>
<li>and it often makes them slow as well</li>
</ul></li>
<li>Over the course of the book
<ol class="org-ol">
<li>the root causes that lead to complexity</li>
<li>red flags that can help you identify unnecessary complexity</li>
<li>general ideas you can use to create simpler software systems</li>
<li>the investment mindset needed to produce simple designs</li>
</ol></li>
<li>The downside of all these suggestions is that they create extra work
in the early stages of a project
<ul class="org-ul">
<li>Furthermore, if you aren’t used to thinking about design issues,
then you will slow down even more while you learn good design
techniques.</li>
<li>If the only thing that matters to you is making your current code
work as soon as possible, then thinking about design will seem
like drudge work that is getting in the way of your real goal.</li>
</ul></li>
<li>On the other hand, <b>if good design is an important goal for you, then
the ideas in this book should make programming more fun.</b>
<ul class="org-ul">
<li>Design is a fascinating puzzle: <i>how can a particular problem be
solved with the simplest possible structure?</i></li>
<li>It’s fun to explore different approaches, and it’s a great feeling
to discover a solution that is both simple and powerful.</li>
<li>A clean, simple, and obvious design is a beautiful thing.</li>
</ul></li>
<li>Furthermore, the investments you make in good design will pay off
quickly.
<ul class="org-ul">
<li>The modules you defined carefully at the beginning of a project
will save you time later as you reuse them over and over.</li>
<li>The clear documentation that you wrote six months ago will save you
time when you return to the code to add a new feature.</li>
<li>The time you spent honing your design skills will also pay for
itself:
<ul class="org-ul">
<li>as your skills and experience grow, you will find that you can
produce good designs more and more quickly.</li>
<li><b>Good design doesn’t really take much longer than
quick-and-dirty design, once you know how.</b></li>
</ul></li>
</ul></li>
<li>The reward for being a good designer is that <b>you get to spend a
larger fraction of your time in the design phase, which is fun.</b>
<ul class="org-ul">
<li>Poor designers spend most of their time chasing bugs in
complicated and brittle code.</li>
<li>If you improve your design skills, not only will you produce
higher quality software more quickly, but the software development
process will be more enjoyable.</li>
</ul></li>
</ul>
</div>
</div>

    </div>
</section>


    <div class="post-meta">
        <span title="post date" class="post-info">2019-04-12</span>
        <span title="last modification date" class="post-info">2019-04-13</span>
        <span title="tags" class="post-info"><a href="/tags/clipping/">Clipping</a>, <a href="/tags/clean-code/">Clean Code</a>, <a href="/tags/software-engineering/">Software Engineering</a></span>
        <span title="author" class="post-info">Yiming Chen</span>
    </div>
  <section>
    <h1>Comments</h1>
    <script src="https://utteranc.es/client.js"
      repo="dsdshcym/dsdshcym.github.io"
      issue-term="title"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </section>
<footer class="footer">
  <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> (<a href="http://orgmode.org">Org mode</a>)</p>
  <p>
    Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:dsdshcym &lt;at&gt; gmail &lt;dot&gt; com">Yiming Chen</a>
    &nbsp;&nbsp;-&nbsp;&nbsp;
    Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
    <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
  </p>
</footer>

  </body>
</html>
