<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>dsdshome</title>
    <link>http://dsdshcym.github.io</link>
    <description>This is my small blog :)</description>
    <pubDate>Tue, 19 Jun 2018 16:17:15 CST</pubDate>
    <lastBuildDate>Tue, 19 Jun 2018 16:17:15 CST</lastBuildDate>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>Org-page static site generator (https://github.com/kelvinh/org-page)</generator>
    <item>
      <title>Elixir Pattern Matching on Struct Module</title>
      <link>http://dsdshcym.github.io/blog/2018/06/14/elixir_pattern_matching_on_struct_module</link>
      <description><![CDATA[<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>Elixir Pattern Matching on Struct Module</h1>
            <p>
TIL:
</p>

<p>
Elixir's Pattern Matching can also match on the Struct Module:
</p>
<div class="org-src-container">
<pre class="src src-elixir">%struct_module{} = %User{}

struct_module # =&gt; User
</pre>
</div>

<p>
Elixir just keeps doing these things that blows my mind. This kind of
features is completely surprising when I discovered them but after
some thoughts, it completely makes sense.
</p>

<p>
I guess this is why I love Elixir and its Pattern Matching feature so
much.
</p>

    </div>
</section>
]]></description>
      <pubDate>2018-06-14</pubDate>
      <guid>http://dsdshcym.github.io/blog/2018/06/14/elixir_pattern_matching_on_struct_module</guid>
    </item>
    <item>
      <title>Livable and Disposable Code</title>
      <link>http://dsdshcym.github.io/clipping/2018/06/07/livable_and_disposable_code</link>
      <description><![CDATA[<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>Livable and Disposable Code</h1>
            <blockquote>
<ul class="org-ul">
<li>3 basic principles make good software:
<ol class="org-ol">
<li>Reusability</li>
<li>Composability</li>
<li>Disposability</li>
</ol></li>
<li>Building truly disposable software makes it comfortable for
engineers to work on the project overtime.
<ul class="org-ul">
<li>Building softwares isn't just about making sure that your code base
passes some unit or integration test but it is also about how
comfortable engineers would feel while working on the same software
overtime.</li>
</ul></li>
</ul>
</blockquote>
<p>
-- from <a href="https://kunyora.github.io/kunyora/blog/2018/05/05/rethinking-disposability.html">Rethinking - Disposability · Kunyora</a>
</p>

<p>
This idea of <i>disposable code</i> reminded me of
</p>

<ol class="org-ol">
<li><p>
The idea of <i>livable code</i>:
</p>

<blockquote>
<ul class="org-ul">
<li>Our software is a place for us to live -&gt; it needs to be livable
<ul class="org-ul">
<li>Livable
<ul class="org-ul">
<li>We can do what we want easily</li>
<li>Livable means differently to different people</li>
<li>Livable is an on-going process</li>
</ul></li>
<li>Things (House/codebase) get messy one small decision at a time</li>
<li>Hoarder
<ul class="org-ul">
<li>Hoarders whose house got refurnished got back to a hoarded house
every time</li>
<li>It's the habits that decide if we can get to a clean codebase -&gt;
everyone should do every day cleanup</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<p>
-- from <a href="https://www.youtube.com/watch?v=lI77oMKr5EY">RailsConf 2018: Keynote - Livable Code by Sarah Mei - YouTube</a>
</p></li>

<li><p>
The Boy Scout Rule
</p>

<blockquote>
<p>
Leave the campground cleaner than you found it.
</p>
</blockquote>
<p>
-- from <a href="http://www.informit.com/articles/article.aspx?p=1235624&amp;seqNum=6">The Boy Scout Rule - What Is Clean Code? - InformIT</a>
</p></li>
</ol>

<p>
I think the idea of disposable code and livable code is the perfect
explanation of the boy scout rule. If we can make our code base
cleaner everyday (like what <a href="https://www.codequalitychallenge.com/">The 30-Day Code Quality Challenge</a> did),
our code base will definitely become a place everyone feels
comfortable to work on.
</p>

    </div>
</section>
]]></description>
      <pubDate>2018-06-07</pubDate>
      <guid>http://dsdshcym.github.io/clipping/2018/06/07/livable_and_disposable_code</guid>
    </item>
    <item>
      <title>Conceptual Compression</title>
      <link>http://dsdshcym.github.io/clipping/2018/05/28/conceptual-compression</link>
      <description><![CDATA[<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>Conceptual Compression</h1>
            <blockquote>
<p>
The more effectively we compress the concepts of yesterday, the
lower the barriers to entry become.
</p>
</blockquote>
<p>
-- from <a href="../../../../../Org/rss_feed.html#ID-4DB5015D-3F41-469B-A24A-0EF591B92594">Conceptual compression means beginners don’t need to know SQL
   — hallelujah!</a>
</p>

<p>
DHH raised this "new" idea of conceptual compression on this year's
RailsConf<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>.
</p>

<p>
I quoted "new" because, to me, conceptual compression is just a fancy
name for abstractions.
</p>

<p>
I always believe that extracting abstractions is what we do as
software developers.<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> Like DHH said, abstractions help us
compress things we ought to know, so that we can have more free mind
asset to think about things that's more important for us now. This is
exactly how we build large projects:
</p>

<blockquote>
<ul class="org-ul">
<li>We've always known how to do big projects.
<ul class="org-ul">
<li>You do big projects by <b>breaking them up into a bunch of small
projects</b>.</li>
<li>Agile solved the small part of that.</li>
<li>Agile really has nothing to do with the big part.</li>
</ul></li>
</ul>
</blockquote>
<p>
-- from <a href="http://blog.cleancoder.com/uncle-bob/2018/04/02/InTheLarge.html">(Agile) In The Large - Clean Coder Blog</a>
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://www.youtube.com/watch?v=zKyv-IGvgGE&amp;feature=youtu.be">RailsConf 2018: Opening Keynote: FIXME by David Heinemeier
Hansson - YouTube</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="https://dsdshcym.github.io/blog/2017/06/18/programming_languages_comparison/#outline-container-orgf1a9ec2">我看程序语言的历史、现在与将来 - dsdshome</a>
</p></div></div>


</div>
</div>
    </div>
</section>
]]></description>
      <pubDate>2018-05-28</pubDate>
      <guid>http://dsdshcym.github.io/clipping/2018/05/28/conceptual-compression</guid>
    </item>
    <item>
      <title>FP and OOP are compatible (and should be)</title>
      <link>http://dsdshcym.github.io/clipping/2018/04/26/fp_and_oop_are_compatible_and_should_be</link>
      <description><![CDATA[<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>FP and OOP are compatible (and should be)</h1>
            <blockquote>
<p>
Both OOP and functional computation can be completely compatible
(and should be!). There is no reason to munge state in objects, and
there is no reason to invent "monads" in FP. We just have to realize
that "computers are simulators" and figure out what to simulate.
</p>
</blockquote>
<p>
-- from <a href="https://www.quora.com/Why-is-functional-programming-seen-as-the-opposite-of-OOP-rather-than-an-addition-to-it/answer/Alan-Kay-11">Alan Kay's answer to Why is functional programming seen as the
   opposite of OOP rather than an addition to it? - Quora</a>
</p>

<blockquote>
<ul class="org-ul">
<li><b>FP and OO are completely orthogonal</b> (based on their reductive
definitions)
<dl class="org-dl">
<dt>OO</dt><dd>The technique of using dynamic polymorphism to call
functions without the source code of the caller depending
upon the source code of the callee.</dd>
<dt>FP</dt><dd>Referential Transparency – no reassignment of values.</dd>
</dl></li>
<li><b>Orthogonality does not imply <i>mutual exclusion</i> (just ask James
Clerk Maxwell)</b></li>
<li>It's desirable to <b>build a system that employs both <i>dynamic
polymorphism</i> and <i>referential transparency</i>.</b>
<dl class="org-dl">
<dt>Dynamic polymorphism</dt><dd>strongly decoupled</dd>
<dt>Referential transparency</dt><dd>predictable</dd>
</dl></li>
<li>A system that is built on both OO and FP principles will maximize
flexibility, maintainability, testability, simplicity, and
robustness.</li>
</ul>
</blockquote>
<p>
-- from <a href="http://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html">FP vs. OO - Clean Coder Blog</a>
</p>

<p>
I've started trying to write more functional objects after learned
about Imperative Shell around the Functional Core<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>. And I can
really feel the benefits of predictable code brought by the functional
paradigm to my Ruby (Object-Oriented) code.
</p>

<p>
And I'm also switching to Elixir as my main language these days. One
of the reasons behind this decision is that I think Elixir is a
language that can provide both benefits of OOP and FP.
</p>

<ol class="org-ol">
<li>Elixir is a functional programming language in its heart.</li>
<li>But it can still achieve polymorphism by writing Protocols or
using Pattern Matching.</li>
</ol>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="http://dsdshcym.github.io/clipping/2017/12/12/imperative-shell-around-the-functional-core/imperative-shell-around-the-functional-core/">Imperative Shell around the Functional Core - dsdshome</a>
</p></div></div>


</div>
</div>
    </div>
</section>
]]></description>
      <pubDate>2018-04-26</pubDate>
      <guid>http://dsdshcym.github.io/clipping/2018/04/26/fp_and_oop_are_compatible_and_should_be</guid>
    </item>
    <item>
      <title>做产品要有探索精神</title>
      <link>http://dsdshcym.github.io/clipping/2018/04/17/the-spirit-of-exploration</link>
      <description><![CDATA[<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>做产品要有探索精神</h1>
            <blockquote>
<ul class="org-ul">
<li>中美员工的两个差异点
<ol class="org-ol">
<li>探索精神
<ul class="org-ul">
<li>国人对工作工具（如 Workday）不会自己探索学习，以更好地使用</li>
<li>用户很懒，不想自己找信息</li>
</ul></li>
<li>男女平等（gender stereotyping）</li>
</ol></li>
</ul>
</blockquote>
<p>
-- from <a href="http://www.uxcoffee.com/9cb18cf4">#44：Airbnb 进中国，不只是「汉化」这么简单（Airbnb China 设计经理 Vivian Wang - 下） - UX Coffee 设计咖</a>
</p>


<ul class="org-ul">
<li>Takeaways
<ol class="org-ol">
<li><p>
作为 Developer, Designer, Maker 等角色，做产品时自己要具备足够的探索精神，Master your tools。
</p>
<pre class="example">
1. 折腾 Emacs 等编辑器
2. 研究如何改善 Workflow 提高自己的效率
</pre></li>
<li>为用户做产品时可能需要更迁就客户，考虑到不同用户的特点，为自己的目标用户设计合适的探索难度。</li>
</ol></li>
</ul>

    </div>
</section>
]]></description>
      <pubDate>2018-04-17</pubDate>
      <guid>http://dsdshcym.github.io/clipping/2018/04/17/the-spirit-of-exploration</guid>
    </item>
    <item>
      <title>Book Review: The Mythical Man-Month</title>
      <link>http://dsdshcym.github.io/blog/2018/04/09/book-review-the-mythical-man-month</link>
      <description><![CDATA[<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>Book Review: The Mythical Man-Month</h1>
            <blockquote>
<p>
It (<i>The Mythical Man-Month</i>) is the only book you need to read about
software management.
</p>
</blockquote>
<p>
-- from <a href="https://www.youtube.com/watch?v=-I_jE0l7sYQ&amp;feature=youtu.be">Joe Armstrong - Keynote: The Forgotten Ideas in Computer
   Science - Code BEAM SF 2018 - YouTube</a>
</p>

<p>
I truly believe this assertion after reading this book (of course, it
might because of my small sample size of software management
books).
</p>

<p>
This book reflects my current thinking that Agility is all about
gathering fast feedback<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> so well. And it amazed me from time to
time when I read this book that this kind of thinking was already
there 20, or even 40 years ago.
</p>

<p>
What amazed me more is that after 40 years, we are struggling with
some basic problems that could've been solved using the ideas from
this book. I guess this fact is also a strong proof for <b>No Silver
Bullets</b>, at least it shows that there is none yet.
</p>

<p>
I'll write down some amazed moment down below:
</p>
<div id="outline-container-orga246f39" class="outline-2">
<h2 id="orga246f39">Mockist style TDD</h2>
<div class="outline-text-2" id="text-orga246f39">
<p>
In <a href="http://dsdshcym.github.io/clipping/2018/03/24/clippings-from-the-mythical-man-month/#outline-container-orgeaf2d50">Chapter 13. The Whole and the Parts</a>, it mentioned <b>top-down design</b>
and <b>dummy component</b>. They all remind me of the <b>mockist-style TDD</b>
I'm current learning and using.
</p>
<ol class="org-ol">
<li>Top-down design is basically what mockist-style TDD is doing.</li>
<li>Dummy component is what we call mocks/stubs/fakes today.</li>
</ol>

<p>
It always surprises me how early this style of development were used
in the history of software development. Even without tests as
automated as today, people in the early ages were still trying their
best to use the most tight feedback loop they could get.
</p>

<p>
In <a href="http://dsdshcym.github.io/clipping/2018/03/24/clippings-from-the-mythical-man-month/#outline-container-orgba7dc4d">Chapter 19. The Mythical Man-Month: after 20 years</a>, it also
introduces <i>Building an end-to-end skeleton system</i>, which is
basically what <i>Growing Object-Oriented Software Guided by
Tests</i><sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> is doing.
</p>
</div>
</div>
<div id="outline-container-org2fc206b" class="outline-2">
<h2 id="org2fc206b">Readable Code</h2>
<div class="outline-text-2" id="text-org2fc206b">
<p>
In <a href="http://dsdshcym.github.io/clipping/2018/03/24/clippings-from-the-mythical-man-month/#outline-container-orgb12aa9d">Chapter 15. The Other Face</a>, it talked about the importance of
readability<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>:
</p>
<blockquote>
<p>
<b>a written program has another face, that which tells its story to the
human user.</b>
</p>
</blockquote>

<p>
I truly believe that <b>the only way to make our code maintainable is to
write self-documenting programs</b> as described in this book.
</p>
<dl class="org-dl">
<dt>Class/Function/Variable Naming</dt><dd>Use the parts of the program that have to be there anyway (symbol
names), for programming language reasons, to carry as much of the
documentation as possible</dd>
<dt>Style matters<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup></dt><dd>Use space and format as much as possible to improve
readability and show subordination and nesting</dd>
<dt>Comments</dt><dd>Insert the necessary prose documentation as paragraphs of
comment</dd>
</dl>
</div>
</div>
<div id="outline-container-orgac96832" class="outline-2">
<h2 id="orgac96832">Open Source v.s. Buy v.s. Build</h2>
<div class="outline-text-2" id="text-orgac96832">
<p>
If there was anything close to a Silver Bullet, I guess that must be
Open Source Software Movement<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>.
</p>

<p>
With the rising of open source software hosting platform like GitHub,
one can easily build its own software upon these countless open source
libraries/frameworks without any cost.
</p>

<p>
And one can continue get free security patches and performant
improvements if he/she continues updating these dependencies.
</p>

<p>
Indeed, Open Source made a great leap forward from buying software,
but we are still facing the same issue as "buy v.s. build":
<b>applicability</b>.
</p>

<p>
It's still hard to find an off-the-shelf package to perform my own
task and suit my own needs perfectly. (I'll talk more about this in a
future post.) Because of this, I still cannot believe Open Source is
the Silver Bullet.
</p>
</div>
</div>
<div id="outline-container-orgcf28c02" class="outline-2">
<h2 id="orgcf28c02">Continuous Integration / Continuous Deployment (CI/CD)</h2>
<div class="outline-text-2" id="text-orgcf28c02">
<p>
In <a href="http://dsdshcym.github.io/clipping/2018/03/24/clippings-from-the-mythical-man-month/#outline-container-orgba7dc4d">Chapter 19. The Mythical Man-Month: after 20 years</a>, this book shows
how Microsoft did CI/CD in the early days. They called it "Build Every
Night" Approach, which is basically what Continuous Integration /
Continuous Deployment means.
</p>

<p>
And as you might have known, we've learned a lot about this CI/CD
practices in the last 20 years.
</p>
</div>
</div>
<div id="outline-container-org3bd4a39" class="outline-2">
<h2 id="org3bd4a39">Summary</h2>
<div class="outline-text-2" id="text-org3bd4a39">
<p>
As it was said in <a href="http://dsdshcym.github.io/clipping/2018/03/24/clippings-from-the-mythical-man-month/#outline-container-orgba7dc4d">Chapter 19. The Mythical Man-Month: after 20 years</a>:
</p>
<blockquote>
<p>
<b>Software engineering is merely immature as chemical engineering was
in 1945</b>
</p>
</blockquote>
<p>
I think we as the whole software development community are still
learning and gaining more experience in this area in 2018. And we've
also improved a lot in the last 20 years.
</p>

<p>
<b>The beauty of continuous learning and discovering in this immature
industry is what intrigues me the most from this industry.</b>
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="http://dsdshcym.github.io/clipping/2018/03/30/what-agility-really-means/">What Agility Really Means - dsdshome</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="http://dsdshcym.github.io/blog/2017/10/18/build-a-faster-feed-back-loop/">GOOS: Build a Faster Feedback Loop - dsdshome</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
<a href="http://dsdshcym.github.io/clipping/2017/12/11/write-your-code-as-if-youre-writing-a-letter/write-your-code-as-if-you're-writing-a-letter/">Write your code as if you're writing a letter - dsdshome</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
<a href="http://dsdshcym.github.io/clipping/2017/12/21/code-style-consistency-matters/">Code style consistency matters - dsdshome</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
<a href="http://www.cs.colostate.edu/~bieman/Pubs/Editorials/EditorialV14N4.pdf">Editorial: Free/Open Source Software, Silver Bullets, and
Mythical Months.</a>
</p></div></div>


</div>
</div>
    </div>
</section>
]]></description>
      <pubDate>2018-04-10</pubDate>
      <guid>http://dsdshcym.github.io/blog/2018/04/09/book-review-the-mythical-man-month</guid>
    </item>
    <item>
      <title>What Agility Really Means</title>
      <link>http://dsdshcym.github.io/clipping/2018/03/30/what-agility-really-means</link>
      <description><![CDATA[<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>What Agility Really Means</h1>
            <blockquote>
<ul class="org-ul">
<li>What to Do
<ol class="org-ol">
<li>Find out where you are</li>
<li>Take a small step towards your goal</li>
<li>Adjust your understanding based on what you learned</li>
<li>Repeat</li>
</ol></li>
<li>How to Do It
<ul class="org-ul">
<li>When faced with two of more alternatives that deliver roughly
the same value, take the path that makes future change easier</li>
</ul></li>
</ul>
</blockquote>
<p>
-- from <a href="https://www.youtube.com/watch?v=a-BOSpxYJ9M">GOTO 2015 • Agile is Dead • Pragmatic Dave Thomas - YouTube</a>
   and <a href="https://pragdave.me/blog/2014/03/04/time-to-kill-agile.html">Agile is Dead (Long Live Agility)</a>
</p>

<p>
I think this can be the summary of my current understanding of
Agility.
</p>

<p>
<b>Only by taking steps as small as possible, can we embrace the changes
this interesting world presents us without losing any sanity.</b><sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<p>
And this agility thinking can absolutely be adopted to all the things
we are doing at work or even in our daily life:
</p>
<ol class="org-ol">
<li>TDD</li>
<li>Issue Solving</li>
<li>Feature Management</li>
<li>Company Management</li>
<li>Skill Learning</li>
</ol>

<p>
Also, this methodology reflects TDD perfectly:
</p>
<dl class="org-dl">
<dt>Find out where you are</dt><dd>Write a failing test</dd>
<dt>Take a small step towards your goal</dt><dd>Fix this failing test</dd>
<dt>Adjust your understanding based on what you learned</dt><dd>Refactor or Start considering next test</dd>
<dt>(no term)</dt><dd>Repeat</dd>
</dl>

<p>
I first learned this idea from <a href="https://www.sandimetz.com/99bottles/">99 Bottles - Sandi Metz</a>. (You can also
read my review of this book <a href="http://dsdshcym.github.io/blog/2017/12/08/book-review-99-bottles-of-oop/#orgb711f32">here</a><sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>)
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="http://dsdshcym.github.io/blog/2018/03/27/learn-incremental-deployment-the-hard-way/">Learn Incremental Deployment the Hard Way - dsdshome</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="http://dsdshcym.github.io/blog/2017/12/08/book-review-99-bottles-of-oop/#orgb711f32">Book Review: 99 Bottles of OOP - dsdshome</a>
</p></div></div>


</div>
</div>
    </div>
</section>
]]></description>
      <pubDate>2018-03-30</pubDate>
      <guid>http://dsdshcym.github.io/clipping/2018/03/30/what-agility-really-means</guid>
    </item>
    <item>
      <title>Learn Incremental Deployment the Hard Way</title>
      <link>http://dsdshcym.github.io/blog/2018/03/27/learn-incremental-deployment-the-hard-way</link>
      <description><![CDATA[<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>Learn Incremental Deployment the Hard Way</h1>
            <p>
I failed to deploy two big features in the past two years. I want to
discuss why I failed them and what I think the best way to finish
them.
</p>

<div id="outline-container-org9a8de14" class="outline-2">
<h2 id="org9a8de14">2 Failed Features</h2>
<div class="outline-text-2" id="text-org9a8de14">
</div>
<div id="outline-container-orgd9aba66" class="outline-3">
<h3 id="orgd9aba66"><a id="ID-F918D834-B7FA-42D4-8A9A-6453F52AC0A9"></a>Extract App Configurations to Environment Variables</h3>
<div class="outline-text-3" id="text-orgd9aba66">
</div>
<div id="outline-container-org608ae39" class="outline-4">
<h4 id="org608ae39">Context</h4>
<div class="outline-text-4" id="text-org608ae39">
<p>
We have many app configurations (e.g. 3-rd party service
configurations like AWS S3, app behavior configurations like host
name). We were storing these configurations in files (like a normal
Rails app would normally do). In the config files, we have different
values for different environment (development/staging/production).
</p>
</div>
</div>
<div id="outline-container-orgf10f52c" class="outline-4">
<h4 id="orgf10f52c">Reason for refactoring</h4>
<div class="outline-text-4" id="text-orgf10f52c">
<p>
And then we migrated to using Docker/Kubernetes for deployments. We
want to setup more staging environments for different teams to test
independent features.
</p>
</div>
</div>
<div id="outline-container-orgf3db39e" class="outline-4">
<h4 id="orgf3db39e">The Plan</h4>
<div class="outline-text-4" id="text-orgf3db39e">
<p>
So we decided to extract these configuration values into environment
variables.
</p>

<p>
I thought this was an easy change so I kept all the changes in a
single feature branch. But it turned out to be a silly decision.
</p>
</div>
</div>
<div id="outline-container-org17a54f8" class="outline-4">
<h4 id="org17a54f8">Issues</h4>
<div class="outline-text-4" id="text-org17a54f8">
<ol class="org-ol">
<li>It's a ton of work to review. Although it's almost just replacing
the hard-coded value with a call to <code>ENV</code> , it's the most hard to
review type of merge requests because it needs reviewer to verify
if there are any typos instead of logic defects.</li>
<li>We don't have any tests coverage for most of the features. So
it's harder to know if these actually working or not. We have to
deploy them to staging or even production to know that.</li>
<li>I took two-month vacation when I finished the code changes. But
other developers didn't deploy these changes nor tested
them. After I got back, I had to rebase the feature branch to
catch the newest changes and deal with newly added
configurations.</li>
</ol>
</div>
</div>
<div id="outline-container-orgee414ce" class="outline-4">
<h4 id="orgee414ce">Results</h4>
<div class="outline-text-4" id="text-orgee414ce">
<p>
Of course things went completely wrong after I merged this branch
and tested them on staging. Even the homepage had some issues. We
had to go back and forth to find the issue and fix it, test it
again. Finally, it took us almost 3 months to finish this
refactoring.
</p>
</div>
</div>
</div>
<div id="outline-container-orge09279b" class="outline-3">
<h3 id="orge09279b">Merge an API service into the main App</h3>
<div class="outline-text-3" id="text-orge09279b">
</div>
<div id="outline-container-orgeb076c5" class="outline-4">
<h4 id="orgeb076c5">Context</h4>
<div class="outline-text-4" id="text-orgeb076c5">
<p>
We have two apps running, one of them is the web interface (responds
to HTML requests), another one is the API interface (responds to
JSON requests).
</p>
</div>
</div>
<div id="outline-container-org0e4ac95" class="outline-4">
<h4 id="org0e4ac95">Reason for refactoring</h4>
<div class="outline-text-4" id="text-org0e4ac95">
<p>
They share almost the same behaviour, except the view templates are
different. Whenever we need to add or modify a piece of logic, we
need to do it twice.
</p>
</div>
</div>
<div id="outline-container-org5256f75" class="outline-4">
<h4 id="org5256f75">The Plan</h4>
<div class="outline-text-4" id="text-org5256f75">
<p>
So we decided to merge these two apps and leverage Rails' powerful
<code>respond_to</code> method.
</p>

<p>
Since I have the experience from last time (<a href="#orgd9aba66">Extract Feature Toggles
to Environment Variables</a>), I decided to do it one controller by one
controller.
</p>

<p>
It started pretty well: I separated them into different branches, so
that they can be tested and merged independently. I planed to test
and deploy migrated APIs and migrate other APIs at the same time.
</p>
</div>
</div>
<div id="outline-container-org8fced45" class="outline-4">
<h4 id="org8fced45">Issues</h4>
<div class="outline-text-4" id="text-org8fced45">
<p>
But then bad things happened in our process:
</p>
<ol class="org-ol">
<li>My manager took several weeks off for vacation. And I took
several weeks off for vacation after he got back. We didn't
merge/deploy any of these changes in these weeks.</li>
<li>Another developer was still developing new features in the
meantime. So that when I got back from the vacation, I had more
things to sync.</li>
<li>We didn't have any integration tests for our APIs. Which meant I
also needed to add them when I migrated them into the web
app. (But I was not sure if these tests were even correct at
all.)</li>
<li><p>
The client (mobile apps) for this API is maintained by our
clients in a different timezone (Yes, we are only responsible for
the web part and the API). They didn't provide any test apps for
us to test the migrated API until I migrated all of them.
</p>

<p>
Of course things went wrong when all these bad things came together.
</p>
<ol class="org-ol">
<li>Since my manager was off, I finished all the APIs without
deploying anything. (Things started to go off the rails from this
decision.)</li>
<li>The client team moved really slow. I received the test app weeks
after I finished the APIs. And another dev had already added new
features to existing old APIs.</li>
<li>In our old API App, we had handlers for both <code>.api</code> and <code>.json</code>
formats. Since I didn't have any integration tests nor an test
app. I had to re-implement both of them, which actually added
some garbage code to our web app.</li>
<li>The newly added tests didn't provide me with enough confidence so
I had to test the new APIs with a staging app. But then the
controllers had dependencies on each other due to the business
logic on the client side. (I had to login to test all the other
controllers.)</li>
<li>Since the client team was in a different timezone, I had to wait
for a day for their feedback on the API specifications, which
made things much harder.</li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-org9690855" class="outline-4">
<h4 id="org9690855">Results</h4>
<div class="outline-text-4" id="text-org9690855">
<p>
Finally, I had to merge all the changes into one branch and handed
over the testing phase to my manage (who's in the same timezone as
the client team), and let them test the new APIs. This means my plan
to incrementally deploy these new APIs completely failed.
</p>
</div>
</div>
</div>
<div id="outline-container-org36d2bbd" class="outline-3">
<h3 id="org36d2bbd">Common Issues</h3>
<div class="outline-text-3" id="text-org36d2bbd">
</div>
<div id="outline-container-orgf06fa43" class="outline-4">
<h4 id="orgf06fa43">No Tests</h4>
<div class="outline-text-4" id="text-orgf06fa43">
<p>
These two refactorings both started without any integration test
coverage. And testing them on staging/production took a lot of
time. Without the confidence provided by integration tests, I was
always afraid that some changes would break something when deploy.
</p>
</div>
</div>
<div id="outline-container-org9082d56" class="outline-4">
<h4 id="org9082d56">Vocations</h4>
<div class="outline-text-4" id="text-org9082d56">
<p>
I both took vocation during the development of these two
refactorings. I should've at least deployed what I'd finished and
tested them out. So that the changes wouldn't get outdated after my
vocation.
</p>
</div>
</div>
<div id="outline-container-org37d3617" class="outline-4">
<h4 id="org37d3617">Huge Steps</h4>
<div class="outline-text-4" id="text-org37d3617">
<p>
And the most important issue was that I wanted to take a huge step to
finish these tasks once and for all, instead of breaking down them
into smaller tasks (while these two tasks could be easily separated
into sub-tasks by nature). This is against the spirit of Agile and
kind of like waterfall.
</p>

<p>
I ran into many unexpected problems when I deployed the huge
changesets. I would gain more experiences dealing with these problems
if I took smaller steps and tried to learn from each steps.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb146fc8" class="outline-2">
<h2 id="orgb146fc8">Incremental Deployment: the Only Way to Deploy Large Feature Changes</h2>
<div class="outline-text-2" id="text-orgb146fc8">
<p>
I think the only way to deploy this kind of large changesets is
breaking them down into smaller changesets and deploy them
incrementally. Even if I have a better test coverage, I would still
choose this incremental strategy. I think <b>taking small steps</b> and
<b>getting feedback from each step</b> are the core idea of Agile and
Continuous Integration. If I always keep the system deployable and
runnable, add small refactorings step by step, any huge tasks can be
taken down easily.
</p>

<p>
I'll take the above two examples and explain how I would deploy them,
and also give a template for this kind of changes.
</p>
</div>
<div id="outline-container-org61a593d" class="outline-3">
<h3 id="org61a593d">Environment Variables</h3>
<div class="outline-text-3" id="text-org61a593d">
<ol class="org-ol">
<li>Find out all the environment variables that need to be extracted</li>
<li>Create a separate branch for one variable</li>
<li>Extract it to environment variable and update the deploy settings</li>
<li>Test and deploy it</li>
<li>Repeat 2-4 for every variable</li>
</ol>
</div>
</div>
<div id="outline-container-org1deb48b" class="outline-3">
<h3 id="org1deb48b">API rewriting</h3>
<div class="outline-text-3" id="text-org1deb48b">
<ol class="org-ol">
<li>List all the APIs that needs to be rewritten</li>
<li>Figure out the dependencies between controllers to decide the order
of controllers to be rewritten</li>
<li>Create a separate branch for one controller (or even one controller
action)</li>
<li>Rewrite it in the web app and direct client to use this new
endpoint<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup></li>
<li>Test and deploy it</li>
<li>Repeat 3-5 for every controller</li>
</ol>
</div>
</div>
<div id="outline-container-org1a67511" class="outline-3">
<h3 id="org1a67511">Template</h3>
<div class="outline-text-3" id="text-org1a67511">
<ol class="org-ol">
<li>Break down the task and list every separate task that needs to be
done</li>
<li>Figure out the dependencies if there are any</li>
<li>Start working on the first sub-task</li>
<li>Test and deploy it</li>
<li>Repeat it until all the tasks are done</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org1896ab4" class="outline-2">
<h2 id="org1896ab4">Summary</h2>
<div class="outline-text-2" id="text-org1896ab4">
<p>
The final template is super simple and I think this was what I was
doing when I tried to implemented the mentioned refactorings. But due
to many complex reasons, I was doing it completely wrong. I guess I
just learned this idea of incremental deployment the hard way from
these real cases.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Things get trickier when you have to deal with a separate team that
controls the client app and calling different endpoints in the same
app.
</p></div></div>


</div>
</div>
    </div>
</section>
]]></description>
      <pubDate>2018-03-28</pubDate>
      <guid>http://dsdshcym.github.io/blog/2018/03/27/learn-incremental-deployment-the-hard-way</guid>
    </item>
    <item>
      <title>UI/UX design and software/code design are very alike</title>
      <link>http://dsdshcym.github.io/clipping/2018/03/26/ui-ux-design-and-software-code-design-are-very-alike</link>
      <description><![CDATA[<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>UI/UX design and software/code design are very alike</h1>
            <blockquote>
<ul class="org-ul">
<li>What started out as casual conversation with my friends turned into
a deep investigation into our habits as humans and needs as
listeners.</li>
<li>I explored each facet of user experience design and found that my
fascination with human-computer interaction stemmed from my
compassion for people (empathy).</li>
<li>Some powerful things I learned was knowing how to handle change, how
crucial iteration is, and being thorough. Most importantly, there is
a lot more to learn in design and research.</li>
</ul>
</blockquote>
<p>
-- from <a href="https://medium.freecodecamp.org/my-friends-hate-soundcloud-ios-so-i-redesigned-it-for-them-d3038cdd020b">My friends hate SoundCloud iOS so I redesigned it for them</a>
</p>

<p>
A coworker of mine did an internal sharing for <a href="https://medium.freecodecamp.org/my-friends-hate-soundcloud-ios-so-i-redesigned-it-for-them-d3038cdd020b">this article</a><sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> last
Friday.
</p>

<p>
I think the learning from this experiment actually resonates so
well with my programming experiences. And I always think UI/UX design
and software design are very much alike somehow.
</p>

<ol class="org-ol">
<li>HCI and programming are all about empathy.</li>
<li>Embrace change</li>
<li>Fast iterations</li>
<li>Continuous learning</li>
</ol>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://medium.freecodecamp.org/my-friends-hate-soundcloud-ios-so-i-redesigned-it-for-them-d3038cdd020b">My friends hate SoundCloud iOS so I redesigned it for them</a>
</p></div></div>


</div>
</div>
    </div>
</section>
]]></description>
      <pubDate>2018-03-26</pubDate>
      <guid>http://dsdshcym.github.io/clipping/2018/03/26/ui-ux-design-and-software-code-design-are-very-alike</guid>
    </item>
    <item>
      <title>Clippings from The Mythical Man-Month</title>
      <link>http://dsdshcym.github.io/clipping/2018/03/24/clippings-from-the-mythical-man-month</link>
      <description><![CDATA[<section id="content" role="main">
    <div id="outline-container-sec-" class="row" style="padding-top: 70px">
        <div class="col-md-2"></div>
            <h1>Clippings from The Mythical Man-Month</h1>
            
<div id="outline-container-org3bb7fb1" class="outline-2">
<h2 id="org3bb7fb1">Preface to the 20th Anniversary Edition</h2>
</div>
<div id="outline-container-org36daacd" class="outline-2">
<h2 id="org36daacd">Preface to the First Edition</h2>
</div>
<div id="outline-container-org29cea6d" class="outline-2">
<h2 id="org29cea6d">Chapter 1. The Tar Pit</h2>
<div class="outline-text-2" id="text-org29cea6d">
<ul class="org-ul">
<li>Large-system programming is a tar pit that so many great and powerful beasts
have sunk in it</li>
<li>The Programming Systems Product
<ul class="org-ul">
<li>A Program</li>
<li>A Programming Product</li>
<li>A Programming System</li>
<li>A Programming Systems Product</li>
</ul></li>
<li>The Joy of the Craft
<ol class="org-ol">
<li>Making things</li>
<li>Making things that are useful to other people</li>
<li>Fashioning complex puzzle-like objects of interlocking moving parts and
watching them work in subtle cycles, playing out the consequences of
principles built in from the beginning</li>
<li>Always learning</li>
<li>Working in such a tractable, flexible medium</li>
</ol></li>
<li>The Woes of the Craft
<ol class="org-ol">
<li>One must perform perfectly</li>
<li>One rarely control the circumstances of his work, or even its goal</li>
<li>Dependencies are often mal-designed, poorly implemented, incompletely
delivered, and poorly documented</li>
<li>Designing grand concepts is fun, but finding nitty little bugs is just work</li>
<li>Debugging has a linear convergence (the last difficult bugs takes more time
to find than the first)</li>
<li>The product appears to be obsolete upon (or before) completion
<ul class="org-ul">
<li>As soon as one freezes a design, it becomes obsolete in terms of its
concepts</li>
<li><b>The obsolescence of an implementation must be measured against other
existing implementations, not against unrealized concepts</b></li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org91be7dc" class="outline-2">
<h2 id="org91be7dc">Chapter 2. The Mythical Man-Month</h2>
<div class="outline-text-2" id="text-org91be7dc">
<ul class="org-ul">
<li>Scheduling tasks is hard
<ol class="org-ol">
<li>Our techniques of estimating are poorly developed</li>
<li>Our estimating techniques fallaciously confuse effort with progress, hiding
the assumption that men and months are interchangeable</li>
<li>Software managers often lack the courteous stubbornness because we are
uncertain of our estimates</li>
<li>Schedule progress is poorly monitored</li>
<li>When schedule slippage is recognized, the natural and traditional response
is to add manpower</li>
</ol></li>
<li>Optimism
<ul class="org-ul">
<li>The first false assumption: <i>all will go well</i> (<i>each task will hike only as
long as it "ought" to take</i>)</li>
<li>3 stages of a creative activity (book, program, etc.) from <i>The Mind of the Maker</i>
<ol class="org-ol">
<li>the idea</li>
<li>the implementation</li>
<li>the interaction</li>
</ol></li>
<li>Because the medium (computer) is tractable, we expect few difficulties in
implementation -&gt; optimism</li>
<li>A large programming effort, however, consists of many tasks, some chained
end-to-end. The probability that each will go well becomes vanishingly
small.</li>
</ul></li>
<li>The Man-Month
<ul class="org-ul">
<li><b>The man-month as a unit for measuring the size of a job is a dangerous and
deceptive myth.</b>
<ul class="org-ul">
<li><i>Cost</i> does indeed vary as the product of the number of men and the number
of months</li>
<li><i>Progress</i> does not vary</li>
</ul></li>
<li>Men and months are not interchangeable (for programming)
<ol class="org-ol">
<li>They are interchangeable commodities only when a task can be partitioned
among many workers <b>with no communication among them</b>
<ul class="org-ul">
<li>reaping wheat</li>
<li>picking cotton</li>
</ul></li>
<li>When a task cannot be partitioned because of sequential constraints, the
application of more effort has no effect on the schedule
<ul class="org-ul">
<li><b>The bearing of a child takes nine months, no matter how many women are
assigned.</b></li>
</ul></li>
<li>When a task can be partitioned but requires communication among the
subtasks, the effort of communication must be added to the amount of work
to be done</li>
</ol></li>
<li>The added burden of communication is made up of two parts
<ol class="org-ol">
<li>Training
<ul class="org-ul">
<li>Cannot be partitioned</li>
</ul></li>
<li>Intercommunication
<ul class="org-ul">
<li>O(n^2)</li>
<li>The added effort of communicating may fully counteract the division of
the original task and bring us to this situation</li>
</ul></li>
</ol></li>
<li>Since software construction is inherently a systems effort, an exercise in
complex interrelationships, communication effort is great, and it quickly
dominates the decrease in individual task time brought about by
partitioning.</li>
</ul></li>
<li>Systems Test
<ul class="org-ul">
<li>Because of optimism, we usually expect the number of bugs to be smaller than
it turns out to be. Therefore testing is usually the most mis-scheduled part
of programming.</li>
<li>Rule of thumb
<ul class="org-ul">
<li>1/3 planning</li>
<li>1/6 coding</li>
<li>1/4 component test and early system test</li>
<li>1/4 system test, all components in hand</li>
</ul></li>
<li>Failure to allow enough time for system test, in particular, is peculiarly
disastrous.
<ul class="org-ul">
<li>Since the delay comes at the end of the schedule, no one is aware of
schedule trouble until almost the delivery date.</li>
<li>Delay at this point has unusually severe financial, as well as
psychological, repercussions.</li>
</ul></li>
</ul></li>
<li>Gutless Estimating
<ul class="org-ul">
<li>False scheduling to match the patron's desired date is much more common in
our discipline than elsewhere in engineering.</li>
</ul></li>
<li><b>Regenerative Schedule Disaster</b>
<ul class="org-ul">
<li><p>
<b>Brooks's Law</b>
</p>
<blockquote>
<p>
Adding manpower to a late software project makes it later.
</p>
</blockquote></li>
<li>One can derive schedules using fewer men and more months.</li>
<li>One cannot, however, get workable schedules using more men and fewer months.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2e010fd" class="outline-2">
<h2 id="org2e010fd">Chapter 3. The Surgical Team</h2>
<div class="outline-text-2" id="text-org2e010fd">
<ul class="org-ul">
<li>The Problem
<dl class="org-dl">
<dt>The problem with large teams</dt><dd>Not everyone is a 10x programmer</dd>
<dt>The problem with small, sharp team concept</dt><dd>Too slow for really big systems</dd>
</dl></li>
<li><p>
Mills's Proposal (The Surgical Team)
</p>
<blockquote>
<p>
Instead of each member cutting away on the problem, one does the cutting and
the others give him every support that will enhance his effectiveness and
productivity.
</p>
</blockquote></li>
</ul>
</div>
</div>
<div id="outline-container-org7b25b3d" class="outline-2">
<h2 id="org7b25b3d">Chapter 4. Aristocracy, Democracy, and System Design</h2>
<div class="outline-text-2" id="text-org7b25b3d">
<ul class="org-ul">
<li>Conceptual Integrity
<ul class="org-ul">
<li>Software and Cathedrals
<ul class="org-ul">
<li>Most cathedrals show differences between parts built in different
generations by different builders</li>
<li>Most software reflect <i>conceptual disunity</i> far worse than that of
cathedrals (from the separation of design into many tasks done by many men)</li>
</ul></li>
<li><i>Conceptual integrity</i> is <b>the most important consideration in system
design</b></li>
<li>Chapter 4-7
<ol class="org-ol">
<li>How is conceptual integrity to be achieved?</li>
<li>Does not this argument imply an elite, or aristocracy of architects, and
a horde of plebeian implementer whose creative talents and ideas are
suppressed?</li>
<li>How does one keep the architects from drifting off into the blue with
unimplementable or costly specifications?</li>
<li>How does one ensure that every trifling detail of an architectural
specification get communicated to the implementer, properly understood by
him, and accurately incorporated into the product?</li>
</ol></li>
</ul></li>
<li>Achieving Conceptual Integrity
<ul class="org-ul">
<li>The purpose of a programming system is to make a computer easy to use</li>
<li><b>The ratio of <i>function</i> to <i>conceptual complexity</i> is the ultimate test of
system design</b>
<ul class="org-ul">
<li>Neither <i>function</i> alone nor <i>simplicity</i> alone defines a good design</li>
</ul></li>
</ul></li>
<li>Aristocracy and Democracy
<ul class="org-ul">
<li>Dilemma
<dl class="org-dl">
<dt>Conceptual integrity</dt><dd>The design must proceed from one mind (or a very small number of minds)</dd>
<dt>Schedule pressures</dt><dd>The system building needs many hands</dd>
</dl></li>
<li>Solution
<ol class="org-ol">
<li>Chapter 3. The Surgical Team</li>
<li><p>
Separate architecture (UI) and implementation (Details)
</p>
<blockquote>
<p>
Where architecture tells <i>what</i> happens, implementation tells
<i>how</i> it is made to happen
</p>
</blockquote>
<ul class="org-ul">
<li><i>Architecture</i> -&gt; The complete and detailed specification of
the user interface (UI)</li>
<li>The setting of external specifications is not more creative
work than the designing of implementations.</li>
</ul></li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge234209" class="outline-2">
<h2 id="orge234209">Chapter 5. The Second-System Effect</h2>
<div class="outline-text-2" id="text-orge234209">
<ul class="org-ul">
<li>An architect's first work is apt to be spare and clean
<ol class="org-ol">
<li>He knows the doesn't know what he's doing</li>
<li>He does it carefully and with great restraint</li>
</ol></li>
<li>The Second-System Effect
<ul class="org-ul">
<li>The general tendency is to <b>over-design</b> the second system
<ul class="org-ul">
<li>OS/360 is a prime example of the second-system effect</li>
</ul></li>
<li>Another tendency is to <b>refine obsoleted techniques</b></li>
</ul></li>
<li>How to avoid the second-system effect
<ul class="org-ul">
<li>Architect
<ol class="org-ol">
<li>Be conscious of the peculiar hazards of the second-system</li>
<li>Exert extra <b>self-discipline</b> to
<ol class="org-ol">
<li>avoid functional ornamentation</li>
<li>avoid extrapolation of functions that are obviated by changes
in assumptions and purposes</li>
</ol></li>
</ol></li>
<li>Project Manager
<ol class="org-ol">
<li>Insist on a senior architect who has <b>at least two</b> systems
under his belt</li>
<li>Stay aware of the special temptations</li>
</ol></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org52ff06b" class="outline-3">
<h3 id="org52ff06b"><a href="https://en.wikipedia.org/wiki/Second-system_effect">Second-system effect - Wikipedia</a></h3>
<div class="outline-text-3" id="text-org52ff06b">
<blockquote>
<p>
The tendency of small, elegant, and successful systems, to be
succeeded by over-engineered, bloated systems, due to inflated
expectations and overconfidence.
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-org349cd8f" class="outline-2">
<h2 id="org349cd8f">Chapter 6. Passing the Word</h2>
<div class="outline-text-2" id="text-org349cd8f">
<p>
<b>How shall the manager ensure that everyone hears, understands, and
implements the architects' decisions?</b>
(A successful solution for the System/360 hardware design effort)
</p>
<ol class="org-ol">
<li>Written Specifications - the Manual
<ul class="org-ul">
<li>The <i>external</i> specification of the product</li>
<li>The architect must
<ol class="org-ol">
<li><b>always be prepared to show <i>an</i> implementation for any feature
he describes</b></li>
<li>but not attempt to dictate <i>the</i> implementation</li>
</ol></li>
<li>The style must be precise, full, and accurately detailed.</li>
</ul></li>
<li>Formal Definitions
<ul class="org-ul">
<li>Future specifications will consist of both a formal definition
<i>and</i> a prose definition
<ul class="org-ul">
<li>Formal Definitions are <b>precise</b></li>
<li>Prose Definitions can <b>explain why</b></li>
</ul></li>
<li>But there can be <b>only one</b> primary standard</li>
<li>An implementation can also serve as a formal definition
<ul class="org-ul">
<li>Advantages
<ol class="org-ol">
<li>All questions can be settled unambiguously by experiment</li>
<li>Debate is never needed</li>
<li>Answers are always as precise as one wants</li>
<li>Answers are always correct, by definition</li>
</ol></li>
<li>Disadvantages
<ol class="org-ol">
<li>The implementation may over-prescribe even the externals
<ol class="org-ol">
<li>Side effects</li>
<li>Not only what it must do, but also how to do it</li>
</ol></li>
<li>Sometimes give unexpected and unplanned answers (Vim and its
Emulators)</li>
<li>the use of an implementation as a formal definition is
peculiarly susceptible to confusion as to whether the prose
description or the formal description is in fact the
standard.</li>
</ol></li>
</ul></li>
</ul></li>
<li>Direct Incorporation</li>
<li>Conferences and Courts
<ol class="org-ol">
<li>Weekly half-day conference of all the architects, plus official
representatives of the implementers, and the market planners</li>
<li>Semi-Annual supreme court sessions (two weeks every six months)
<ul class="org-ul">
<li>To solve issues, appeals, or disgruntlements</li>
</ul></li>
</ol></li>
<li>Multiple Implementations
<ul class="org-ul">
<li>when you have enough time and manpower</li>
</ul></li>
<li>The Telephone Log
<ul class="org-ul">
<li>Keep a text log for questions/issues</li>
</ul></li>
<li>Product Test</li>
</ol>
</div>
</div>
<div id="outline-container-orgcf8a35b" class="outline-2">
<h2 id="orgcf8a35b">Chapter 7. Why Did the Tower of Babel Fail?</h2>
<div class="outline-text-2" id="text-orgcf8a35b">
<ul class="org-ul">
<li>Where did they lack?
<ol class="org-ol">
<li>Communication
<ul class="org-ul">
<li>lack of communication led to disputes, bad feelings, and group
jealousies.</li>
</ul></li>
<li>Organization (1's consequence)</li>
</ol></li>
<li>Communication in the Large Programming Project
<ul class="org-ul">
<li>A formal project work book must be started at the beginning</li>
<li>The Project Workbook
<dl class="org-dl">
<dt>What</dt><dd><i>All</i> the documents of the project
<ol class="org-ol">
<li>Objectives</li>
<li>External specifications</li>
<li>Interface specifications</li>
<li>Technical standards</li>
<li>Internal specifications</li>
<li>Administrative memorandum</li>
</ol></dd>
<dt>Why</dt><dd><ol class="org-ol">
<li>Technical prose is almost immortal</li>
<li>Ensure that relevant information gets to all the people who
need it (Control of the distribution of information )</li>
</ol></dd>
<dt>Mechanics</dt><dd><ol class="org-ol">
<li>Each programmer should see all the material</li>
<li>Timely updating</li>
</ol></dd>
</dl></li>
</ul></li>
<li>Organization in the Large Programming Project
<ul class="org-ul">
<li>The purpose of organization is to <b>reduce the amount of
communication and coordination necessary</b></li>
<li>The means by which communication is obviated
<ol class="org-ol">
<li>division of labor</li>
<li>specialization of function</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2448ef7" class="outline-2">
<h2 id="org2448ef7">Chapter 8. Calling the Shot</h2>
<div class="outline-text-2" id="text-org2448ef7">
<ul class="org-ul">
<li>Teams are only realizing 50 percent of the working week as actual
programming and debugging time (20 hours per week)</li>
<li>Programming productivity may be increased as much as five times when
a suitable high-level language is used</li>
</ul>
</div>
</div>
<div id="outline-container-orgea89e98" class="outline-2">
<h2 id="orgea89e98">Chapter 9. Ten Pounds in a Five-Pound Sack</h2>
<div class="outline-text-2" id="text-orgea89e98">
<ul class="org-ul">
<li>Program Space as Cost
<ul class="org-ul">
<li>Since size is such a large part of the user cost of a programming
system product, the builder must set size targets, control size,
and devise size-reduction techniques</li>
</ul></li>
<li>Size Control
<ol class="org-ol">
<li>Budget all aspects of size</li>
<li>Define exactly what a module must do when you specify how big it
must be</li>
</ol></li>
<li>Space Techniques</li>
<li><b>Representation (Data Structure) Is the Essence of Programming</b>
<ul class="org-ul">
<li>Almost always faster algorithms are the result of stategic
breakthrough rather than tactical cleverness.</li>
<li>Much more often, strategic breakthrough will come from redoing the
representation of the data or tables.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb564233" class="outline-2">
<h2 id="orgb564233">Chapter 10. The Documentary Hypothesis</h2>
<div class="outline-text-2" id="text-orgb564233">
<ul class="org-ul">
<li>Why Formal Documents?
<ol class="org-ol">
<li>writing the decisions down is essential</li>
<li>the documents will communicate the decisions to others</li>
<li>a manager's documents give him a data base and checklist.</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org58e9f01" class="outline-2">
<h2 id="org58e9f01">Chapter 11. Plan to Throw One Away</h2>
<div class="outline-text-2" id="text-org58e9f01">
<ul class="org-ul">
<li>Pilot Plants and Scaling Up
<ul class="org-ul">
<li>Chemical engineers learned long ago that a process that works in
the laboratory <b>cannot be implemented in a factory in only one
step.</b></li>
<li>Delivering that throwaway to customers buys time, but it does so
only at the cost of agony for the user, distraction for the
builders while they do the redesign, and a bad reputation for the
product that the best redesign will find hard to live down.</li>
<li><b>Plan to throw one away; you will, anyhow.</b></li>
</ul></li>
<li><b>The Only Constancy Is Change Itself</b></li>
<li>Plan the System for Change
<ul class="org-ul">
<li>Most important is <b>the use of a high-level language</b> and
<b>self-documenting techniques</b> so as to reduce errors induced by
changes.</li>
</ul></li>
<li>Plan the Organization for Change
<ul class="org-ul">
<li><p>
The reluctance to document designs comes from the designer's
reluctance to commit himself to the defense of decisions which he
knows to be tentative
</p>
<blockquote>
<p>
By documenting a design, the designer exposes himself to the
criticisms of everyone, and he must be able to defend everything
he writes. If the organizational structure is threatening in any
way, nothing is going to be documented until it is com- pletely
defensible.
</p>
</blockquote></li>
<li>Structuring an organization for change is much harder than
designing a system for change.</li>
<li>Management structures also need to be changed as the system
changes.</li>
</ul></li>
<li>Plan to Throw One Away
<ul class="org-ul">
<li>The fundamental problem with program maintenance is that fixing a
defect has a substantial (20-50 percent) chance of introducing
another.
<ol class="org-ol">
<li>unless the structure is pure or the documentation very fine,
the far-reaching effects of the repair will be overlooked.</li>
<li>the repairer is usually not the man who wrote the code, and
often he is a junior programmer or trainee.</li>
</ol></li>
<li>Program maintenance requires far more system testing per statement
written than any other programming.</li>
</ul></li>
<li>One step forward and one step back
<ul class="org-ul">
<li>Less and less effort is spent on fixing original design flaws;
more and more is spent on fixing flaws introduced by earlier
fixes.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org65880fc" class="outline-2">
<h2 id="org65880fc">Chapter 12. Sharp Tools</h2>
<div class="outline-text-2" id="text-org65880fc">
<blockquote>
<p>
A good workman is known by his tools
</p>
</blockquote>
<ul class="org-ul">
<li>What are the tools about which the manager must philosophize, plan,
and organize?
<ol class="org-ol">
<li>Computer Facility</li>
<li>Operating System</li>
<li>Language
<ol class="org-ol">
<li><b>High-level language</b></li>
<li><b>Interactive programming</b></li>
</ol></li>
<li>Utilities</li>
<li>Debugging aids</li>
<li>Test-case generators</li>
<li>Text-processing system (for documentation)</li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org53c2088" class="outline-2">
<h2 id="org53c2088">Chapter 13. The Whole and the Parts</h2>
<div class="outline-text-2" id="text-org53c2088">
<ul class="org-ul">
<li>This Chapter
<ol class="org-ol">
<li>How does one build a program to work?</li>
<li>How does one test a program</li>
<li>How does one integrate a tested set of component programs into a
tested and dependable system?</li>
</ol></li>
<li>Designing the Bugs Out
<ul class="org-ul">
<li>Bug-proofing the definition
<ul class="org-ul">
<li>The most pernicious and subtle bugs are system bugs arising from
<b>mismatched assumptions</b> made by the authors of various
components</li>
<li><b>Conceptual integrity</b> can solve this issue</li>
<li>Careful function definition</li>
<li>Careful specification</li>
</ul></li>
<li><p>
Testing the specification
</p>
<blockquote>
<p>
They won't tell you they don't understand it; they will happily
invent their way through the gaps and obscurities.
</p>
</blockquote></li>
<li><b>Top-down design</b>
<ul class="org-ul">
<li>Program Development by Stepwise Refinement
<ul class="org-ul">
<li>Identify design as a sequence of <i>refinement steps</i> (refactoring?)
<ol class="org-ol">
<li>Sketch a rough task definition and a rough solution method
that achieves the principal result</li>
<li>Examine the definition more closely to see how the result
differs from what is wanted</li>
<li>Take the large setps of the solution and break them down
into smaller steps</li>
</ol></li>
<li>During this process, developer identifies <i>modules</i></li>
<li><b>Use as high-level annotation as is possible at each step</b>,
exposing the concepts and concealing the details until further
refinement becomes necessary</li>
</ul></li>
<li>How top-down design avoids bugs
<ol class="org-ol">
<li><b>The clarity of structure and representation</b> makes the
precise statement of requirements and functions of the
modules easier</li>
<li>The partitioning and independence of modules avoids system
bugs</li>
<li>The suppression of detail makes flaws in the structure more
apparent</li>
<li>The design can be tested at each of its refinement steps
<ul class="org-ul">
<li>So testing can start earlier</li>
<li>testing can focus on the proper level of detail at each
step</li>
</ul></li>
</ol></li>
<li>It's much easier to see exactly when and why one should throw
away a gross design and start over</li>
<li><b>Many poor systems come from an attempt to salvage a bad basic
design and patch it with all kinds of cosmetic relief.</b> Top-down
design reduces the temptation</li>
</ul></li>
<li>Structured programming
<ul class="org-ul">
<li>Do not use <code>goto</code></li>
<li><b>Think about the control structures of a system as control
structures</b>, not as individual branch statements.</li>
</ul></li>
</ul></li>
<li>Component Debugging
(The cycle of debugging procedures)
<ol class="org-ol">
<li>On-machine debugging</li>
<li>Memory dumps</li>
<li>Snapshots</li>
<li>Interactive debugging</li>
</ol></li>
<li>System Debugging
<ul class="org-ul">
<li>System debugging will take longer than one expects</li>
<li>Its difficulty justifies <b>a thoroughly systematic and planned
approach</b>
<ol class="org-ol">
<li>Use debugged components
<ul class="org-ul">
<li>The sooner one puts the pieces together, the sooner the
system bugs will emerge</li>
<li><b>One does <i>not</i> know all the expected effects of known bugs</b></li>
</ul></li>
<li>Build plenty of scaffolding
(programs and data built for debugging purpose)
<ol class="org-ol">
<li><i>dummy component</i> (<b>fake/mock/stub</b>)</li>
<li><i>miniature file</i>
<ul class="org-ul">
<li><i>dummy file</i></li>
</ul></li>
<li><i>auxiliary programs</i>
<ul class="org-ul">
<li>generators for test data (factories)</li>
<li>special analysis printouts</li>
<li>cross-reference table analyzers</li>
</ul></li>
</ol></li>
<li>Control changes</li>
<li>Add one component at a time
<ul class="org-ul">
<li>Assume there will be lots of bugs</li>
<li>Plan an orderly procedure for snaking bugs out</li>
</ul></li>
<li>Quantize updates</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3d66056" class="outline-2">
<h2 id="org3d66056">Chapter 14. Hatching a Catastrophe</h2>
<div class="outline-text-2" id="text-org3d66056">
<ul class="org-ul">
<li>Day-by-day slippage is harder to recognize, harder to prevent,
harder to make up
<ul class="org-ul">
<li>Each one only postpones some activity by a half-day or a day.</li>
<li>And the schedule slips, one day at a time.</li>
</ul></li>
<li>Milestones or Millstones?
<ul class="org-ul">
<li>Milestones must be concrete, specific, measurable events, defined
with knife-edge sharpness.</li>
<li>Two interesting studies of Estimating behavior show that:
<ol class="org-ol">
<li><i>Estimates</i> of the length of an activity, made and revised
care- fully every two weeks before the activity starts, do not
signifi- cantly change as the start time draws near, no matter
how wrong they ultimately turn out to be.</li>
<li>During the activity, <i>overestimates</i> of duration come steadily
down as the activity proceeds.</li>
<li><i>Underestimates</i> do not change significantly during the
activity until about three weeks before the scheduled
completion.</li>
</ol></li>
</ul></li>
<li>"The Other Piece Is Late, Anyway"
<ul class="org-ul">
<li>Critical-path scheduling</li>
<li>PERT chart</li>
</ul></li>
<li>Under the Rug
<ul class="org-ul">
<li>When a first-line manager sees his small team slipping behind, he
is rarely inclined to run to the boss with this woe.</li>
<li><p>
The first-line manager's interests and those of the boss have an
inherent conflict here.
</p>
<blockquote>
<p>
The first-line manager fears that if he reports his problem, the
boss will act on it. Then his action will preempt the manager's
function, diminish his authority, foul up his other plans. So as
long as the manager thinks he can solve it alone, he doesn't tell
the boss.
</p>
</blockquote></li>
<li>Two rug-lifting techniques
<ol class="org-ol">
<li>Reducing the role conflict
<ol class="org-ol">
<li>The boss must distinguish between <i>action information</i> and
<i>status information</i></li>
<li>The boss must discipline himself
<ol class="org-ol">
<li><i>not</i> to act on problems his managers can solve</li>
<li><i>not</i> to act on problems when he is explicitly reviewing status</li>
</ol></li>
<li>The boss can label meetings, reviews, conferences, as
<i>status-review meetings</i> versus <i>problem-action meetings</i>,
and controls himself accordingly.</li>
</ol></li>
<li>Yanking the rug off
<ul class="org-ul">
<li>It is necessary to have review techniques by which the true
status is made known, whether cooperatively or not.</li>
<li>A report showing milestones and actual completions is the key
document.
<ol class="org-ol">
<li>Everyone knows the questions</li>
<li>The component manager should be prepared to explain why
it's late, when it will be finished, what steps he's
taking, and what help</li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
<li>Plans and Controls team</li>
</ul>
</div>
</div>
<div id="outline-container-org6ca2009" class="outline-2">
<h2 id="org6ca2009">Chapter 15. The Other Face</h2>
<div class="outline-text-2" id="text-org6ca2009">
<ul class="org-ul">
<li>The Other Face
<ul class="org-ul">
<li>A computer program is a message from a man to a machine</li>
<li>But a written program has another face, that which <b>tells its
story to the human user</b>.
<ul class="org-ul">
<li>Even if you are not cooperating, memory will fail the
author-user, and you will require refreshing on the details of
his handiwork.</li>
</ul></li>
<li>The other face to the user is fully as important as the face to
the machine.</li>
<li><b>The "how" of good documentation</b></li>
</ul></li>
<li>What Documentation Is Required?
<ul class="org-ul">
<li>To use a program
<ol class="org-ol">
<li>Purpose</li>
<li>Environment</li>
<li>(Input) domain and (output) range</li>
<li>Functions realized and algorithms used</li>
<li>Input-output formats</li>
<li>Operating instructions</li>
<li>Options</li>
<li>Running time</li>
<li>Accuracy and checking</li>
</ol></li>
<li>To believe a program (test cases)
<ol class="org-ol">
<li>Mainline cases (chief functions for commonly encountered data)</li>
<li>Barely legitimate cases (probe the edge of the input data
domain)</li>
<li>Barely illegitimate cases (probe the domain boundary from the
other side)</li>
</ol></li>
<li>To modify a program
<ol class="org-ol">
<li>A flow chart or subprogram structure graph</li>
<li>Complete descriptions of the algorithms used, or self
references to such descriptions in the literature</li>
<li>An explanation of the file structures</li>
<li>And overview of the data pass structure (data flow)</li>
<li>A discussion of modifications contemplated in the original
design, the nature and location of hooks and exits</li>
</ol></li>
</ul></li>
<li>The Flow-Chart Curse
<ul class="org-ul">
<li>Flow charts show the decision structure of a program, which is
only one aspect of its structure.</li>
<li>The one-page flow chart for a substantial program becomes
essentially a diagram of program structure, and of phases or
steps.</li>
<li>The detailed blow-by-blow flow chart, however, is an obsolete
nuisance, suitable only for initiating beginners into algorithmic
thinking.</li>
<li><b>Flow charting is more preached than practiced.</b></li>
</ul></li>
<li>Self-Documenting Programs
<ul class="org-ul">
<li>As a principal objective, we must attempt to <b>minimize the burden
of documentation</b>, the burden neither we nor our predecessors have
been able to bear successfully.</li>
<li>An approach
<ol class="org-ol">
<li>Use the parts of the program that have to be there anyway
(symbol names), for programming language reasons, to carry  as
much of the documentation as possible</li>
<li>Use space and format as much as possible to improve readability
and show subordination and nesting</li>
<li>Insert the necessary prose documentation as paragraphs of
comment
<ul class="org-ul">
<li><i>Paragraph comments</i> are better than <i>line-by-line comments</i>
because they usually give inteligibility and overview to the
whole thing</li>
</ul></li>
</ol></li>
<li>Write documentations when the program is first written</li>
<li>Why not?
<ol class="org-ol">
<li>the increase in the size of the source code</li>
<li>more keystrokes</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgae25018" class="outline-2">
<h2 id="orgae25018">Chapter 16. No Silver Bullet - Essence and Accident in Software Engineering</h2>
<div class="outline-text-2" id="text-orgae25018">
<blockquote>
<p>
There is no single development, in either technology or management
technique, which by itselfpromises even one order-of-magnitude
improvement within a decade in productivity, in reliability, in
simplicity.
</p>
</blockquote>
<ul class="org-ul">
<li><a href="http://www.cs.nott.ac.uk/~pszcah/G51ISS/Documents/NoSilverBullet.html">No Silver Bullet: Essence and Accidents of Software Engineering</a></li>
<li><p>
Silver Bullet
</p>
<blockquote>
<p>
Of all the monsters that fill the nightmares of our folklore, none terrify
more than werewolves, because they transform unexpectedly from the familiar
into horrors. For these, one seeks bullets of silver that can magically lay
them to rest.
</p>
</blockquote>
<ul class="org-ul">
<li>The familiar software project, at least as seen by the nontechnical manager,
has something of this character</li>
</ul></li>
<li>Essential Difficulties
<ol class="org-ol">
<li>Not that software progress is so slow, but that computer hardware progress
is so fast (the fastest in human history)</li>
<li>The difficulties of software technology
<ul class="org-ul">
<li><p>
Essence (inherent)
</p>

<p>
I believe the hard part of building software to be the <b>specification</b>,
<b>design</b>, and <b>testing</b> of this conceptual construct, not the labor of
representing it and testing the fidelity of the representation.
</p>

<ul class="org-ul">
<li>Complexity
<ul class="org-ul">
<li>DRY
<ul class="org-ul">
<li>Software entities are more complex for their size than perhaps any
other human construct because no two parts are alike</li>
<li>If they are, we make the two similar parts into a subroutine</li>
</ul></li>
<li>States
<ul class="org-ul">
<li>Software systems have orders-of-magnitude more states than
computers do.</li>
</ul></li>
<li>Lead to many problems
<ol class="org-ol">
<li>Communication
<dl class="org-dl">
<dt>Function complexity</dt><dd>Hard to use</dd>
<dt>Structure complexity</dt><dd>Hard to extend</dd>
<dt>Structure complexity</dt><dd>Unvisualized states</dd>
</dl></li>
<li>Management</li>
</ol></li>
</ul></li>
<li>Conformity</li>
<li>Changeability
<ul class="org-ul">
<li>Software is constantly subject to pressures for change
<ol class="org-ol">
<li>The software in a system embodies its function, and the
<b>function is the part that most feels the pressures of
change</b></li>
<li>Software can be changed more easily (than buildings,
cars, computers, etc.)</li>
</ol></li>
<li>All successful software gets changes
<ol class="org-ol">
<li>People try it in new cases at the edge of, or beyond,
the original domain</li>
<li>Successful software also survives beyond the normal life
of the hardware for which it is first written</li>
</ol></li>
<li>Software is embedded in <b>a cultural matrix of applications,
users, laws, and hardware</b>. These all change continually</li>
</ul></li>
<li>Invisibility
<ul class="org-ul">
<li>Software constitute not one, but several, general directed
graphs, superimposed one upon another</li>
<li>This lack of visualization not only impedes the process of
design within one mind, it severely hinders communication
among minds</li>
</ul></li>
</ul></li>
<li>Accidents (not inherent)</li>
</ul></li>
</ol></li>
<li><p>
Past Breakthroughs Solved Accidental Difficulties
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Breakthroughs</th>
<th scope="col" class="org-left">Accidental Difficulties</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">High-level languages</td>
<td class="org-left">Machine</td>
</tr>

<tr>
<td class="org-left">Time-sharing</td>
<td class="org-left">Slow turn-around</td>
</tr>

<tr>
<td class="org-left">Unified programming environments</td>
<td class="org-left">Using programs together</td>
</tr>
</tbody>
</table>
<ul class="org-ul">
<li>High-level languages
<ul class="org-ul">
<li>It frees a program from much of its <b>accidental complexity of
the machine</b>.</li>
<li>The most a high-level language can do is to furnish all the
constructs the programmer imagines in the abstract program</li>
<li>At some point the elaboration of a high-level language becomes a
burden that <b>increases, not reduces, the intellectual task of
the user who rarely uses the esoteric constructs</b></li>
</ul></li>
<li>Time-sharing
<ul class="org-ul">
<li>Time-sharing <b>preserves immediacy</b>, and hence enables us to
maintain an overview of complexity</li>
<li>The slow turnaround of batch programming means that we
inevitably forget the minutiae, if not the very thrust, of what
we were thinking when we stopped programming and called for
compilation and execution.
<ul class="org-ul">
<li><b>Slow turn-around</b>, like machine-language complexities, is an
accidental difficulty of the software process.</li>
</ul></li>
<li>The principal effect is to shorten system response time.</li>
</ul></li>
<li>Unified programming environments
<ul class="org-ul">
<li>They attack the accidental difficulties of <b>using programs
together</b>, by providing integrated libraries, unified file
formats, and pipes and filters</li>
</ul></li>
</ul></li>
<li>Hopes for the Silver
<ol class="org-ol">
<li>Another high-level language? (Like Ada)
<ul class="org-ul">
<li>Ada, after all, is just another high-level language</li>
<li>The biggest payoff from high-level languages came from the first
transition</li>
</ul></li>
<li>OOP
<ul class="org-ul">
<li><i>Abstract data types</i> and <i>hierarchical types</i> each removes one
more accidental difficulty from the process</li>
<li>The complexity of the design itself is essential</li>
</ul></li>
<li>Artificial intelligence
<ul class="org-ul">
<li>强人工智能是 P 还是 NP - Google Search</li>
<li><b>The hard thing about building software is deciding what to say,
not saying it.</b></li>
<li>Expert systems (Linter?)
<ul class="org-ul">
<li>suggesting interface rules</li>
<li>advising on testing strategies</li>
<li>remembering bug-type frequencies</li>
<li>offering optimization hints</li>
<li>The most powerful contribution of expert systems will surely
be to put at the service of the inexperienced programmer the
experience and accumulated wisdom of the best program- mers.</li>
</ul></li>
<li>"Automatic" programming
<ul class="org-ul">
<li>the generation of a program for solving a problem from a
statement of the problem specifications.</li>
<li>in most cases it is the solution method, not the problem,
whose specification has to be given.</li>
<li>Problems can be solved by using generators
<ol class="org-ol">
<li>The problems are readily characterized by relatively few
parameters</li>
<li>There are many known methods of solution to provide a
library of alternatives</li>
<li>Extensive analysis has led to explicit rules for selecting
solution techniques, given problem parameters.</li>
</ol></li>
</ul></li>
</ul></li>
<li>Graphical programming
<ol class="org-ol">
<li>The flow chart is a very poor abstraction of software structure
<ul class="org-ul">
<li>it has proved to be essentially useless as a design tool</li>
<li>programmers draw flow charts after, not before, writing the
programs they describe.</li>
</ul></li>
<li>The screens of today are too small, in pixels, to show both the
scope and the resolution of any serious detailed software
diagram</li>
<li>Software is very difficult to visualize</li>
</ol></li>
<li>Program verification
<ul class="org-ul">
<li>Program verification does not promise, however, to save labor</li>
<li>Program verification does not mean error-proof programs.
<ul class="org-ul">
<li>Mathematical proofs also can be faulty.</li>
<li>So whereas verification might reduce the program-testing load,
it cannot eliminate it.</li>
</ul></li>
<li>Even perfect program verification <b>can only establish that a
program meets its specification</b>
<ul class="org-ul">
<li><b>The hardest part of the software task is arriving at a
complete and consistent specification</b>, and much of the
essence of building a program is in fact the debugging of the
specification.</li>
</ul></li>
</ul></li>
<li>Environments and tools
<ul class="org-ul">
<li>The most IDEs promise is freedom from syntactic errors and
simple semantic errors.</li>
<li>Perhaps the biggest gain yet to be realized in the programming
environment is <b>the use of integrated database systems to keep
track of the myriads of details</b> that must be recalled
accurately by the individual programmer and kept current in a
group of collaborators on a single system.</li>
</ul></li>
<li>Workstations
<ul class="org-ul">
<li>A factor of 10 in machine speed would surely leave think-time
the dominant activity in the programmer's day.</li>
</ul></li>
</ol></li>
<li>Promising Attacks on the Conceptual Essence
<ol class="org-ol">
<li>Buy vs. Build
<ul class="org-ul">
<li>The most radical possible solution for constructing software is
<b>not to construct it at all</b></li>
<li>The cost of software has always been <b>development cost</b>, not
<i>replication cost</i></li>
<li>The use of <i>n</i> copies of a software system effectively
multiplies the productivity of its developers by <i>n</i></li>
<li>The key issue is <b>applicability</b>
<ul class="org-ul">
<li>The big change has been in the hardware/software cost ratio.
<ul class="org-ul">
<li>The buyer of a $2-million machine in 1960 felt that he
could afford $250,000 more for a customized payroll program</li>
<li>Buyers of $50,000 office machines today cannot conceivably
afford customized payroll programs</li>
</ul></li>
</ul></li>
</ul></li>
<li>Requirements refinement and rapid prototyping
<ul class="org-ul">
<li><b>The hardest single part of building a software system is
deciding precisely what to build.</b></li>
<li><b>The clients do not know what they want.</b>
<ol class="org-ol">
<li>They usually do not know what questions must be answered,</li>
<li>They almost never have thought of the problem in the detail
that must be specified.</li>
</ol></li>
<li>It is really impossible for clients, even those working with
software engineers, to specify completely, precisely, and
correctly the exact requirements of a modern software product
before having built and tried some versions of the product they
are specifying.</li>
<li>The purpose of the prototype is to make real the conceptual
structure specified, so that the client can test it for
consistency and usability.</li>
</ul></li>
<li>Incremental development
<ul class="org-ul">
<li><b>Grow, not build, software</b></li>
<li>We freely use other elements of the metaphor, such as
<ol class="org-ol">
<li>specifications</li>
<li>assembly of components</li>
<li>scaffolding</li>
</ol></li>
<li>Top-down Design</li>
<li>Teams can <i>grow</i> much more complex entities in four months than
they can <i>build</i></li>
</ul></li>
<li>Great designers
<ul class="org-ul">
<li>We can get good designs by <i>following good practices</i> instead
of poor ones.</li>
<li><b>The very best designers produce structures that are faster,
smaller, simpler, cleaner, and produced with less effort.</b></li>
<li>Software systems that have excited passionate fans are those
that are the products of one or a few designing minds, great
designers.
<ul class="org-ul">
<li>Unix</li>
<li>Pascal</li>
<li>Smalltalk</li>
<li>FORTRAN</li>
<li>Modulo</li>
</ul></li>
<li>I think the most important single effort we can mount is to
<b>develop ways to grow great designers.</b></li>
<li>Each software organization must determine and proclaim that
great designers are as important to its success as great
managers are, and that they can be expected to be similarly
nurtured and rewarded.</li>
<li><b>How to grow great designers?</b>
<ul class="org-ul">
<li>Systematically identify top designers as early as
possible. The best are often not the most experienced.</li>
<li>Assign a career mentor to be responsible for the develop-
ment of the prospect, and keep a careful career file.</li>
<li>Devise and maintain a career development plan for each
prospect, including carefully selected apprenticeships with
top designers, episodes of advanced formal education, and
short courses, all interspersed with solo design and
technical leadership assignments.</li>
<li>Provide opportunities for growing designers to interact with
and stimulate each other.</li>
</ul></li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org83502c8" class="outline-2">
<h2 id="org83502c8">Chapter 17. "No Silver Bullet" Refired</h2>
<div class="outline-text-2" id="text-org83502c8">
<ul class="org-ul">
<li>accidental complexity -&gt; incidental/appurtenant complexity
<dl class="org-dl">
<dt>essence</dt><dd>mental crafting of the conceptual construct</dd>
<dt>accident</dt><dd>its implementation process</dd>
</dl></li>
<li>If the accidental part of the work is less than 9/10 of the total,
shrinking it to zero will not give an order of magnitude
productivity improvement</li>
<li><p>
Complexity is by levels
</p>
<blockquote>
<p>
<b>Most of the complexities which are encountered in systems work are
symptoms of organizational malfunctions.</b>
</p>
</blockquote>
<p>
NSB advocates adding necessary complexity to a software system:
</p>
<ul class="org-ul">
<li>Hierarchically, by layered modules or objects</li>
<li>Incrementally, so that the system always works.</li>
</ul></li>
<li><p>
Jones's Point—Productivity Follows Quality
</p>
<blockquote>
<p>
Focus on <i>quality</i>, and <i>productivity</i> will follow.
</p>
</blockquote></li>
<li>Object-Oriented Programming -- Will a Brass Bullet Do?
<ul class="org-ul">
<li>Buildings with bigger pieces
<ul class="org-ul">
<li>Views of OOP
<ol class="org-ol">
<li>Modularity</li>
<li>Encapsulation</li>
<li>Inheritance</li>
<li>Strong abstract data-typing</li>
</ol></li>
<li>All these disciplines can be had without taking the whole
Smalltalk or C++ package</li>
</ul></li>
<li><b>Why has object-oriented technique grown slowly</b>
<ul class="org-ul">
<li><p>
The C++ Report
</p>
<blockquote>
<p>
The problem is that programmers in OO have been experimenting in
incestuous applications and aiming low in abstraction, instead
of high.
</p>

<p>
For example, they have been building classes such as <code>linked-list</code>
or <code>set</code> instead of classes such as <code>user-interface</code> or <code>radiation
      beam</code> or <code>finite-element model</code>.
</p>
</blockquote></li>
<li><p>
<b>OO is a type of design</b>
</p>
<blockquote>
<p>
OO has been tied to a variety of complex languages.
</p>

<p>
Instead of teaching people that OO is a type of design, and
giving them design principles, people have taught that OO is the
use of a particular tool.
</p>

<p>
<b>We can write good or bad programs with any tool.</b>
</p>

<p>
<b>Unless we teach people how to design, the languages matter very
little.</b> The result is that people do bad designs with these
languages and get very little value from them. If the value is
small, it won't catch on.
</p>
</blockquote></li>
</ul></li>
<li>Front-loaded costs, down-stream benefits
<ul class="org-ul">
<li>Switching to OO system costs more when started</li>
<li><p>
The big benefits pay off during successor building, extension,
and maintenance activities
</p>
<blockquote>
<p>
Object-oriented techniques will not make the first project
development any faster, or the next one. The fifth one in that
family will go blazingly fast.
</p>
</blockquote></li>
<li>Betting real up-front money for the sake of projected but iffy
benefits later is what investors do every day.</li>
<li>In many programming organizations, however, it requires real
managerial courage, a commodity much scarcer than technical
competence or administrative proficiency. (Tech Debt)</li>
</ul></li>
</ul></li>
<li><p>
What About Reuse?
</p>
<blockquote>
<p>
We conjecture that barriers to reuse are not on the producer side,
but on the consumer side. If a software engineer, a potential
consumer of standardized software components, perceives it to be
more expensive to find a component that meets his need, and so
verify, than to write one anew, a new, duplicative component will be
written. Notice we said perceives above. It doesn't matter what the
true cost of reconstruction is.
</p>
</blockquote>
<ul class="org-ul">
<li>Learning Large Vocabularies — A Predictable but Unpredicted
Problem for Software Reuse
<ul class="org-ul">
<li>The higher the level at which one thinks, the more numerous the
primitive thought-elements one has to deal with.</li>
<li>Whether we do this (reusing) by object class libraries or
procedure libraries, we must face the fact that <b>we are
radically raising the sizes of our programming vocabularies</b>.</li>
<li><b>How people acquire language</b>
<ul class="org-ul">
<li>People learn in sentence contexts, so we need to publish many
examples of composed products, not just libraries of parts.</li>
<li>People do not memorize anything but spelling. They learn
syntax and semantics incrementally, in context, by use.</li>
<li>People group word composition rules by syntactic classes, not
by compatible subsets of objects.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org10f0a5b" class="outline-2">
<h2 id="org10f0a5b">Chapter 18. Propositions of The Mythical Man-Month: True or False?</h2>
</div>
<div id="outline-container-orgc435d8b" class="outline-2">
<h2 id="orgc435d8b">Chapter 19. The Mythical Man-Month: after 20 years</h2>
<div class="outline-text-2" id="text-orgc435d8b">
<ul class="org-ul">
<li>Why Is There a Twentieth Anniversary Edition?
<ol class="org-ol">
<li>The software development discipline has not advanced normally or
properly.
<ul class="org-ul">
<li>Chapter 16. No Silver Bullet - Essence and Accident in Software Engineering</li>
</ul></li>
<li>The Mythical Man-Month is only incidentally about software but
primarily about <b>how people in teams make things</b>.
<ul class="org-ul">
<li><b>Managing a software project is more like other management than
most programmers initially believe</b></li>
</ul></li>
</ol></li>
<li>What was right when written, and still is
<ul class="org-ul">
<li>The Central Argument: Conceptual Integrity and the Architect
<ul class="org-ul">
<li>Conceptual integrity</li>
<li>The architect</li>
<li>Separation of architecture from implementation and realization</li>
<li>Recursion of architects</li>
</ul></li>
<li>The Second-System Effect: Featuritis and Frequency-Guessing
<ul class="org-ul">
<li>Featuritis
<ul class="org-ul">
<li>The besetting temptation for the architect of a general
purpose tool is to <b>overload the product with features of
marginal utility</b>, at the expense of performance and even of
ease of use.</li>
<li>Frequently, the original system architect has gone on to
greater glories, and the architecture is in the hands of
people with less experience at representing the user's overall
interest in balance.</li>
</ul></li>
<li>Defining the user set
<ul class="org-ul">
<li>Each member of the design team will surely have an implicit
mental image of the users, and <b>each designer's image will be
different</b>.</li>
<li><b>Writing down the attributes of the expected user set</b>,
including:
<ol class="org-ol">
<li>Who they are</li>
<li>What they need</li>
<li>What they think they need</li>
<li>What they want</li>
</ol></li>
</ul></li>
<li>Frequencies
<ul class="org-ul">
<li>For any software product, any of the attributes of the user
set is in fact a distribution, with many possible values, each
<b>with its own frequency</b>.</li>
<li><b>Write down explicit guesses for the attributes of the user
set</b>. It is far better to be explicit and wrong than to be
vague.
<ol class="org-ol">
<li>The process of carefully guessing the frequencies will
cause the architect to think very carefully about the
expected user set.</li>
<li>Writing the frequencies down will subject them to debate,
which will illuminate all the participants and bring to the
surface the differences in the user images that the several
designers carry</li>
<li>Enumerating the frequencies explicitly helps everyone
recognize which decisions depend upon which user set
properties</li>
</ol></li>
</ul></li>
<li>2 Second-System in this book
<ul class="org-ul">
<li>The "second" system described in Chapter 5 is the second
system fielded, <i>the follow-on system that invites added
function and frills</i></li>
<li>The "second" system in Chapter 11 is <i>the second try at
building what should be the first system to be fielded</i>. It is
built under all the schedule, talent, and ignorance
constraints that characterize new projects—the constraints
that exert a slimness discipline.</li>
</ul></li>
</ul></li>
</ul></li>
<li>The Triumph of the WIMP Interface
<ul class="org-ul">
<li>WIMP
<ul class="org-ul">
<li>Windows</li>
<li>Icons</li>
<li>Menus</li>
<li>Pointing interface</li>
</ul></li>
<li>Conceptual integrity via a metaphor
<ul class="org-ul">
<li>The WIMP is a superb example of a user interface that has
conceptual integrity, achieved by the adoption of a familiar
mental model</li>
<li>The reliable interpretation of free-form generated English
commands is beyond the present state of the art
<ul class="org-ul">
<li>They wisely picked up from the usual desktop its one
example of command selection—the printed buck slip, on
which <b>the user selects from among a constrained menu of
commands</b> whose semantics are standardized.</li>
</ul></li>
</ul></li>
<li>Command utterances and the two-cursor problem
<ul class="org-ul">
<li>Two-cursor problem:
<b>One cursor is having to do the work of two</b>
<ol class="org-ol">
<li>pick an object in the desktop part of the window;</li>
<li>pick a verb in the menu portion</li>
</ol></li>
<li>A brilliant solution:
<b>Use one hand on the keyboard to specify verbs and the other
hand on a mouse to pick nouns</b></li>
<li>User power versus ease of use
<ul class="org-ul">
<li>One of the hardest issues facing software architects is
exactly <b>how to balance user power versus ease of use</b>.</li>
<li>The high-frequency menu verbs each have single-key +
command-key equivalents, mostly chosen so that they can
easily be struck as a single chord with the left hand.</li>
</ul></li>
<li>Incremental transition from novice to power user</li>
</ul></li>
<li>The fate of WIMP: Obsolescence
<ul class="org-ul">
<li>Pointing will still be the way to express nouns as we
command our machines;</li>
<li>Speech is surely the right way to express the verbs.</li>
</ul></li>
</ul></li>
<li>Don't Build One to Throw Away - The Waterfall Model Is Wrong!
<ol class="org-ol">
<li><b>it assumes a project goes through the process once</b>
<ul class="org-ul">
<li>The waterfall model assumes the mistakes will all be in the
realization,</li>
<li>Thus that their repair can be smoothly interspersed with
component and system testing.</li>
<li>One might discard and redesign the first system <b>piece by piece</b>,
rather than in one lump</li>
<li>The waterfall model puts system test, and therefore by implication
user testing, at the end of the construction process.</li>
</ul></li>
<li><b>It assumes one builds a whole system at once</b>
<ul class="org-ul">
<li>combining the pieces for an end-to-end system test after all
of the implementation design, most of the coding, and much of
the component testing has been done.</li>
<li><p>
<b>There has to be upstream movement</b>
</p>
<blockquote>
<p>
Designing the implementation will show that some
architectural features cripple performance; so the
architecture has to be reworked.
</p>
</blockquote></li>
</ul></li>
</ol></li>
<li>An Incremental-Build Model Is Better - Progressive Refinement
<ol class="org-ol">
<li><p>
Building an end-to-end skeleton system
</p>
<pre class="example">
Harlan Mills, working in a real-time system environment, early
advocated that we should build the basic polling loop of a real- time
system, with subroutine calls (stubs) for all the functions, but only
null subroutines. Compile it; test it. It goes round and round, doing
literally nothing, but doing it correctly.
</pre>
<ul class="org-ul">
<li><b>At every stage we have a running system</b></li>
<li>Since we have a working system at all times
<ol class="org-ol">
<li>we can begin user testing very early</li>
<li>we can adopt a build-to-budget strategy that protects
absolutely against schedule or budget overruns (at the cost
of possible functional shortfall).</li>
</ol></li>
</ul></li>
<li>Parnas Families
<ul class="org-ul">
<li><b>Designing a software product as a <i>family</i> of related products</b></li>
<li>To define their (both lateral extensions and succeeding
versions) function or platform differences so as to construct a
family tree of related products</li>
<li>Put near its root those design decisions that are less likely
to change.</li>
</ul></li>
<li><p>
Microsoft's "Build Every Night" Approach (CI/CD)
</p>
<blockquote>
<p>
After we first ship, we will be shipping later versions that add
more function to an existing, running product. Why should the
initial building process be different? Beginning at the time of
our first milestone [where the march to first ship has three
intermediate milestones] we rebuild the developing system every
night [and run the test cases]. The build cycle becomes the
heartbeat of the project. Every day one or more of the
programmer-tester teams check in modules with new
functions. After every build, we have a running system. If the
build breaks, we stop the whole process until the trouble is
found and fixed. At all times everybody on the team knows the
status.
</p>

<p>
It is really hard. You have to devote lots of resources, but it
is a disciplined process, a tracked and known process. It gives
the team credibility to itself. Your credibility determines your
morale, your emotional state.
</p>
</blockquote></li>
<li>Incremental-Build and Rapid Prototyping</li>
</ol></li>
<li>Parnas Was Right, and I Was Wrong about Information Hiding
<ul class="org-ul">
<li>Programmers are most effective if shielded from, not exposed to,
the innards of modules not their own</li>
<li><b>Information hiding is the only way of raising the level of
software design.</b></li>
<li>If we can limit design and building so that we only do the putting
together and parameterization of such chunks from pre-built
collections, we have radically raised the conceptual level, and
eliminated the vast amounts of work and the copious opportunities
for error that dwell at the individual statement level.</li>
<li>3 steps of information-hiding
<ol class="org-ol">
<li>Define a module as a software entity with its own data model
and its own set of operations</li>
<li>The upgrading of the module into an abstract data type
(<b>interface!</b>)
<ul class="org-ul">
<li>The abstract data type provides a uniform way of thinking about
and specifying <b>module interfaces</b>, and an access discipline
that is easy to enforce.</li>
</ul></li>
<li>OOP
<ul class="org-ul">
<li>inheritance</li>
</ul></li>
</ol></li>
<li>Modules are not just programs, but instead are <b>program products</b></li>
<li>Some people are vainly hoping for significant module reuse without
paying the initial cost of building product-quality
modules—generalized, robust, tested, and documented.</li>
</ul></li>
<li>How Mythical Is the Man-Month? Boehm's Model and Data
<ul class="org-ul">
<li>Adding more people to a late project always makes it more costly,
but it does not always cause it to be completed later</li>
<li>New people added late in a development project must be team
players willing to pitch in and work within the process, and not
attempt to alter or improve the process itself!</li>
<li><b>The work must be repartitioned</b>, a process I have often found to
be non trivial.</li>
</ul></li>
<li><b>People Are Everything</b> (Well, Almost Everything)
<ul class="org-ul">
<li><b>The quality of the people on a project</b>, and <b>their organization
and management</b>, are much more important factors in success than
are the tools they use or the technical approaches they take.</li>
<li>Peopleware
<ul class="org-ul">
<li><i>Peopleware: Productive Projects and Teams</i>
<ul class="org-ul">
<li><b>The manager's function is not to make people work, it is to
make it possible for people to work.</b></li>
</ul></li>
</ul></li>
</ul></li>
<li>The Power of Giving Up Power
<ul class="org-ul">
<li><b>Creativity comes from individuals and not from structures or
processes</b></li>
<li>The Principle of Subsidiary Function</li>
</ul></li>
<li>The State and Future of Software Engineering
<ul class="org-ul">
<li>Chemical engineering
<ol class="org-ol">
<li>rules of thumb</li>
<li>empirical nomograms</li>
<li>formulas for designing particular components</li>
<li>mathematical models for heat transport</li>
<li>mass transport</li>
<li>momentum transport in single vessels</li>
</ol></li>
<li>Software engineering is merely immature as chemical engineering
was in 1945</li>
<li>This complex craft will demand our continual development of the
discipline, our learning to compose in larger units, our best use
of new tools, our best adaptation of proven engineering management
methods, liberal application of common sense, and a God-given
humility to recognize our fallibility and limitations.</li>
</ul></li>
</ul>
</div>
</div>

    </div>
</section>
]]></description>
      <pubDate>2018-03-24</pubDate>
      <guid>http://dsdshcym.github.io/clipping/2018/03/24/clippings-from-the-mythical-man-month</guid>
    </item>
  </channel>
</rss>