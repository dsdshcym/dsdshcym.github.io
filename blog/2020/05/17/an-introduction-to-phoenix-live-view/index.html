<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>Phoenix LiveView 简介 - Yiming Chen</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@dsdshcym" />
  <meta name="twitter:creator" content="@dsdshcym" />
  <meta name="author" content="Yiming Chen" />
  <meta name="description" content="Phoenix LiveView 能让开发者们用最小的成本，开发出具有实时交互体验的 Web 应用。" />
  <meta name="keywords" content="nil" />
  <meta property="og:title" content="Phoenix LiveView 简介 - Yiming Chen" />
  <meta property="og:description" content="Phoenix LiveView 能让开发者们用最小的成本，开发出具有实时交互体验的 Web 应用。" />

  <link rel="alternate" title="RSS Feed" href="/rss.xml" type="application/rss+xml">
  <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  <link rel="stylesheet" href="/media/css/posts.css" type="text/css">
  <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
  <script src="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>

  <script src="/media/js/main.js"></script>
</head>

  <body class="container">
<header id="header">
    <body>
        <nav class="navbar navbar-default navbar-fixed-top" style="opacity: .9" role="navigation">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/">Yiming Chen</a>
                </div>
                <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="/blog/">Blog</a></li>
                        <li><a href="/clipping/">Clipping</a></li>
                        <li><a href="/tags/">Tags</a></li>
                        <li><a href="/about/">About</a></li>
                        <li><a href="https://github.com/dsdshcym">GitHub</a></li>
                        <li><a href="/rss.xml">RSS</a></li>
                        <li><a href="https://webring.xxiivv.com/#random">Webring</a></li>
                    </ul>
                </div>
            </div>
        </nav>
    </body>
</header>

<section id="content" role="main">
    <div id="post-container">
        <h1>Phoenix LiveView 简介</h1>
        <blockquote>
<p>
这是我在 <a href="https://mp.weixin.qq.com/s/7zvTxSAM8pyvjaPkAUqWtg">20200516 Elixir Meetup 线上活动</a> 里介绍 Phoenix LiveView 所用的讲稿。
Slide PDF 版本： <a href="https://gist.github.com/dsdshcym/4014b7e9c31cd4a0050c687b862c962f">202005 Elixir Meetup - Phoenix LiveView</a>
</p>
</blockquote>

<div id="outline-container-org4a68753" class="outline-2">
<h2 id="org4a68753">Demo</h2>
<div class="outline-text-2" id="text-org4a68753">
<div class="notes">
<p>
刚才陈天老师为我们分享了当 Elixir 有不足的时候，该如何引入其他的语言（Rust）进行补足。而我的分享可能刚好相反，是通过 Elixir 的强处，来实现一些其他语言难以实现的效果。希望能让大家体会到 Elixir 的优美和高效。
</p>

<p>
今天的主角是 Phoenix LiveView。
Phoenix LiveView 是由 Phoenix 官方团队在 2019 年 3 月正式推出的后端渲染框架。它所要解决的问题是：让开发者们用最小的成本，开发出具有实时交互体验的 Web 应用。那什么是「具有丰富的实时交互体验的 Web 应用」呢？让我们先来看两个 Demo:
</p>

</div>
</div>
<div id="outline-container-orgcea938e" class="outline-3">
<h3 id="orgcea938e">数独</h3>
<div class="outline-text-3" id="text-orgcea938e">
<div class="notes">
<p>
第一个 Demo 是一个数独解题器：用户可以在这个 9x9 的表单中填入数字，点击 "Start" 进行解题，并能实时地看到解题算法的每一步更新。更厉害的是，用户可以通过滑块实时地控制解题算法更新的间隔。而这些功能，都是用 Elixir 通过 Phoenix LiveView 加上一些简单的 HTML 和 CSS 实现的。
</p>

</div>

<div class="figure">
<p><img src="https://gist.githubusercontent.com/dsdshcym/4014b7e9c31cd4a0050c687b862c962f/raw/3d50388498e9cbec05bd973f9738129e8dbdbdd2/screencast.gif" alt="screencast.gif" width="50%" />
</p>
</div>
</div>
</div>
<div id="outline-container-org6d305e1" class="outline-3">
<h3 id="org6d305e1">Twitter</h3>
<div class="outline-text-3" id="text-org6d305e1">
<div class="notes">
<p>
这个 Demo 是一个 Twitter 克隆。从这个录屏中，我们可以看到，在一个客户端中创建的新推文，被实时地推送到了另外的客户端上。这些功能，就是通过 Phoenix LiveView 在 15 分钟内迅速实现的（不包括前端样式部分）。
</p>

</div>
<p>
<a href="https://www.youtube.com/watch?v=MZvmYaFkNJI&amp;feature=emb_title">Build a real-time Twitter clone in 15 minutes</a>
</p>

<div class="figure">
<p><img src="https://gist.githubusercontent.com/dsdshcym/4014b7e9c31cd4a0050c687b862c962f/raw/3d50388498e9cbec05bd973f9738129e8dbdbdd2/twitter.gif" alt="twitter.gif" width="75%" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org4389bf9" class="outline-2">
<h2 id="org4389bf9">Agenda</h2>
<div class="outline-text-2" id="text-org4389bf9">
<div class="notes">
<p>
看过了这两个 Demo，相信大家都能体会到 Phoenix LiveView 的强大。那就让我们正式进入今天的主题吧！
</p>

</div>
</div>
<div id="outline-container-org63fe648" class="outline-3">
<h3 id="org63fe648">What's in this talk</h3>
<div class="outline-text-3" id="text-org63fe648">
<div class="notes">
<p>
今天的分享主要包含三个部分：
</p>
<ol class="org-ol">
<li>LiveView 要解决什么问题？通过回答这个问题，我们可以明确 LiveView 的定位，理解它背后的设计逻辑。</li>
<li>LiveView 把这个问题解决了吗？通过这个问题，我们可以知道 LiveView 的优势与劣势，帮助我们决定是否要学习、使用 LiveView。</li>
<li>LiveView 是怎么解决这个问题的？最后，我们会一起看看 LiveView 背后的实现机制，更好地理解这个强大的框架。</li>
</ol>

</div>
<ol class="org-ol">
<li>LiveView 要解决什么问题？</li>
<li>LiveView 把这个问题解决了吗？</li>
<li>LiveView 是怎么解决这个问题的？</li>
</ol>
</div>
</div>
<div id="outline-container-org3ec9ebc" class="outline-3">
<h3 id="org3ec9ebc">What's not in this talk</h3>
<div class="outline-text-3" id="text-org3ec9ebc">
<div class="notes">
<p>
另外，这次分享并不会介绍如何使用 Phoenix LiveView。大家可以参考官方和社区提供的教程。
</p>

</div>

<p>
怎么使用 Phoenix LiveView
</p>
<ul class="org-ul">
<li><a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html">Phoenix.LiveView — phoenix_live_view v0.12.1</a></li>
<li><a href="https://elixirschool.com/blog/phoenix-live-view/">Walk-Through of Phoenix LiveView · Elixir School</a></li>
<li><a href="https://pragmaticstudio.com/phoenix-liveview">Phoenix LiveView - The Pragmatic Studio</a></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga847acd" class="outline-2">
<h2 id="orga847acd">LiveView 要解决什么问题？</h2>
<div class="outline-text-2" id="text-orga847acd">
<div class="notes">
<p>
LiveView 希望解决的问题其实正是 Phoenix 框架本身在开发之初所要解决的问题：实时的用户交互体验。
</p>

</div>
</div>
<div id="outline-container-org3a0aeb1" class="outline-3">
<h3 id="org3a0aeb1">实时的用户交互体验</h3>
<div class="outline-text-3" id="text-org3a0aeb1">
<div class="notes">
<ol class="org-ol">
<li>在 Web 技术刚出现时的 Web 1.0 时代，通过 HTTP 请求网页，显示静态的文字、图片内容，已经能够满足用户的需求。</li>
<li>而在 Web 2.0 时代，GMail 等使用 AJAX 技术的应用不断涌现。这些应用在静态页面的基础上，动态地请求服务器的数据，及时地将数据变动更新到用户端。</li>
<li>现在，JavaScript 及其框架不断更新迭代，用户对数据实时性、界面交互性的要求越来越高。提供一个实时的、高度交互的用户体验成为了大部分 Web 应用的基本要求。
<ul class="org-ul">
<li>在搜索时，我们不再满足于一个空荡荡的搜索框，还希望这个搜索框能够补全要搜索的内容。</li>
<li>在填写表单时，我们不再满足于在提交表单之后再收到错误提示，而希望在输入时就得到对应的反馈。</li>
<li>在聊天时，我们谁也不会通过刷新页面来获取新的消息，而是希望新消息实时地出现在屏幕上。</li>
</ul></li>
</ol>

<p>
我们可以看一些具体的例子演示。
(Demo <a href="https://github.com/chrismccord/phoenix_live_view_example">chrismccord/phoenix_live_view_example</a> in Chrome)
</p>
<ol class="org-ol">
<li><p>
Weather
</p>

<p>
这是 Phoenix LiveView 官方提供的一些样例。
</p>

<p>
在主页里我们可以看到 LiveView 最基本的应用：天气查询。
</p>

<p>
这里对天气信息的更新全是在 Elixir 里实现的，我们不需要写一行 JavaScript 代码。
</p></li>
<li><p>
Search
</p>

<p>
这是另一个样例：词典搜索。
</p>

<p>
用户在输入时，LiveView 会实时地给出单词的补全。在查询时，LiveView 会请求第三方词典 API，获得单词的解释之后，再将其渲染到客户端。
</p>

<p>
(Demo)
</p>

<p>
值得注意的是，在请求第三方客户端时，LiveView 会显示「Searching」，让用户得到适当的反馈。这对于一些后端比较耗时的操作来说，是很有必要的。
</p></li>
<li><p>
Form
</p>

<p>
第二个例子是一个实时表单。
</p>

<p>
当用户在表单里填入信息时，LiveView 会实时地给出错误提示。这样一来，用户就不必等到提交表单之后才知道自己的 Email 格式不正确，或者已经被人使用了等错误，避免了重复提交表单的繁琐。
</p></li>
</ol>

</div>
<ol class="org-ol">
<li>搜索框自动补全</li>
<li>表单实时验证</li>
<li>实时聊天</li>
</ol>
</div>
</div>
<div id="outline-container-org1d9a432" class="outline-3">
<h3 id="org1d9a432">已有的解决方案</h3>
<div class="outline-text-3" id="text-org1d9a432">
<div class="notes">
<p>
但是，现有的解决方案都不尽如人意。为了实现复杂的实时交互体验，开发团队需要投入大量的时间成本、人力成本开发、维护前后端的应用。交互体验与开发成本之间，似乎构成了一种「鱼和熊掌不可得兼」的对立关系。我们可以先对已有的解决方案进行简单地对比。
</p>

</div>
</div>
<div id="outline-container-org7048060" class="outline-4">
<h4 id="org7048060">单页应用（Single Page Application）</h4>
<div class="outline-text-4" id="text-org7048060">
<div class="notes">
<p>
首先，当下最火热的解决方案就是单页应用框架。
</p>

<p>
它们能够实现最复杂的页面交互效果、逻辑。用户甚至可以在下载了应用之后，离线使用。最典型的例子是 Google Docs 和 Figma 这类协作创造工具。（Google Docs 并不能离线使用，Figma 离线时可使用的功能也是受限的）
</p>

<p>
但是，实现这些交互的代价可能是巨大的。前后端的分离意味着开发者需要使用两套开发语言、框架，开发效率较低。同时维护前端应用和后端 API 也带来了极高的维护成本。
</p>

<p>
另外，这个方案对搜索引擎的爬虫并不友好，为了搜索引擎优化（SEO）可能需要服务端渲染（SSR）等额外的技术开销。
</p>

</div>
<ul class="org-ul">
<li>应用
<ul class="org-ul">
<li>Google Docs</li>
<li>Figma</li>
</ul></li>
<li>优势
<ul class="org-ul">
<li>可以实现最为复杂的交互、动画效果</li>
<li>可以离线使用</li>
</ul></li>
<li>劣势
<ul class="org-ul">
<li>开发效率低下</li>
<li>对 SEO 不友好</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org277e5d9" class="outline-4">
<h4 id="org277e5d9">AJAX 应用（服务端 API + jQuery）</h4>
<div class="outline-text-4" id="text-org277e5d9">
<div class="notes">
<p>
另外，我们也有比较传统的解决方案：在 Ruby on Rails, Phoenix 这些服务端渲染框架的基础上，在 HTML 页面渲染之后，通过 jQuery 等 JavaScript Library 发起 AJAX 请求，接收到 JSON 返回之后更新用户界面，达到实时交互的效果。
</p>

<p>
这种方案的部署、维护成本较低，初期的代码复杂度比较低，开发效率较高。但是当应用对实时性、交互性的要求逐渐增加，前端代码的维护成本也是极高的，这也是 React, Vue.js 这些前端框架火热的原因。另外，用较低的代码复杂度换来的也只是少许的实时交互效果，一些复杂的需求（比如，服务端向客户端实时推送数据）就很难实现。而应用页面之间的切换往往还是依赖一次完整的页面请求，相比 API 请求会传输更多的数据，加载速度更慢，用户体验差。
</p>

</div>
<ul class="org-ul">
<li>例子
<ul class="org-ul">
<li>Ruby on Rails</li>
<li>Phoenix (without LiveView)</li>
</ul></li>
<li>应用
<ul class="org-ul">
<li>Gmail</li>
</ul></li>
<li>优势
<ul class="org-ul">
<li>初期代码复杂度相对较低，开发效率较高</li>
<li>对 SEO 友好</li>
</ul></li>
<li>劣势
<ul class="org-ul">
<li>实时性弱，数据更新往往需要通过刷新页面来获取</li>
<li>请求速度慢（每次刷新都重新获取数据）</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org930b628" class="outline-4">
<h4 id="org930b628">介于两者之间的解决方案</h4>
<div class="outline-text-4" id="text-org930b628">
<div class="notes">
<p>
当然，在单页应用和 AJAX 应用之间也已经有了许多不同的解决方案。
</p>

<p>
像 Basecamp 就在 Rails 的基础上开发了 Turbolinks 技术，通过传输 HTML partials 在 AJAX 应用的基础上实现了类似单页应用的效果。
</p>

<p>
但是，这类已有的解决方案要么存在着性能问题，不适合大规模使用，要么就是在开发效率和实时性之间做了取舍。鱼和熊掌难以兼得。
</p>

</div>
<ul class="org-ul">
<li>例子
<ul class="org-ul">
<li>Turbolinks</li>
<li>Stimulus</li>
</ul></li>
<li>应用
<ul class="org-ul">
<li>Basecamp</li>
</ul></li>
<li>开发效率与实时性均在单页应用和 AJAX 应用之间</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org02cd7a2" class="outline-3">
<h3 id="org02cd7a2">更快速的开发+更实时的交互</h3>
<div class="outline-text-3" id="text-org02cd7a2">
<div class="notes">
<p>
我们可以用这么一张图总结。
</p>
<ul class="org-ul">
<li>横坐标代表的是应用交互体验的实时性，从左到右逐渐加强。</li>
<li>纵坐标代表的是应用的开发成本，从下到上逐渐增加。</li>
</ul>
<p>
已有的解决方案分布在从左下到右上的对角线上。而 Phoenix LiveView 的目标在右下角。
</p>

<p>
也就是说，如何快速地、低成本地开发出带有实时交互体验的 Web 应用，并且满足生产环境的性能、SEO 需求，就是 Phoenix 和 Phoenix LiveView 希望解决的问题。
</p>

</div>

<div class="figure">
<p><object type="image/svg+xml" data="https://gist.githubusercontent.com/dsdshcym/4014b7e9c31cd4a0050c687b862c962f/raw/3d50388498e9cbec05bd973f9738129e8dbdbdd2/spectrum.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orge35426d" class="outline-2">
<h2 id="orge35426d">LiveView 把问题解决了吗？</h2>
<div class="outline-text-2" id="text-orge35426d">
<div class="notes">
<p>
讨论完了 LiveView 的目标，我们现在可以看看在发布了一年之后，LiveView 把这些目标完成得怎么样，具备了哪些优势，还存在哪些劣势。
</p>

</div>
</div>
<div id="outline-container-org7833f0e" class="outline-3">
<h3 id="org7833f0e">LiveView 的优势</h3>
<div class="outline-text-3" id="text-org7833f0e">
<div class="notes">
<p>
Phoenix LiveView 因为站在 Erlang OTP, Elixir, Phoenix 这些巨人们的肩膀上，在出生伊始，就具备了其他解决方案无法比拟的四大优势：
</p>

</div>
<ol class="org-ol">
<li>满足大部分实时交互需求</li>
<li>高效的开发体验</li>
<li>极致的性能</li>
<li>SEO 友好</li>
</ol>
</div>
<div id="outline-container-org901c86c" class="outline-4">
<h4 id="org901c86c">满足大部分实时交互需求</h4>
<div class="outline-text-4" id="text-org901c86c">
<div class="notes">
<p>
首先，LiveView 目前已经能够支持大部分 Web Application 中需要实时交互的场景。
</p>

<p>
除了满足基本的 CRUD 操作更新、服务端推送数据更新之外，
LiveView 还提供了 JavaScript Hook functions 满足更加定制化的需求（比如：无限滚动加载、DOM 元素更新时的动画效果、与 JavaScript 第三方库的交互 等等）
</p>

</div>
<dl class="org-dl">
<dt>CRUD 操作的实时更新</dt><dd>Twitter Timeline</dd>
<dt>服务端主动推送数据更新至客户端</dt><dd>Phoenix Live Dashboard</dd>
<dt>提供 JavaScript Hook functions 进行定制</dt><dd>Infinite scroll</dd>
</dl>
</div>
</div>
<div id="outline-container-org9bda8cd" class="outline-4">
<h4 id="org9bda8cd">高效的开发体验</h4>
<div class="outline-text-4" id="text-org9bda8cd">
<div class="notes">
<p>
其次，LiveView 应用的开发是极其高效的，之前展示的所有例子，核心代码都不超过 100 行。
</p>

<p>
这里展示的是「天气查询」的 LiveView component 代码，开发者只需要负责实现核心业务的部分：
</p>
<ol class="org-ol">
<li><code>render</code>: HTML template</li>
<li>LiveView component callbacks
<ol class="org-ol">
<li><code>mount</code>: component 的初始化</li>
<li><code>handle_event</code>: 用户事件的处理逻辑</li>
</ol></li>
<li><code>weather</code>: 后端业务逻辑</li>
</ol>

<p>
而我们作为开发者不用考虑该如何设计后端 API 的请求路径、返回数据结构，如何追踪数据的变化，如何通知客户端数据的更新，如何在前端接收 API 返回、解析、更新 DOM 结构等非核心业务逻辑，
LiveView 帮我们打理好了这一切，并且比我们大多数人设计得更好。
</p>

<p>
这也正是 LiveView 为什么能如此显著地提高开发效率的原因：
<b>开发者只用关心核心业务逻辑</b>
</p>

</div>
<div class="org-src-container">
<pre class="src src-elixir">def render(assigns) do
  ~L"""
  &lt;div&gt;
    &lt;form phx-submit="set-location"&gt;
      &lt;input name="location" placeholder="Location" value="&lt;%= @location %&gt;"/&gt;
      &lt;%= @weather %&gt;
    &lt;/form&gt;
  &lt;/div&gt;
  """
end

def mount(_params, _session, socket) do
  {:ok, assign(socket, location: "Shanghai", weather: weather("Shanghai"))}
end

def handle_event("set-location", %{"location" =&gt; location}, socket) do
  {:noreply, put_location(socket, location)}
end

defp put_location(socket, location) do
  assign(socket, location: location, weather: weather(location))
end

defp weather(local) do
  {:ok, {{_, 200, _}, _, body}} =
    :httpc.request(:get, {~c"http://wttr.in/#{URI.encode(local)}?format=1", []}, [], [])

  IO.iodata_to_binary(body)
end
</pre>
</div>
</div>
</div>
<div id="outline-container-org61c05d7" class="outline-4">
<h4 id="org61c05d7">极致的性能</h4>
<div class="outline-text-4" id="text-org61c05d7">
<div class="notes">
<p>
除去高效的开发体验之外，LiveView 另外一个出彩的地方就是它出色的性能。
</p>

<p>
正如刚才提到的，LiveView 帮我们实现了对状态的管理、变化追踪、同步，它在这些功能的实现上都是极其高效的：
</p>
<ol class="org-ol">
<li>LiveView 在渲染模版时会区分出静态的模版内容和可能动态变化的内容；静态的内容不会随着数据变化或者用户的操作而变化，因此 LiveView 只会在初次渲染时将静态内容传输到客户端；之后的数据更新都只包含动态变化的部分</li>
<li>而且在传输动态数据的更新时，LiveView 只会传输需要更新的数据，前端再结合已有的静态模版，更新 DOM 结构。</li>
<li>最后，LiveView 目前使用 JSON 与前端通信，之后计划增加对 Erlang Term Format 这种数据格式的支持，提高服务端的负载能力，并且进一步减少更新时的数据包大小。</li>
</ol>

<p>
而在可扩展方面，因为有着 Erlang OTP, Elixir, Phoenix 这些得天独厚的优势，无论是纵向扩展还是横向扩展都没有问题。
</p>
<ul class="org-ul">
<li>纵向扩展方面，Phoenix Channel 在一台 40 核 128GB 内存的服务器上可以支撑 2000000 的 WebSocket 连接服务。</li>
<li>横向扩展方面，Erlang OTP 可以连接多台机器组成集群。</li>
</ul>

</div>
<ol class="org-ol">
<li>diff 机制高效，且仍有优化空间
<ol class="org-ol">
<li>区分静态内容与动态内容</li>
<li>只传输变化的数据 diff</li>
<li><a href="https://github.com/phoenixframework/phoenix_live_view/issues/616">JSON -&gt; Erlang Term Format (ETF)</a></li>
</ol></li>
<li><p>
纵向扩展有 Phoenix Channel 做保障
</p>

<p>
(<a href="https://www.phoenixframework.org/blog/the-road-to-2-million-websocket-connections">The Road to 2 Million Websocket Connections</a>)
</p></li>
<li>横向扩展有 Erlang OTP 做保障</li>
</ol>
</div>
</div>
<div id="outline-container-org6ede599" class="outline-4">
<h4 id="org6ede599">SEO 友好</h4>
<div class="outline-text-4" id="text-org6ede599">
<div class="notes">
<p>
最后，因为 LiveView 本身就运行在一个 Phoenix 应用中，给爬虫渲染 HTML 这个原本并不复杂的任务根本不在话下。
</p>

<p>
LiveView 会在请求开始的首次渲染时返回完整的 HTML response。这样，无论是浏览器还是爬虫，都能正常地拿到要渲染的数据。
</p>

<p>
之后，LiveView 才会通过 JavaScript 调用 WebSocket 启动 LiveView 生命周期，保证浏览器里数据的正常更新。
</p>

<p>
因此，使用 LiveView 并不会对 SEO 有任何影响，因为这本就是一个服务端渲染的页面。
</p>

</div>
<ol class="org-ol">
<li>首次渲染默认返回完整的 HTML response</li>
<li>HTML 渲染结束之后再建立 WebSocket 连接启动 LiveView 生命周期</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgbce47e6" class="outline-3">
<h3 id="orgbce47e6">LiveView 的劣势</h3>
<div class="outline-text-3" id="text-orgbce47e6">
<div class="notes">
<p>
说完了 LiveView 的优势，LiveView 当然也有着它的缺陷与劣势。这些劣势主要都是源于 LiveView 对 WebSocket 的依赖。
</p>

<p>
LiveView 需要 WebSocket 才能正常接收数据更新，因此即使用户把页面缓存之后，在离线状态下也是无法正常使用的。
</p>

<p>
而如果网络的延迟很高，对 LiveView 应用的用户体验也会有很明显的影响。如果需要实现 CSS 动画或者多人游戏这类对低延迟、高帧率有要求的功能时，LiveView 也显然不是合适的选择。
</p>

<p>
在此，我必须要为 LiveView 稍作开脱。毕竟，又有多少应用、框架能够实现这个受到物理世界因素限制的需求呢？大部分应用也只是通过缓存、过场动画等用户体验上的改善，让用户体会不到网络延迟的存在，而这些改善用 LiveView 也同样能够实现。而且，LiveView 团队已经在开发相关的功能尝试解决这些问题：
</p>
<ol class="org-ol">
<li>在断线状态对客户端更新进行缓存，连线之后上传更新。</li>
<li>提供开发环境下的延迟模拟功能，供开发者调试。</li>
</ol>

</div>
<ol class="org-ol">
<li>无法在离线状态下正常使用
<ul class="org-ul">
<li>复杂的本地应用（例：Figma）</li>
</ul></li>
<li>用户体验容易受到延迟影响
<ul class="org-ul">
<li>游戏</li>
<li>动画效果</li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org0498618" class="outline-2">
<h2 id="org0498618">LiveView 是如何实现的？</h2>
<div class="outline-text-2" id="text-org0498618">
<div class="notes">
<p>
那么，如此强大的 LiveView 是如何实现的呢？
</p>

<ol class="org-ol">
<li>首先，浏览器通过 Phoenix Channel 与服务器建立 WebSocket 连接。之后会在 <code>phx-*</code> 对应的事件发生后发送 WebSocket 请求至后端服务器。</li>
<li>后端服务器的 Phoenix LiveView Channel GenServer 接收到请求之后，会调用对应的 LiveView module 中的 <code>handle_event/3</code> callback。</li>
<li>我们在应用中定义的 LiveView module 对数据状态进行更新，以 tuple 返回值的形式交还给 LiveView Channel GenServer。</li>
<li>数据状态更新完成之后，LiveView.Channel 调用 LiveView.Diff 生成 diff 数据。</li>
<li>LiveView Channel GenServer 推送 diff/redirect/render 更新到客户端。</li>
<li>客户端接收数据之后，通过 morphdom 这个 JavaScript library 对 DOM 结构进行更新，并且调用对应的 JavaScript hooks。</li>
</ol>

<p>
这是 LiveView 底层实现细节的一个简单介绍，具体的细节大家可以阅读 phoenix_live_view/channel.ex 中的源码。
</p>

</div>

<div class="figure">
<p><img src="https://gist.githubusercontent.com/dsdshcym/4014b7e9c31cd4a0050c687b862c962f/raw/3d50388498e9cbec05bd973f9738129e8dbdbdd2/flow.png" alt="flow.png" width="75%" />
</p>
</div>
<ul class="org-ul">
<li><a href="https://github.com/patrick-steele-idem/morphdom">patrick-steele-idem/morphdom</a></li>
<li><a href="https://github.com/phoenixframework/phoenix_live_view/blob/e102da323feceab588a1a090e7d0b766c9e099b8/lib/phoenix_live_view/channel.ex#L81-L92">phoenix_live_view/channel.ex</a></li>
</ul>
</div>
</div>
<div id="outline-container-org464969e" class="outline-2">
<h2 id="org464969e">谢谢！</h2>
<div class="outline-text-2" id="text-org464969e">
<div class="notes">
<p>
最后，谢谢大家参加这次分享！也欢迎大家随时找我交流。
</p>

</div>
<ul class="org-ul">
<li><a href="https://yiming.dev/">Blog - Yiming Chen</a></li>
<li><a href="https://github.com/chrismccord/phoenix_live_view_example">chrismccord/phoenix_live_view_example</a></li>
<li><a href="https://github.com/dsdshcym/phoenix_live_view_sudoku">dsdshcym/phoenix_live_view_sudoku</a></li>
<li><a href="https://www.youtube.com/watch?v=MZvmYaFkNJI&amp;feature=emb_title">Build a real-time Twitter clone in 15 minutes</a></li>
<li><a href="https://taian.su/2019-03-25-phoenix-liveview/">Phoenix LiveView 概念篇 - Tai An, Su</a></li>
<li><a href="https://pragmaticstudio.com/phoenix-liveview">Phoenix LiveView - The Pragmatic Studio</a></li>
</ul>
</div>
</div>

    </div>
</section>


    <div class="post-meta">
        <span title="post date" class="post-info">2020-05-17</span>
        <span title="last modification date" class="post-info">2020-05-17</span>
        <span title="tags" class="post-info"><a href="/tags/phoenix/">Phoenix</a>, <a href="/tags/elixir/">Elixir</a>, <a href="/tags/liveview/">LiveView</a></span>
        <span title="author" class="post-info">Yiming Chen</span>
    </div>
  <section>
    <h1>Comments</h1>
    <script src="https://utteranc.es/client.js"
      repo="dsdshcym/dsdshcym.github.io"
      issue-term="title"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  </section>
<footer class="footer">
  <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> (<a href="http://orgmode.org">Org mode</a>)</p>
  <p>
    Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:dsdshcym &lt;at&gt; gmail &lt;dot&gt; com">Yiming Chen</a>
    &nbsp;&nbsp;-&nbsp;&nbsp;
    Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
    <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
  </p>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-152951733-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-152951733-1');
</script>

  </body>
</html>
